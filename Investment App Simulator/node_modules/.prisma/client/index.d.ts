
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model Status
 * 
 */
export type Status = $Result.DefaultSelection<Prisma.$StatusPayload>
/**
 * Model Person
 * 
 */
export type Person = $Result.DefaultSelection<Prisma.$PersonPayload>
/**
 * Model TaskAssignment
 * 
 */
export type TaskAssignment = $Result.DefaultSelection<Prisma.$TaskAssignmentPayload>
/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model Stock
 * 
 */
export type Stock = $Result.DefaultSelection<Prisma.$StockPayload>
/**
 * Model FavoriteStock
 * 
 */
export type FavoriteStock = $Result.DefaultSelection<Prisma.$FavoriteStockPayload>
/**
 * Model HistPrice
 * 
 */
export type HistPrice = $Result.DefaultSelection<Prisma.$HistPricePayload>
/**
 * Model LimitOrder
 * 
 */
export type LimitOrder = $Result.DefaultSelection<Prisma.$LimitOrderPayload>
/**
 * Model Trade
 * 
 */
export type Trade = $Result.DefaultSelection<Prisma.$TradePayload>
/**
 * Model News
 * 
 */
export type News = $Result.DefaultSelection<Prisma.$NewsPayload>
/**
 * Model BlogPost
 * 
 */
export type BlogPost = $Result.DefaultSelection<Prisma.$BlogPostPayload>
/**
 * Model BlogComment
 * 
 */
export type BlogComment = $Result.DefaultSelection<Prisma.$BlogCommentPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Referral
 * 
 */
export type Referral = $Result.DefaultSelection<Prisma.$ReferralPayload>
/**
 * Model ReferralUsage
 * 
 */
export type ReferralUsage = $Result.DefaultSelection<Prisma.$ReferralUsagePayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model FavoriteApi
 * 
 */
export type FavoriteApi = $Result.DefaultSelection<Prisma.$FavoriteApiPayload>
/**
 * Model Goal
 * 
 */
export type Goal = $Result.DefaultSelection<Prisma.$GoalPayload>
/**
 * Model RedeemBy
 * 
 */
export type RedeemBy = $Result.DefaultSelection<Prisma.$RedeemByPayload>
/**
 * Model QuizQuestion
 * 
 */
export type QuizQuestion = $Result.DefaultSelection<Prisma.$QuizQuestionPayload>
/**
 * Model Reward
 * 
 */
export type Reward = $Result.DefaultSelection<Prisma.$RewardPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Tasks
 * const tasks = await prisma.task.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Tasks
   * const tasks = await prisma.task.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs, $Utils.Call<Prisma.TypeMapCb, {
    extArgs: ExtArgs
  }>, ClientOptions>

      /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.status`: Exposes CRUD operations for the **Status** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Statuses
    * const statuses = await prisma.status.findMany()
    * ```
    */
  get status(): Prisma.StatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.person`: Exposes CRUD operations for the **Person** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more People
    * const people = await prisma.person.findMany()
    * ```
    */
  get person(): Prisma.PersonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskAssignment`: Exposes CRUD operations for the **TaskAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskAssignments
    * const taskAssignments = await prisma.taskAssignment.findMany()
    * ```
    */
  get taskAssignment(): Prisma.TaskAssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stock`: Exposes CRUD operations for the **Stock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stocks
    * const stocks = await prisma.stock.findMany()
    * ```
    */
  get stock(): Prisma.StockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.favoriteStock`: Exposes CRUD operations for the **FavoriteStock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FavoriteStocks
    * const favoriteStocks = await prisma.favoriteStock.findMany()
    * ```
    */
  get favoriteStock(): Prisma.FavoriteStockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.histPrice`: Exposes CRUD operations for the **HistPrice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HistPrices
    * const histPrices = await prisma.histPrice.findMany()
    * ```
    */
  get histPrice(): Prisma.HistPriceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.limitOrder`: Exposes CRUD operations for the **LimitOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LimitOrders
    * const limitOrders = await prisma.limitOrder.findMany()
    * ```
    */
  get limitOrder(): Prisma.LimitOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trade`: Exposes CRUD operations for the **Trade** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trades
    * const trades = await prisma.trade.findMany()
    * ```
    */
  get trade(): Prisma.TradeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.news`: Exposes CRUD operations for the **News** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more News
    * const news = await prisma.news.findMany()
    * ```
    */
  get news(): Prisma.NewsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blogPost`: Exposes CRUD operations for the **BlogPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlogPosts
    * const blogPosts = await prisma.blogPost.findMany()
    * ```
    */
  get blogPost(): Prisma.BlogPostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blogComment`: Exposes CRUD operations for the **BlogComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlogComments
    * const blogComments = await prisma.blogComment.findMany()
    * ```
    */
  get blogComment(): Prisma.BlogCommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.referral`: Exposes CRUD operations for the **Referral** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Referrals
    * const referrals = await prisma.referral.findMany()
    * ```
    */
  get referral(): Prisma.ReferralDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.referralUsage`: Exposes CRUD operations for the **ReferralUsage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReferralUsages
    * const referralUsages = await prisma.referralUsage.findMany()
    * ```
    */
  get referralUsage(): Prisma.ReferralUsageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.favoriteApi`: Exposes CRUD operations for the **FavoriteApi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FavoriteApis
    * const favoriteApis = await prisma.favoriteApi.findMany()
    * ```
    */
  get favoriteApi(): Prisma.FavoriteApiDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.goal`: Exposes CRUD operations for the **Goal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Goals
    * const goals = await prisma.goal.findMany()
    * ```
    */
  get goal(): Prisma.GoalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.redeemBy`: Exposes CRUD operations for the **RedeemBy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RedeemBies
    * const redeemBies = await prisma.redeemBy.findMany()
    * ```
    */
  get redeemBy(): Prisma.RedeemByDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizQuestion`: Exposes CRUD operations for the **QuizQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizQuestions
    * const quizQuestions = await prisma.quizQuestion.findMany()
    * ```
    */
  get quizQuestion(): Prisma.QuizQuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reward`: Exposes CRUD operations for the **Reward** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rewards
    * const rewards = await prisma.reward.findMany()
    * ```
    */
  get reward(): Prisma.RewardDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.3.1
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Task: 'Task',
    Status: 'Status',
    Person: 'Person',
    TaskAssignment: 'TaskAssignment',
    Company: 'Company',
    Stock: 'Stock',
    FavoriteStock: 'FavoriteStock',
    HistPrice: 'HistPrice',
    LimitOrder: 'LimitOrder',
    Trade: 'Trade',
    News: 'News',
    BlogPost: 'BlogPost',
    BlogComment: 'BlogComment',
    User: 'User',
    Referral: 'Referral',
    ReferralUsage: 'ReferralUsage',
    Comment: 'Comment',
    FavoriteApi: 'FavoriteApi',
    Goal: 'Goal',
    RedeemBy: 'RedeemBy',
    QuizQuestion: 'QuizQuestion',
    Reward: 'Reward'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "task" | "status" | "person" | "taskAssignment" | "company" | "stock" | "favoriteStock" | "histPrice" | "limitOrder" | "trade" | "news" | "blogPost" | "blogComment" | "user" | "referral" | "referralUsage" | "comment" | "favoriteApi" | "goal" | "redeemBy" | "quizQuestion" | "reward"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      Status: {
        payload: Prisma.$StatusPayload<ExtArgs>
        fields: Prisma.StatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusPayload>
          }
          findFirst: {
            args: Prisma.StatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusPayload>
          }
          findMany: {
            args: Prisma.StatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusPayload>[]
          }
          create: {
            args: Prisma.StatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusPayload>
          }
          createMany: {
            args: Prisma.StatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusPayload>[]
          }
          delete: {
            args: Prisma.StatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusPayload>
          }
          update: {
            args: Prisma.StatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusPayload>
          }
          deleteMany: {
            args: Prisma.StatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusPayload>
          }
          aggregate: {
            args: Prisma.StatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStatus>
          }
          groupBy: {
            args: Prisma.StatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<StatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.StatusCountArgs<ExtArgs>
            result: $Utils.Optional<StatusCountAggregateOutputType> | number
          }
        }
      }
      Person: {
        payload: Prisma.$PersonPayload<ExtArgs>
        fields: Prisma.PersonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          findFirst: {
            args: Prisma.PersonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          findMany: {
            args: Prisma.PersonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>[]
          }
          create: {
            args: Prisma.PersonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          createMany: {
            args: Prisma.PersonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>[]
          }
          delete: {
            args: Prisma.PersonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          update: {
            args: Prisma.PersonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          deleteMany: {
            args: Prisma.PersonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PersonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          aggregate: {
            args: Prisma.PersonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePerson>
          }
          groupBy: {
            args: Prisma.PersonGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersonGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonCountArgs<ExtArgs>
            result: $Utils.Optional<PersonCountAggregateOutputType> | number
          }
        }
      }
      TaskAssignment: {
        payload: Prisma.$TaskAssignmentPayload<ExtArgs>
        fields: Prisma.TaskAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload>
          }
          findFirst: {
            args: Prisma.TaskAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload>
          }
          findMany: {
            args: Prisma.TaskAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload>[]
          }
          create: {
            args: Prisma.TaskAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload>
          }
          createMany: {
            args: Prisma.TaskAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload>[]
          }
          delete: {
            args: Prisma.TaskAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload>
          }
          update: {
            args: Prisma.TaskAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.TaskAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload>
          }
          aggregate: {
            args: Prisma.TaskAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskAssignment>
          }
          groupBy: {
            args: Prisma.TaskAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<TaskAssignmentCountAggregateOutputType> | number
          }
        }
      }
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      Stock: {
        payload: Prisma.$StockPayload<ExtArgs>
        fields: Prisma.StockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          findFirst: {
            args: Prisma.StockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          findMany: {
            args: Prisma.StockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>[]
          }
          create: {
            args: Prisma.StockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          createMany: {
            args: Prisma.StockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>[]
          }
          delete: {
            args: Prisma.StockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          update: {
            args: Prisma.StockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          deleteMany: {
            args: Prisma.StockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          aggregate: {
            args: Prisma.StockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStock>
          }
          groupBy: {
            args: Prisma.StockGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockCountArgs<ExtArgs>
            result: $Utils.Optional<StockCountAggregateOutputType> | number
          }
        }
      }
      FavoriteStock: {
        payload: Prisma.$FavoriteStockPayload<ExtArgs>
        fields: Prisma.FavoriteStockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FavoriteStockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteStockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FavoriteStockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteStockPayload>
          }
          findFirst: {
            args: Prisma.FavoriteStockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteStockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FavoriteStockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteStockPayload>
          }
          findMany: {
            args: Prisma.FavoriteStockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteStockPayload>[]
          }
          create: {
            args: Prisma.FavoriteStockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteStockPayload>
          }
          createMany: {
            args: Prisma.FavoriteStockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FavoriteStockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteStockPayload>[]
          }
          delete: {
            args: Prisma.FavoriteStockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteStockPayload>
          }
          update: {
            args: Prisma.FavoriteStockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteStockPayload>
          }
          deleteMany: {
            args: Prisma.FavoriteStockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FavoriteStockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FavoriteStockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteStockPayload>
          }
          aggregate: {
            args: Prisma.FavoriteStockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFavoriteStock>
          }
          groupBy: {
            args: Prisma.FavoriteStockGroupByArgs<ExtArgs>
            result: $Utils.Optional<FavoriteStockGroupByOutputType>[]
          }
          count: {
            args: Prisma.FavoriteStockCountArgs<ExtArgs>
            result: $Utils.Optional<FavoriteStockCountAggregateOutputType> | number
          }
        }
      }
      HistPrice: {
        payload: Prisma.$HistPricePayload<ExtArgs>
        fields: Prisma.HistPriceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HistPriceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistPricePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HistPriceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistPricePayload>
          }
          findFirst: {
            args: Prisma.HistPriceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistPricePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HistPriceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistPricePayload>
          }
          findMany: {
            args: Prisma.HistPriceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistPricePayload>[]
          }
          create: {
            args: Prisma.HistPriceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistPricePayload>
          }
          createMany: {
            args: Prisma.HistPriceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HistPriceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistPricePayload>[]
          }
          delete: {
            args: Prisma.HistPriceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistPricePayload>
          }
          update: {
            args: Prisma.HistPriceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistPricePayload>
          }
          deleteMany: {
            args: Prisma.HistPriceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HistPriceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HistPriceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistPricePayload>
          }
          aggregate: {
            args: Prisma.HistPriceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHistPrice>
          }
          groupBy: {
            args: Prisma.HistPriceGroupByArgs<ExtArgs>
            result: $Utils.Optional<HistPriceGroupByOutputType>[]
          }
          count: {
            args: Prisma.HistPriceCountArgs<ExtArgs>
            result: $Utils.Optional<HistPriceCountAggregateOutputType> | number
          }
        }
      }
      LimitOrder: {
        payload: Prisma.$LimitOrderPayload<ExtArgs>
        fields: Prisma.LimitOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LimitOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LimitOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LimitOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LimitOrderPayload>
          }
          findFirst: {
            args: Prisma.LimitOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LimitOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LimitOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LimitOrderPayload>
          }
          findMany: {
            args: Prisma.LimitOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LimitOrderPayload>[]
          }
          create: {
            args: Prisma.LimitOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LimitOrderPayload>
          }
          createMany: {
            args: Prisma.LimitOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LimitOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LimitOrderPayload>[]
          }
          delete: {
            args: Prisma.LimitOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LimitOrderPayload>
          }
          update: {
            args: Prisma.LimitOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LimitOrderPayload>
          }
          deleteMany: {
            args: Prisma.LimitOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LimitOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LimitOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LimitOrderPayload>
          }
          aggregate: {
            args: Prisma.LimitOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLimitOrder>
          }
          groupBy: {
            args: Prisma.LimitOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<LimitOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.LimitOrderCountArgs<ExtArgs>
            result: $Utils.Optional<LimitOrderCountAggregateOutputType> | number
          }
        }
      }
      Trade: {
        payload: Prisma.$TradePayload<ExtArgs>
        fields: Prisma.TradeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TradeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TradeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradePayload>
          }
          findFirst: {
            args: Prisma.TradeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TradeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradePayload>
          }
          findMany: {
            args: Prisma.TradeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradePayload>[]
          }
          create: {
            args: Prisma.TradeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradePayload>
          }
          createMany: {
            args: Prisma.TradeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TradeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradePayload>[]
          }
          delete: {
            args: Prisma.TradeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradePayload>
          }
          update: {
            args: Prisma.TradeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradePayload>
          }
          deleteMany: {
            args: Prisma.TradeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TradeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TradeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradePayload>
          }
          aggregate: {
            args: Prisma.TradeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrade>
          }
          groupBy: {
            args: Prisma.TradeGroupByArgs<ExtArgs>
            result: $Utils.Optional<TradeGroupByOutputType>[]
          }
          count: {
            args: Prisma.TradeCountArgs<ExtArgs>
            result: $Utils.Optional<TradeCountAggregateOutputType> | number
          }
        }
      }
      News: {
        payload: Prisma.$NewsPayload<ExtArgs>
        fields: Prisma.NewsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NewsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NewsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          findFirst: {
            args: Prisma.NewsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NewsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          findMany: {
            args: Prisma.NewsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>[]
          }
          create: {
            args: Prisma.NewsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          createMany: {
            args: Prisma.NewsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NewsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>[]
          }
          delete: {
            args: Prisma.NewsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          update: {
            args: Prisma.NewsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          deleteMany: {
            args: Prisma.NewsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NewsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NewsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          aggregate: {
            args: Prisma.NewsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNews>
          }
          groupBy: {
            args: Prisma.NewsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewsGroupByOutputType>[]
          }
          count: {
            args: Prisma.NewsCountArgs<ExtArgs>
            result: $Utils.Optional<NewsCountAggregateOutputType> | number
          }
        }
      }
      BlogPost: {
        payload: Prisma.$BlogPostPayload<ExtArgs>
        fields: Prisma.BlogPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          findFirst: {
            args: Prisma.BlogPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          findMany: {
            args: Prisma.BlogPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>[]
          }
          create: {
            args: Prisma.BlogPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          createMany: {
            args: Prisma.BlogPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlogPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>[]
          }
          delete: {
            args: Prisma.BlogPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          update: {
            args: Prisma.BlogPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          deleteMany: {
            args: Prisma.BlogPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlogPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BlogPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          aggregate: {
            args: Prisma.BlogPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlogPost>
          }
          groupBy: {
            args: Prisma.BlogPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogPostCountArgs<ExtArgs>
            result: $Utils.Optional<BlogPostCountAggregateOutputType> | number
          }
        }
      }
      BlogComment: {
        payload: Prisma.$BlogCommentPayload<ExtArgs>
        fields: Prisma.BlogCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCommentPayload>
          }
          findFirst: {
            args: Prisma.BlogCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCommentPayload>
          }
          findMany: {
            args: Prisma.BlogCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCommentPayload>[]
          }
          create: {
            args: Prisma.BlogCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCommentPayload>
          }
          createMany: {
            args: Prisma.BlogCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlogCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCommentPayload>[]
          }
          delete: {
            args: Prisma.BlogCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCommentPayload>
          }
          update: {
            args: Prisma.BlogCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCommentPayload>
          }
          deleteMany: {
            args: Prisma.BlogCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlogCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BlogCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCommentPayload>
          }
          aggregate: {
            args: Prisma.BlogCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlogComment>
          }
          groupBy: {
            args: Prisma.BlogCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogCommentCountArgs<ExtArgs>
            result: $Utils.Optional<BlogCommentCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Referral: {
        payload: Prisma.$ReferralPayload<ExtArgs>
        fields: Prisma.ReferralFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReferralFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReferralFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          findFirst: {
            args: Prisma.ReferralFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReferralFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          findMany: {
            args: Prisma.ReferralFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>[]
          }
          create: {
            args: Prisma.ReferralCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          createMany: {
            args: Prisma.ReferralCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReferralCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>[]
          }
          delete: {
            args: Prisma.ReferralDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          update: {
            args: Prisma.ReferralUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          deleteMany: {
            args: Prisma.ReferralDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReferralUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReferralUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          aggregate: {
            args: Prisma.ReferralAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferral>
          }
          groupBy: {
            args: Prisma.ReferralGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReferralGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReferralCountArgs<ExtArgs>
            result: $Utils.Optional<ReferralCountAggregateOutputType> | number
          }
        }
      }
      ReferralUsage: {
        payload: Prisma.$ReferralUsagePayload<ExtArgs>
        fields: Prisma.ReferralUsageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReferralUsageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralUsagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReferralUsageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralUsagePayload>
          }
          findFirst: {
            args: Prisma.ReferralUsageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralUsagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReferralUsageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralUsagePayload>
          }
          findMany: {
            args: Prisma.ReferralUsageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralUsagePayload>[]
          }
          create: {
            args: Prisma.ReferralUsageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralUsagePayload>
          }
          createMany: {
            args: Prisma.ReferralUsageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReferralUsageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralUsagePayload>[]
          }
          delete: {
            args: Prisma.ReferralUsageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralUsagePayload>
          }
          update: {
            args: Prisma.ReferralUsageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralUsagePayload>
          }
          deleteMany: {
            args: Prisma.ReferralUsageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReferralUsageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReferralUsageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralUsagePayload>
          }
          aggregate: {
            args: Prisma.ReferralUsageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferralUsage>
          }
          groupBy: {
            args: Prisma.ReferralUsageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReferralUsageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReferralUsageCountArgs<ExtArgs>
            result: $Utils.Optional<ReferralUsageCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      FavoriteApi: {
        payload: Prisma.$FavoriteApiPayload<ExtArgs>
        fields: Prisma.FavoriteApiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FavoriteApiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteApiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FavoriteApiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteApiPayload>
          }
          findFirst: {
            args: Prisma.FavoriteApiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteApiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FavoriteApiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteApiPayload>
          }
          findMany: {
            args: Prisma.FavoriteApiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteApiPayload>[]
          }
          create: {
            args: Prisma.FavoriteApiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteApiPayload>
          }
          createMany: {
            args: Prisma.FavoriteApiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FavoriteApiCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteApiPayload>[]
          }
          delete: {
            args: Prisma.FavoriteApiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteApiPayload>
          }
          update: {
            args: Prisma.FavoriteApiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteApiPayload>
          }
          deleteMany: {
            args: Prisma.FavoriteApiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FavoriteApiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FavoriteApiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteApiPayload>
          }
          aggregate: {
            args: Prisma.FavoriteApiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFavoriteApi>
          }
          groupBy: {
            args: Prisma.FavoriteApiGroupByArgs<ExtArgs>
            result: $Utils.Optional<FavoriteApiGroupByOutputType>[]
          }
          count: {
            args: Prisma.FavoriteApiCountArgs<ExtArgs>
            result: $Utils.Optional<FavoriteApiCountAggregateOutputType> | number
          }
        }
      }
      Goal: {
        payload: Prisma.$GoalPayload<ExtArgs>
        fields: Prisma.GoalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GoalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GoalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          findFirst: {
            args: Prisma.GoalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GoalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          findMany: {
            args: Prisma.GoalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>[]
          }
          create: {
            args: Prisma.GoalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          createMany: {
            args: Prisma.GoalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GoalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>[]
          }
          delete: {
            args: Prisma.GoalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          update: {
            args: Prisma.GoalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          deleteMany: {
            args: Prisma.GoalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GoalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GoalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          aggregate: {
            args: Prisma.GoalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGoal>
          }
          groupBy: {
            args: Prisma.GoalGroupByArgs<ExtArgs>
            result: $Utils.Optional<GoalGroupByOutputType>[]
          }
          count: {
            args: Prisma.GoalCountArgs<ExtArgs>
            result: $Utils.Optional<GoalCountAggregateOutputType> | number
          }
        }
      }
      RedeemBy: {
        payload: Prisma.$RedeemByPayload<ExtArgs>
        fields: Prisma.RedeemByFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RedeemByFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemByPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RedeemByFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemByPayload>
          }
          findFirst: {
            args: Prisma.RedeemByFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemByPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RedeemByFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemByPayload>
          }
          findMany: {
            args: Prisma.RedeemByFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemByPayload>[]
          }
          create: {
            args: Prisma.RedeemByCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemByPayload>
          }
          createMany: {
            args: Prisma.RedeemByCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RedeemByCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemByPayload>[]
          }
          delete: {
            args: Prisma.RedeemByDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemByPayload>
          }
          update: {
            args: Prisma.RedeemByUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemByPayload>
          }
          deleteMany: {
            args: Prisma.RedeemByDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RedeemByUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RedeemByUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemByPayload>
          }
          aggregate: {
            args: Prisma.RedeemByAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRedeemBy>
          }
          groupBy: {
            args: Prisma.RedeemByGroupByArgs<ExtArgs>
            result: $Utils.Optional<RedeemByGroupByOutputType>[]
          }
          count: {
            args: Prisma.RedeemByCountArgs<ExtArgs>
            result: $Utils.Optional<RedeemByCountAggregateOutputType> | number
          }
        }
      }
      QuizQuestion: {
        payload: Prisma.$QuizQuestionPayload<ExtArgs>
        fields: Prisma.QuizQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          findFirst: {
            args: Prisma.QuizQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          findMany: {
            args: Prisma.QuizQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>[]
          }
          create: {
            args: Prisma.QuizQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          createMany: {
            args: Prisma.QuizQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizQuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>[]
          }
          delete: {
            args: Prisma.QuizQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          update: {
            args: Prisma.QuizQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          deleteMany: {
            args: Prisma.QuizQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuizQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          aggregate: {
            args: Prisma.QuizQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizQuestion>
          }
          groupBy: {
            args: Prisma.QuizQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<QuizQuestionCountAggregateOutputType> | number
          }
        }
      }
      Reward: {
        payload: Prisma.$RewardPayload<ExtArgs>
        fields: Prisma.RewardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RewardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RewardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>
          }
          findFirst: {
            args: Prisma.RewardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RewardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>
          }
          findMany: {
            args: Prisma.RewardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>[]
          }
          create: {
            args: Prisma.RewardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>
          }
          createMany: {
            args: Prisma.RewardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RewardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>[]
          }
          delete: {
            args: Prisma.RewardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>
          }
          update: {
            args: Prisma.RewardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>
          }
          deleteMany: {
            args: Prisma.RewardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RewardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RewardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>
          }
          aggregate: {
            args: Prisma.RewardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReward>
          }
          groupBy: {
            args: Prisma.RewardGroupByArgs<ExtArgs>
            result: $Utils.Optional<RewardGroupByOutputType>[]
          }
          count: {
            args: Prisma.RewardCountArgs<ExtArgs>
            result: $Utils.Optional<RewardCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.DriverAdapter | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    task?: TaskOmit
    status?: StatusOmit
    person?: PersonOmit
    taskAssignment?: TaskAssignmentOmit
    company?: CompanyOmit
    stock?: StockOmit
    favoriteStock?: FavoriteStockOmit
    histPrice?: HistPriceOmit
    limitOrder?: LimitOrderOmit
    trade?: TradeOmit
    news?: NewsOmit
    blogPost?: BlogPostOmit
    blogComment?: BlogCommentOmit
    user?: UserOmit
    referral?: ReferralOmit
    referralUsage?: ReferralUsageOmit
    comment?: CommentOmit
    favoriteApi?: FavoriteApiOmit
    goal?: GoalOmit
    redeemBy?: RedeemByOmit
    quizQuestion?: QuizQuestionOmit
    reward?: RewardOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TaskCountOutputType
   */

  export type TaskCountOutputType = {
    persons: number
  }

  export type TaskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    persons?: boolean | TaskCountOutputTypeCountPersonsArgs
  }

  // Custom InputTypes
  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCountOutputType
     */
    select?: TaskCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountPersonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskAssignmentWhereInput
  }


  /**
   * Count Type StatusCountOutputType
   */

  export type StatusCountOutputType = {
    tasks: number
  }

  export type StatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | StatusCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * StatusCountOutputType without action
   */
  export type StatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusCountOutputType
     */
    select?: StatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StatusCountOutputType without action
   */
  export type StatusCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type PersonCountOutputType
   */

  export type PersonCountOutputType = {
    tasks: number
  }

  export type PersonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | PersonCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonCountOutputType
     */
    select?: PersonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskAssignmentWhereInput
  }


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    stocks: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stocks?: boolean | CompanyCountOutputTypeCountStocksArgs
  }

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountStocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockWhereInput
  }


  /**
   * Count Type StockCountOutputType
   */

  export type StockCountOutputType = {
    favoriteStock: number
    hist_prices: number
    limitOrder: number
    trading: number
  }

  export type StockCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    favoriteStock?: boolean | StockCountOutputTypeCountFavoriteStockArgs
    hist_prices?: boolean | StockCountOutputTypeCountHist_pricesArgs
    limitOrder?: boolean | StockCountOutputTypeCountLimitOrderArgs
    trading?: boolean | StockCountOutputTypeCountTradingArgs
  }

  // Custom InputTypes
  /**
   * StockCountOutputType without action
   */
  export type StockCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockCountOutputType
     */
    select?: StockCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StockCountOutputType without action
   */
  export type StockCountOutputTypeCountFavoriteStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteStockWhereInput
  }

  /**
   * StockCountOutputType without action
   */
  export type StockCountOutputTypeCountHist_pricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HistPriceWhereInput
  }

  /**
   * StockCountOutputType without action
   */
  export type StockCountOutputTypeCountLimitOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LimitOrderWhereInput
  }

  /**
   * StockCountOutputType without action
   */
  export type StockCountOutputTypeCountTradingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TradeWhereInput
  }


  /**
   * Count Type BlogPostCountOutputType
   */

  export type BlogPostCountOutputType = {
    BlogComment: number
  }

  export type BlogPostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BlogComment?: boolean | BlogPostCountOutputTypeCountBlogCommentArgs
  }

  // Custom InputTypes
  /**
   * BlogPostCountOutputType without action
   */
  export type BlogPostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostCountOutputType
     */
    select?: BlogPostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BlogPostCountOutputType without action
   */
  export type BlogPostCountOutputTypeCountBlogCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogCommentWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    BlogComment: number
    BlogPost: number
    Comment: number
    FavoriteApi: number
    favoriteStocks: number
    Goal: number
    limitOrders: number
    RedeemBy: number
    referrals: number
    referralUsages: number
    trading: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BlogComment?: boolean | UserCountOutputTypeCountBlogCommentArgs
    BlogPost?: boolean | UserCountOutputTypeCountBlogPostArgs
    Comment?: boolean | UserCountOutputTypeCountCommentArgs
    FavoriteApi?: boolean | UserCountOutputTypeCountFavoriteApiArgs
    favoriteStocks?: boolean | UserCountOutputTypeCountFavoriteStocksArgs
    Goal?: boolean | UserCountOutputTypeCountGoalArgs
    limitOrders?: boolean | UserCountOutputTypeCountLimitOrdersArgs
    RedeemBy?: boolean | UserCountOutputTypeCountRedeemByArgs
    referrals?: boolean | UserCountOutputTypeCountReferralsArgs
    referralUsages?: boolean | UserCountOutputTypeCountReferralUsagesArgs
    trading?: boolean | UserCountOutputTypeCountTradingArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlogCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogCommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlogPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFavoriteApiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteApiWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFavoriteStocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteStockWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGoalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GoalWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLimitOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LimitOrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRedeemByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RedeemByWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReferralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReferralUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralUsageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTradingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TradeWhereInput
  }


  /**
   * Count Type ReferralCountOutputType
   */

  export type ReferralCountOutputType = {
    referralUsages: number
    referredUsers: number
  }

  export type ReferralCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referralUsages?: boolean | ReferralCountOutputTypeCountReferralUsagesArgs
    referredUsers?: boolean | ReferralCountOutputTypeCountReferredUsersArgs
  }

  // Custom InputTypes
  /**
   * ReferralCountOutputType without action
   */
  export type ReferralCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralCountOutputType
     */
    select?: ReferralCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReferralCountOutputType without action
   */
  export type ReferralCountOutputTypeCountReferralUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralUsageWhereInput
  }

  /**
   * ReferralCountOutputType without action
   */
  export type ReferralCountOutputTypeCountReferredUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type RewardCountOutputType
   */

  export type RewardCountOutputType = {
    redeemedBy: number
  }

  export type RewardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    redeemedBy?: boolean | RewardCountOutputTypeCountRedeemedByArgs
  }

  // Custom InputTypes
  /**
   * RewardCountOutputType without action
   */
  export type RewardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardCountOutputType
     */
    select?: RewardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RewardCountOutputType without action
   */
  export type RewardCountOutputTypeCountRedeemedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RedeemByWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskAvgAggregateOutputType = {
    id: number | null
    statusId: number | null
  }

  export type TaskSumAggregateOutputType = {
    id: number | null
    statusId: number | null
  }

  export type TaskMinAggregateOutputType = {
    id: number | null
    name: string | null
    statusId: number | null
  }

  export type TaskMaxAggregateOutputType = {
    id: number | null
    name: string | null
    statusId: number | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    name: number
    statusId: number
    _all: number
  }


  export type TaskAvgAggregateInputType = {
    id?: true
    statusId?: true
  }

  export type TaskSumAggregateInputType = {
    id?: true
    statusId?: true
  }

  export type TaskMinAggregateInputType = {
    id?: true
    name?: true
    statusId?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    name?: true
    statusId?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    name?: true
    statusId?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _avg?: TaskAvgAggregateInputType
    _sum?: TaskSumAggregateInputType
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: number
    name: string
    statusId: number
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    statusId?: boolean
    status?: boolean | StatusDefaultArgs<ExtArgs>
    persons?: boolean | Task$personsArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    statusId?: boolean
    status?: boolean | StatusDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>


  export type TaskSelectScalar = {
    id?: boolean
    name?: boolean
    statusId?: boolean
  }

  export type TaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "statusId", ExtArgs["result"]["task"]>
  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    status?: boolean | StatusDefaultArgs<ExtArgs>
    persons?: boolean | Task$personsArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    status?: boolean | StatusDefaultArgs<ExtArgs>
  }

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      status: Prisma.$StatusPayload<ExtArgs>
      persons: Prisma.$TaskAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      statusId: number
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TaskCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    status<T extends StatusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StatusDefaultArgs<ExtArgs>>): Prisma__StatusClient<$Result.GetResult<Prisma.$StatusPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    persons<T extends Task$personsArgs<ExtArgs> = {}>(args?: Subset<T, Task$personsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */ 
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'Int'>
    readonly name: FieldRef<"Task", 'String'>
    readonly statusId: FieldRef<"Task", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Task createManyAndReturn
   */
  export type TaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
  }

  /**
   * Task.persons
   */
  export type Task$personsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    where?: TaskAssignmentWhereInput
    orderBy?: TaskAssignmentOrderByWithRelationInput | TaskAssignmentOrderByWithRelationInput[]
    cursor?: TaskAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskAssignmentScalarFieldEnum | TaskAssignmentScalarFieldEnum[]
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model Status
   */

  export type AggregateStatus = {
    _count: StatusCountAggregateOutputType | null
    _avg: StatusAvgAggregateOutputType | null
    _sum: StatusSumAggregateOutputType | null
    _min: StatusMinAggregateOutputType | null
    _max: StatusMaxAggregateOutputType | null
  }

  export type StatusAvgAggregateOutputType = {
    id: number | null
  }

  export type StatusSumAggregateOutputType = {
    id: number | null
  }

  export type StatusMinAggregateOutputType = {
    id: number | null
    text: string | null
  }

  export type StatusMaxAggregateOutputType = {
    id: number | null
    text: string | null
  }

  export type StatusCountAggregateOutputType = {
    id: number
    text: number
    _all: number
  }


  export type StatusAvgAggregateInputType = {
    id?: true
  }

  export type StatusSumAggregateInputType = {
    id?: true
  }

  export type StatusMinAggregateInputType = {
    id?: true
    text?: true
  }

  export type StatusMaxAggregateInputType = {
    id?: true
    text?: true
  }

  export type StatusCountAggregateInputType = {
    id?: true
    text?: true
    _all?: true
  }

  export type StatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Status to aggregate.
     */
    where?: StatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Statuses to fetch.
     */
    orderBy?: StatusOrderByWithRelationInput | StatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Statuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Statuses
    **/
    _count?: true | StatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StatusMaxAggregateInputType
  }

  export type GetStatusAggregateType<T extends StatusAggregateArgs> = {
        [P in keyof T & keyof AggregateStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStatus[P]>
      : GetScalarType<T[P], AggregateStatus[P]>
  }




  export type StatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StatusWhereInput
    orderBy?: StatusOrderByWithAggregationInput | StatusOrderByWithAggregationInput[]
    by: StatusScalarFieldEnum[] | StatusScalarFieldEnum
    having?: StatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StatusCountAggregateInputType | true
    _avg?: StatusAvgAggregateInputType
    _sum?: StatusSumAggregateInputType
    _min?: StatusMinAggregateInputType
    _max?: StatusMaxAggregateInputType
  }

  export type StatusGroupByOutputType = {
    id: number
    text: string
    _count: StatusCountAggregateOutputType | null
    _avg: StatusAvgAggregateOutputType | null
    _sum: StatusSumAggregateOutputType | null
    _min: StatusMinAggregateOutputType | null
    _max: StatusMaxAggregateOutputType | null
  }

  type GetStatusGroupByPayload<T extends StatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StatusGroupByOutputType[P]>
            : GetScalarType<T[P], StatusGroupByOutputType[P]>
        }
      >
    >


  export type StatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    tasks?: boolean | Status$tasksArgs<ExtArgs>
    _count?: boolean | StatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["status"]>

  export type StatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
  }, ExtArgs["result"]["status"]>


  export type StatusSelectScalar = {
    id?: boolean
    text?: boolean
  }

  export type StatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "text", ExtArgs["result"]["status"]>
  export type StatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | Status$tasksArgs<ExtArgs>
    _count?: boolean | StatusCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StatusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $StatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Status"
    objects: {
      tasks: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      text: string
    }, ExtArgs["result"]["status"]>
    composites: {}
  }

  type StatusGetPayload<S extends boolean | null | undefined | StatusDefaultArgs> = $Result.GetResult<Prisma.$StatusPayload, S>

  type StatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StatusCountAggregateInputType | true
    }

  export interface StatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Status'], meta: { name: 'Status' } }
    /**
     * Find zero or one Status that matches the filter.
     * @param {StatusFindUniqueArgs} args - Arguments to find a Status
     * @example
     * // Get one Status
     * const status = await prisma.status.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StatusFindUniqueArgs>(args: SelectSubset<T, StatusFindUniqueArgs<ExtArgs>>): Prisma__StatusClient<$Result.GetResult<Prisma.$StatusPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Status that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StatusFindUniqueOrThrowArgs} args - Arguments to find a Status
     * @example
     * // Get one Status
     * const status = await prisma.status.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StatusFindUniqueOrThrowArgs>(args: SelectSubset<T, StatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StatusClient<$Result.GetResult<Prisma.$StatusPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Status that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusFindFirstArgs} args - Arguments to find a Status
     * @example
     * // Get one Status
     * const status = await prisma.status.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StatusFindFirstArgs>(args?: SelectSubset<T, StatusFindFirstArgs<ExtArgs>>): Prisma__StatusClient<$Result.GetResult<Prisma.$StatusPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Status that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusFindFirstOrThrowArgs} args - Arguments to find a Status
     * @example
     * // Get one Status
     * const status = await prisma.status.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StatusFindFirstOrThrowArgs>(args?: SelectSubset<T, StatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__StatusClient<$Result.GetResult<Prisma.$StatusPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Statuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Statuses
     * const statuses = await prisma.status.findMany()
     * 
     * // Get first 10 Statuses
     * const statuses = await prisma.status.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const statusWithIdOnly = await prisma.status.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StatusFindManyArgs>(args?: SelectSubset<T, StatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatusPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Status.
     * @param {StatusCreateArgs} args - Arguments to create a Status.
     * @example
     * // Create one Status
     * const Status = await prisma.status.create({
     *   data: {
     *     // ... data to create a Status
     *   }
     * })
     * 
     */
    create<T extends StatusCreateArgs>(args: SelectSubset<T, StatusCreateArgs<ExtArgs>>): Prisma__StatusClient<$Result.GetResult<Prisma.$StatusPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Statuses.
     * @param {StatusCreateManyArgs} args - Arguments to create many Statuses.
     * @example
     * // Create many Statuses
     * const status = await prisma.status.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StatusCreateManyArgs>(args?: SelectSubset<T, StatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Statuses and returns the data saved in the database.
     * @param {StatusCreateManyAndReturnArgs} args - Arguments to create many Statuses.
     * @example
     * // Create many Statuses
     * const status = await prisma.status.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Statuses and only return the `id`
     * const statusWithIdOnly = await prisma.status.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StatusCreateManyAndReturnArgs>(args?: SelectSubset<T, StatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatusPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Status.
     * @param {StatusDeleteArgs} args - Arguments to delete one Status.
     * @example
     * // Delete one Status
     * const Status = await prisma.status.delete({
     *   where: {
     *     // ... filter to delete one Status
     *   }
     * })
     * 
     */
    delete<T extends StatusDeleteArgs>(args: SelectSubset<T, StatusDeleteArgs<ExtArgs>>): Prisma__StatusClient<$Result.GetResult<Prisma.$StatusPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Status.
     * @param {StatusUpdateArgs} args - Arguments to update one Status.
     * @example
     * // Update one Status
     * const status = await prisma.status.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StatusUpdateArgs>(args: SelectSubset<T, StatusUpdateArgs<ExtArgs>>): Prisma__StatusClient<$Result.GetResult<Prisma.$StatusPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Statuses.
     * @param {StatusDeleteManyArgs} args - Arguments to filter Statuses to delete.
     * @example
     * // Delete a few Statuses
     * const { count } = await prisma.status.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StatusDeleteManyArgs>(args?: SelectSubset<T, StatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Statuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Statuses
     * const status = await prisma.status.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StatusUpdateManyArgs>(args: SelectSubset<T, StatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Status.
     * @param {StatusUpsertArgs} args - Arguments to update or create a Status.
     * @example
     * // Update or create a Status
     * const status = await prisma.status.upsert({
     *   create: {
     *     // ... data to create a Status
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Status we want to update
     *   }
     * })
     */
    upsert<T extends StatusUpsertArgs>(args: SelectSubset<T, StatusUpsertArgs<ExtArgs>>): Prisma__StatusClient<$Result.GetResult<Prisma.$StatusPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Statuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusCountArgs} args - Arguments to filter Statuses to count.
     * @example
     * // Count the number of Statuses
     * const count = await prisma.status.count({
     *   where: {
     *     // ... the filter for the Statuses we want to count
     *   }
     * })
    **/
    count<T extends StatusCountArgs>(
      args?: Subset<T, StatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Status.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StatusAggregateArgs>(args: Subset<T, StatusAggregateArgs>): Prisma.PrismaPromise<GetStatusAggregateType<T>>

    /**
     * Group by Status.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StatusGroupByArgs['orderBy'] }
        : { orderBy?: StatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Status model
   */
  readonly fields: StatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Status.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tasks<T extends Status$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Status$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Status model
   */ 
  interface StatusFieldRefs {
    readonly id: FieldRef<"Status", 'Int'>
    readonly text: FieldRef<"Status", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Status findUnique
   */
  export type StatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Status
     */
    select?: StatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Status
     */
    omit?: StatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusInclude<ExtArgs> | null
    /**
     * Filter, which Status to fetch.
     */
    where: StatusWhereUniqueInput
  }

  /**
   * Status findUniqueOrThrow
   */
  export type StatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Status
     */
    select?: StatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Status
     */
    omit?: StatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusInclude<ExtArgs> | null
    /**
     * Filter, which Status to fetch.
     */
    where: StatusWhereUniqueInput
  }

  /**
   * Status findFirst
   */
  export type StatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Status
     */
    select?: StatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Status
     */
    omit?: StatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusInclude<ExtArgs> | null
    /**
     * Filter, which Status to fetch.
     */
    where?: StatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Statuses to fetch.
     */
    orderBy?: StatusOrderByWithRelationInput | StatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Statuses.
     */
    cursor?: StatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Statuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Statuses.
     */
    distinct?: StatusScalarFieldEnum | StatusScalarFieldEnum[]
  }

  /**
   * Status findFirstOrThrow
   */
  export type StatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Status
     */
    select?: StatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Status
     */
    omit?: StatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusInclude<ExtArgs> | null
    /**
     * Filter, which Status to fetch.
     */
    where?: StatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Statuses to fetch.
     */
    orderBy?: StatusOrderByWithRelationInput | StatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Statuses.
     */
    cursor?: StatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Statuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Statuses.
     */
    distinct?: StatusScalarFieldEnum | StatusScalarFieldEnum[]
  }

  /**
   * Status findMany
   */
  export type StatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Status
     */
    select?: StatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Status
     */
    omit?: StatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusInclude<ExtArgs> | null
    /**
     * Filter, which Statuses to fetch.
     */
    where?: StatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Statuses to fetch.
     */
    orderBy?: StatusOrderByWithRelationInput | StatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Statuses.
     */
    cursor?: StatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Statuses.
     */
    skip?: number
    distinct?: StatusScalarFieldEnum | StatusScalarFieldEnum[]
  }

  /**
   * Status create
   */
  export type StatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Status
     */
    select?: StatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Status
     */
    omit?: StatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusInclude<ExtArgs> | null
    /**
     * The data needed to create a Status.
     */
    data: XOR<StatusCreateInput, StatusUncheckedCreateInput>
  }

  /**
   * Status createMany
   */
  export type StatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Statuses.
     */
    data: StatusCreateManyInput | StatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Status createManyAndReturn
   */
  export type StatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Status
     */
    select?: StatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Status
     */
    omit?: StatusOmit<ExtArgs> | null
    /**
     * The data used to create many Statuses.
     */
    data: StatusCreateManyInput | StatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Status update
   */
  export type StatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Status
     */
    select?: StatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Status
     */
    omit?: StatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusInclude<ExtArgs> | null
    /**
     * The data needed to update a Status.
     */
    data: XOR<StatusUpdateInput, StatusUncheckedUpdateInput>
    /**
     * Choose, which Status to update.
     */
    where: StatusWhereUniqueInput
  }

  /**
   * Status updateMany
   */
  export type StatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Statuses.
     */
    data: XOR<StatusUpdateManyMutationInput, StatusUncheckedUpdateManyInput>
    /**
     * Filter which Statuses to update
     */
    where?: StatusWhereInput
  }

  /**
   * Status upsert
   */
  export type StatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Status
     */
    select?: StatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Status
     */
    omit?: StatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusInclude<ExtArgs> | null
    /**
     * The filter to search for the Status to update in case it exists.
     */
    where: StatusWhereUniqueInput
    /**
     * In case the Status found by the `where` argument doesn't exist, create a new Status with this data.
     */
    create: XOR<StatusCreateInput, StatusUncheckedCreateInput>
    /**
     * In case the Status was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StatusUpdateInput, StatusUncheckedUpdateInput>
  }

  /**
   * Status delete
   */
  export type StatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Status
     */
    select?: StatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Status
     */
    omit?: StatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusInclude<ExtArgs> | null
    /**
     * Filter which Status to delete.
     */
    where: StatusWhereUniqueInput
  }

  /**
   * Status deleteMany
   */
  export type StatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Statuses to delete
     */
    where?: StatusWhereInput
  }

  /**
   * Status.tasks
   */
  export type Status$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Status without action
   */
  export type StatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Status
     */
    select?: StatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Status
     */
    omit?: StatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusInclude<ExtArgs> | null
  }


  /**
   * Model Person
   */

  export type AggregatePerson = {
    _count: PersonCountAggregateOutputType | null
    _avg: PersonAvgAggregateOutputType | null
    _sum: PersonSumAggregateOutputType | null
    _min: PersonMinAggregateOutputType | null
    _max: PersonMaxAggregateOutputType | null
  }

  export type PersonAvgAggregateOutputType = {
    id: number | null
  }

  export type PersonSumAggregateOutputType = {
    id: number | null
  }

  export type PersonMinAggregateOutputType = {
    id: number | null
    email: string | null
    name: string | null
    avatar: string | null
  }

  export type PersonMaxAggregateOutputType = {
    id: number | null
    email: string | null
    name: string | null
    avatar: string | null
  }

  export type PersonCountAggregateOutputType = {
    id: number
    email: number
    name: number
    avatar: number
    _all: number
  }


  export type PersonAvgAggregateInputType = {
    id?: true
  }

  export type PersonSumAggregateInputType = {
    id?: true
  }

  export type PersonMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    avatar?: true
  }

  export type PersonMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    avatar?: true
  }

  export type PersonCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    avatar?: true
    _all?: true
  }

  export type PersonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Person to aggregate.
     */
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: PersonOrderByWithRelationInput | PersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned People
    **/
    _count?: true | PersonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PersonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PersonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonMaxAggregateInputType
  }

  export type GetPersonAggregateType<T extends PersonAggregateArgs> = {
        [P in keyof T & keyof AggregatePerson]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerson[P]>
      : GetScalarType<T[P], AggregatePerson[P]>
  }




  export type PersonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonWhereInput
    orderBy?: PersonOrderByWithAggregationInput | PersonOrderByWithAggregationInput[]
    by: PersonScalarFieldEnum[] | PersonScalarFieldEnum
    having?: PersonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonCountAggregateInputType | true
    _avg?: PersonAvgAggregateInputType
    _sum?: PersonSumAggregateInputType
    _min?: PersonMinAggregateInputType
    _max?: PersonMaxAggregateInputType
  }

  export type PersonGroupByOutputType = {
    id: number
    email: string
    name: string
    avatar: string | null
    _count: PersonCountAggregateOutputType | null
    _avg: PersonAvgAggregateOutputType | null
    _sum: PersonSumAggregateOutputType | null
    _min: PersonMinAggregateOutputType | null
    _max: PersonMaxAggregateOutputType | null
  }

  type GetPersonGroupByPayload<T extends PersonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonGroupByOutputType[P]>
            : GetScalarType<T[P], PersonGroupByOutputType[P]>
        }
      >
    >


  export type PersonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    avatar?: boolean
    tasks?: boolean | Person$tasksArgs<ExtArgs>
    _count?: boolean | PersonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["person"]>

  export type PersonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    avatar?: boolean
  }, ExtArgs["result"]["person"]>


  export type PersonSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    avatar?: boolean
  }

  export type PersonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "avatar", ExtArgs["result"]["person"]>
  export type PersonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | Person$tasksArgs<ExtArgs>
    _count?: boolean | PersonCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PersonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PersonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Person"
    objects: {
      tasks: Prisma.$TaskAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      name: string
      avatar: string | null
    }, ExtArgs["result"]["person"]>
    composites: {}
  }

  type PersonGetPayload<S extends boolean | null | undefined | PersonDefaultArgs> = $Result.GetResult<Prisma.$PersonPayload, S>

  type PersonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PersonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PersonCountAggregateInputType | true
    }

  export interface PersonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Person'], meta: { name: 'Person' } }
    /**
     * Find zero or one Person that matches the filter.
     * @param {PersonFindUniqueArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersonFindUniqueArgs>(args: SelectSubset<T, PersonFindUniqueArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Person that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PersonFindUniqueOrThrowArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersonFindUniqueOrThrowArgs>(args: SelectSubset<T, PersonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Person that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonFindFirstArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersonFindFirstArgs>(args?: SelectSubset<T, PersonFindFirstArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Person that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonFindFirstOrThrowArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersonFindFirstOrThrowArgs>(args?: SelectSubset<T, PersonFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more People that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all People
     * const people = await prisma.person.findMany()
     * 
     * // Get first 10 People
     * const people = await prisma.person.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personWithIdOnly = await prisma.person.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PersonFindManyArgs>(args?: SelectSubset<T, PersonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Person.
     * @param {PersonCreateArgs} args - Arguments to create a Person.
     * @example
     * // Create one Person
     * const Person = await prisma.person.create({
     *   data: {
     *     // ... data to create a Person
     *   }
     * })
     * 
     */
    create<T extends PersonCreateArgs>(args: SelectSubset<T, PersonCreateArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many People.
     * @param {PersonCreateManyArgs} args - Arguments to create many People.
     * @example
     * // Create many People
     * const person = await prisma.person.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersonCreateManyArgs>(args?: SelectSubset<T, PersonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many People and returns the data saved in the database.
     * @param {PersonCreateManyAndReturnArgs} args - Arguments to create many People.
     * @example
     * // Create many People
     * const person = await prisma.person.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many People and only return the `id`
     * const personWithIdOnly = await prisma.person.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersonCreateManyAndReturnArgs>(args?: SelectSubset<T, PersonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Person.
     * @param {PersonDeleteArgs} args - Arguments to delete one Person.
     * @example
     * // Delete one Person
     * const Person = await prisma.person.delete({
     *   where: {
     *     // ... filter to delete one Person
     *   }
     * })
     * 
     */
    delete<T extends PersonDeleteArgs>(args: SelectSubset<T, PersonDeleteArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Person.
     * @param {PersonUpdateArgs} args - Arguments to update one Person.
     * @example
     * // Update one Person
     * const person = await prisma.person.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersonUpdateArgs>(args: SelectSubset<T, PersonUpdateArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more People.
     * @param {PersonDeleteManyArgs} args - Arguments to filter People to delete.
     * @example
     * // Delete a few People
     * const { count } = await prisma.person.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersonDeleteManyArgs>(args?: SelectSubset<T, PersonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more People.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many People
     * const person = await prisma.person.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersonUpdateManyArgs>(args: SelectSubset<T, PersonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Person.
     * @param {PersonUpsertArgs} args - Arguments to update or create a Person.
     * @example
     * // Update or create a Person
     * const person = await prisma.person.upsert({
     *   create: {
     *     // ... data to create a Person
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Person we want to update
     *   }
     * })
     */
    upsert<T extends PersonUpsertArgs>(args: SelectSubset<T, PersonUpsertArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of People.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonCountArgs} args - Arguments to filter People to count.
     * @example
     * // Count the number of People
     * const count = await prisma.person.count({
     *   where: {
     *     // ... the filter for the People we want to count
     *   }
     * })
    **/
    count<T extends PersonCountArgs>(
      args?: Subset<T, PersonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Person.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonAggregateArgs>(args: Subset<T, PersonAggregateArgs>): Prisma.PrismaPromise<GetPersonAggregateType<T>>

    /**
     * Group by Person.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonGroupByArgs['orderBy'] }
        : { orderBy?: PersonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Person model
   */
  readonly fields: PersonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Person.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tasks<T extends Person$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Person$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Person model
   */ 
  interface PersonFieldRefs {
    readonly id: FieldRef<"Person", 'Int'>
    readonly email: FieldRef<"Person", 'String'>
    readonly name: FieldRef<"Person", 'String'>
    readonly avatar: FieldRef<"Person", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Person findUnique
   */
  export type PersonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which Person to fetch.
     */
    where: PersonWhereUniqueInput
  }

  /**
   * Person findUniqueOrThrow
   */
  export type PersonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which Person to fetch.
     */
    where: PersonWhereUniqueInput
  }

  /**
   * Person findFirst
   */
  export type PersonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which Person to fetch.
     */
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: PersonOrderByWithRelationInput | PersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for People.
     */
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of People.
     */
    distinct?: PersonScalarFieldEnum | PersonScalarFieldEnum[]
  }

  /**
   * Person findFirstOrThrow
   */
  export type PersonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which Person to fetch.
     */
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: PersonOrderByWithRelationInput | PersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for People.
     */
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of People.
     */
    distinct?: PersonScalarFieldEnum | PersonScalarFieldEnum[]
  }

  /**
   * Person findMany
   */
  export type PersonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which People to fetch.
     */
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: PersonOrderByWithRelationInput | PersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing People.
     */
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    distinct?: PersonScalarFieldEnum | PersonScalarFieldEnum[]
  }

  /**
   * Person create
   */
  export type PersonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * The data needed to create a Person.
     */
    data: XOR<PersonCreateInput, PersonUncheckedCreateInput>
  }

  /**
   * Person createMany
   */
  export type PersonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many People.
     */
    data: PersonCreateManyInput | PersonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Person createManyAndReturn
   */
  export type PersonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * The data used to create many People.
     */
    data: PersonCreateManyInput | PersonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Person update
   */
  export type PersonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * The data needed to update a Person.
     */
    data: XOR<PersonUpdateInput, PersonUncheckedUpdateInput>
    /**
     * Choose, which Person to update.
     */
    where: PersonWhereUniqueInput
  }

  /**
   * Person updateMany
   */
  export type PersonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update People.
     */
    data: XOR<PersonUpdateManyMutationInput, PersonUncheckedUpdateManyInput>
    /**
     * Filter which People to update
     */
    where?: PersonWhereInput
  }

  /**
   * Person upsert
   */
  export type PersonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * The filter to search for the Person to update in case it exists.
     */
    where: PersonWhereUniqueInput
    /**
     * In case the Person found by the `where` argument doesn't exist, create a new Person with this data.
     */
    create: XOR<PersonCreateInput, PersonUncheckedCreateInput>
    /**
     * In case the Person was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonUpdateInput, PersonUncheckedUpdateInput>
  }

  /**
   * Person delete
   */
  export type PersonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter which Person to delete.
     */
    where: PersonWhereUniqueInput
  }

  /**
   * Person deleteMany
   */
  export type PersonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which People to delete
     */
    where?: PersonWhereInput
  }

  /**
   * Person.tasks
   */
  export type Person$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    where?: TaskAssignmentWhereInput
    orderBy?: TaskAssignmentOrderByWithRelationInput | TaskAssignmentOrderByWithRelationInput[]
    cursor?: TaskAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskAssignmentScalarFieldEnum | TaskAssignmentScalarFieldEnum[]
  }

  /**
   * Person without action
   */
  export type PersonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
  }


  /**
   * Model TaskAssignment
   */

  export type AggregateTaskAssignment = {
    _count: TaskAssignmentCountAggregateOutputType | null
    _avg: TaskAssignmentAvgAggregateOutputType | null
    _sum: TaskAssignmentSumAggregateOutputType | null
    _min: TaskAssignmentMinAggregateOutputType | null
    _max: TaskAssignmentMaxAggregateOutputType | null
  }

  export type TaskAssignmentAvgAggregateOutputType = {
    taskId: number | null
    personId: number | null
  }

  export type TaskAssignmentSumAggregateOutputType = {
    taskId: number | null
    personId: number | null
  }

  export type TaskAssignmentMinAggregateOutputType = {
    taskId: number | null
    personId: number | null
    assignedAt: Date | null
  }

  export type TaskAssignmentMaxAggregateOutputType = {
    taskId: number | null
    personId: number | null
    assignedAt: Date | null
  }

  export type TaskAssignmentCountAggregateOutputType = {
    taskId: number
    personId: number
    assignedAt: number
    _all: number
  }


  export type TaskAssignmentAvgAggregateInputType = {
    taskId?: true
    personId?: true
  }

  export type TaskAssignmentSumAggregateInputType = {
    taskId?: true
    personId?: true
  }

  export type TaskAssignmentMinAggregateInputType = {
    taskId?: true
    personId?: true
    assignedAt?: true
  }

  export type TaskAssignmentMaxAggregateInputType = {
    taskId?: true
    personId?: true
    assignedAt?: true
  }

  export type TaskAssignmentCountAggregateInputType = {
    taskId?: true
    personId?: true
    assignedAt?: true
    _all?: true
  }

  export type TaskAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskAssignment to aggregate.
     */
    where?: TaskAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAssignments to fetch.
     */
    orderBy?: TaskAssignmentOrderByWithRelationInput | TaskAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskAssignments
    **/
    _count?: true | TaskAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskAssignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskAssignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskAssignmentMaxAggregateInputType
  }

  export type GetTaskAssignmentAggregateType<T extends TaskAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskAssignment[P]>
      : GetScalarType<T[P], AggregateTaskAssignment[P]>
  }




  export type TaskAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskAssignmentWhereInput
    orderBy?: TaskAssignmentOrderByWithAggregationInput | TaskAssignmentOrderByWithAggregationInput[]
    by: TaskAssignmentScalarFieldEnum[] | TaskAssignmentScalarFieldEnum
    having?: TaskAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskAssignmentCountAggregateInputType | true
    _avg?: TaskAssignmentAvgAggregateInputType
    _sum?: TaskAssignmentSumAggregateInputType
    _min?: TaskAssignmentMinAggregateInputType
    _max?: TaskAssignmentMaxAggregateInputType
  }

  export type TaskAssignmentGroupByOutputType = {
    taskId: number
    personId: number
    assignedAt: Date
    _count: TaskAssignmentCountAggregateOutputType | null
    _avg: TaskAssignmentAvgAggregateOutputType | null
    _sum: TaskAssignmentSumAggregateOutputType | null
    _min: TaskAssignmentMinAggregateOutputType | null
    _max: TaskAssignmentMaxAggregateOutputType | null
  }

  type GetTaskAssignmentGroupByPayload<T extends TaskAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], TaskAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type TaskAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    taskId?: boolean
    personId?: boolean
    assignedAt?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskAssignment"]>

  export type TaskAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    taskId?: boolean
    personId?: boolean
    assignedAt?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskAssignment"]>


  export type TaskAssignmentSelectScalar = {
    taskId?: boolean
    personId?: boolean
    assignedAt?: boolean
  }

  export type TaskAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"taskId" | "personId" | "assignedAt", ExtArgs["result"]["taskAssignment"]>
  export type TaskAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }
  export type TaskAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }

  export type $TaskAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskAssignment"
    objects: {
      person: Prisma.$PersonPayload<ExtArgs>
      task: Prisma.$TaskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      taskId: number
      personId: number
      assignedAt: Date
    }, ExtArgs["result"]["taskAssignment"]>
    composites: {}
  }

  type TaskAssignmentGetPayload<S extends boolean | null | undefined | TaskAssignmentDefaultArgs> = $Result.GetResult<Prisma.$TaskAssignmentPayload, S>

  type TaskAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskAssignmentCountAggregateInputType | true
    }

  export interface TaskAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskAssignment'], meta: { name: 'TaskAssignment' } }
    /**
     * Find zero or one TaskAssignment that matches the filter.
     * @param {TaskAssignmentFindUniqueArgs} args - Arguments to find a TaskAssignment
     * @example
     * // Get one TaskAssignment
     * const taskAssignment = await prisma.taskAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskAssignmentFindUniqueArgs>(args: SelectSubset<T, TaskAssignmentFindUniqueArgs<ExtArgs>>): Prisma__TaskAssignmentClient<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one TaskAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskAssignmentFindUniqueOrThrowArgs} args - Arguments to find a TaskAssignment
     * @example
     * // Get one TaskAssignment
     * const taskAssignment = await prisma.taskAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskAssignmentClient<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first TaskAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssignmentFindFirstArgs} args - Arguments to find a TaskAssignment
     * @example
     * // Get one TaskAssignment
     * const taskAssignment = await prisma.taskAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskAssignmentFindFirstArgs>(args?: SelectSubset<T, TaskAssignmentFindFirstArgs<ExtArgs>>): Prisma__TaskAssignmentClient<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first TaskAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssignmentFindFirstOrThrowArgs} args - Arguments to find a TaskAssignment
     * @example
     * // Get one TaskAssignment
     * const taskAssignment = await prisma.taskAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskAssignmentClient<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more TaskAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskAssignments
     * const taskAssignments = await prisma.taskAssignment.findMany()
     * 
     * // Get first 10 TaskAssignments
     * const taskAssignments = await prisma.taskAssignment.findMany({ take: 10 })
     * 
     * // Only select the `taskId`
     * const taskAssignmentWithTaskIdOnly = await prisma.taskAssignment.findMany({ select: { taskId: true } })
     * 
     */
    findMany<T extends TaskAssignmentFindManyArgs>(args?: SelectSubset<T, TaskAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a TaskAssignment.
     * @param {TaskAssignmentCreateArgs} args - Arguments to create a TaskAssignment.
     * @example
     * // Create one TaskAssignment
     * const TaskAssignment = await prisma.taskAssignment.create({
     *   data: {
     *     // ... data to create a TaskAssignment
     *   }
     * })
     * 
     */
    create<T extends TaskAssignmentCreateArgs>(args: SelectSubset<T, TaskAssignmentCreateArgs<ExtArgs>>): Prisma__TaskAssignmentClient<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many TaskAssignments.
     * @param {TaskAssignmentCreateManyArgs} args - Arguments to create many TaskAssignments.
     * @example
     * // Create many TaskAssignments
     * const taskAssignment = await prisma.taskAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskAssignmentCreateManyArgs>(args?: SelectSubset<T, TaskAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskAssignments and returns the data saved in the database.
     * @param {TaskAssignmentCreateManyAndReturnArgs} args - Arguments to create many TaskAssignments.
     * @example
     * // Create many TaskAssignments
     * const taskAssignment = await prisma.taskAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskAssignments and only return the `taskId`
     * const taskAssignmentWithTaskIdOnly = await prisma.taskAssignment.createManyAndReturn({
     *   select: { taskId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a TaskAssignment.
     * @param {TaskAssignmentDeleteArgs} args - Arguments to delete one TaskAssignment.
     * @example
     * // Delete one TaskAssignment
     * const TaskAssignment = await prisma.taskAssignment.delete({
     *   where: {
     *     // ... filter to delete one TaskAssignment
     *   }
     * })
     * 
     */
    delete<T extends TaskAssignmentDeleteArgs>(args: SelectSubset<T, TaskAssignmentDeleteArgs<ExtArgs>>): Prisma__TaskAssignmentClient<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one TaskAssignment.
     * @param {TaskAssignmentUpdateArgs} args - Arguments to update one TaskAssignment.
     * @example
     * // Update one TaskAssignment
     * const taskAssignment = await prisma.taskAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskAssignmentUpdateArgs>(args: SelectSubset<T, TaskAssignmentUpdateArgs<ExtArgs>>): Prisma__TaskAssignmentClient<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more TaskAssignments.
     * @param {TaskAssignmentDeleteManyArgs} args - Arguments to filter TaskAssignments to delete.
     * @example
     * // Delete a few TaskAssignments
     * const { count } = await prisma.taskAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskAssignmentDeleteManyArgs>(args?: SelectSubset<T, TaskAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskAssignments
     * const taskAssignment = await prisma.taskAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskAssignmentUpdateManyArgs>(args: SelectSubset<T, TaskAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaskAssignment.
     * @param {TaskAssignmentUpsertArgs} args - Arguments to update or create a TaskAssignment.
     * @example
     * // Update or create a TaskAssignment
     * const taskAssignment = await prisma.taskAssignment.upsert({
     *   create: {
     *     // ... data to create a TaskAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskAssignment we want to update
     *   }
     * })
     */
    upsert<T extends TaskAssignmentUpsertArgs>(args: SelectSubset<T, TaskAssignmentUpsertArgs<ExtArgs>>): Prisma__TaskAssignmentClient<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of TaskAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssignmentCountArgs} args - Arguments to filter TaskAssignments to count.
     * @example
     * // Count the number of TaskAssignments
     * const count = await prisma.taskAssignment.count({
     *   where: {
     *     // ... the filter for the TaskAssignments we want to count
     *   }
     * })
    **/
    count<T extends TaskAssignmentCountArgs>(
      args?: Subset<T, TaskAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAssignmentAggregateArgs>(args: Subset<T, TaskAssignmentAggregateArgs>): Prisma.PrismaPromise<GetTaskAssignmentAggregateType<T>>

    /**
     * Group by TaskAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: TaskAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskAssignment model
   */
  readonly fields: TaskAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    person<T extends PersonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonDefaultArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskAssignment model
   */ 
  interface TaskAssignmentFieldRefs {
    readonly taskId: FieldRef<"TaskAssignment", 'Int'>
    readonly personId: FieldRef<"TaskAssignment", 'Int'>
    readonly assignedAt: FieldRef<"TaskAssignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaskAssignment findUnique
   */
  export type TaskAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignment to fetch.
     */
    where: TaskAssignmentWhereUniqueInput
  }

  /**
   * TaskAssignment findUniqueOrThrow
   */
  export type TaskAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignment to fetch.
     */
    where: TaskAssignmentWhereUniqueInput
  }

  /**
   * TaskAssignment findFirst
   */
  export type TaskAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignment to fetch.
     */
    where?: TaskAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAssignments to fetch.
     */
    orderBy?: TaskAssignmentOrderByWithRelationInput | TaskAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskAssignments.
     */
    cursor?: TaskAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskAssignments.
     */
    distinct?: TaskAssignmentScalarFieldEnum | TaskAssignmentScalarFieldEnum[]
  }

  /**
   * TaskAssignment findFirstOrThrow
   */
  export type TaskAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignment to fetch.
     */
    where?: TaskAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAssignments to fetch.
     */
    orderBy?: TaskAssignmentOrderByWithRelationInput | TaskAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskAssignments.
     */
    cursor?: TaskAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskAssignments.
     */
    distinct?: TaskAssignmentScalarFieldEnum | TaskAssignmentScalarFieldEnum[]
  }

  /**
   * TaskAssignment findMany
   */
  export type TaskAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignments to fetch.
     */
    where?: TaskAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAssignments to fetch.
     */
    orderBy?: TaskAssignmentOrderByWithRelationInput | TaskAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskAssignments.
     */
    cursor?: TaskAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAssignments.
     */
    skip?: number
    distinct?: TaskAssignmentScalarFieldEnum | TaskAssignmentScalarFieldEnum[]
  }

  /**
   * TaskAssignment create
   */
  export type TaskAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskAssignment.
     */
    data: XOR<TaskAssignmentCreateInput, TaskAssignmentUncheckedCreateInput>
  }

  /**
   * TaskAssignment createMany
   */
  export type TaskAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskAssignments.
     */
    data: TaskAssignmentCreateManyInput | TaskAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskAssignment createManyAndReturn
   */
  export type TaskAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many TaskAssignments.
     */
    data: TaskAssignmentCreateManyInput | TaskAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskAssignment update
   */
  export type TaskAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskAssignment.
     */
    data: XOR<TaskAssignmentUpdateInput, TaskAssignmentUncheckedUpdateInput>
    /**
     * Choose, which TaskAssignment to update.
     */
    where: TaskAssignmentWhereUniqueInput
  }

  /**
   * TaskAssignment updateMany
   */
  export type TaskAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskAssignments.
     */
    data: XOR<TaskAssignmentUpdateManyMutationInput, TaskAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which TaskAssignments to update
     */
    where?: TaskAssignmentWhereInput
  }

  /**
   * TaskAssignment upsert
   */
  export type TaskAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskAssignment to update in case it exists.
     */
    where: TaskAssignmentWhereUniqueInput
    /**
     * In case the TaskAssignment found by the `where` argument doesn't exist, create a new TaskAssignment with this data.
     */
    create: XOR<TaskAssignmentCreateInput, TaskAssignmentUncheckedCreateInput>
    /**
     * In case the TaskAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskAssignmentUpdateInput, TaskAssignmentUncheckedUpdateInput>
  }

  /**
   * TaskAssignment delete
   */
  export type TaskAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * Filter which TaskAssignment to delete.
     */
    where: TaskAssignmentWhereUniqueInput
  }

  /**
   * TaskAssignment deleteMany
   */
  export type TaskAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskAssignments to delete
     */
    where?: TaskAssignmentWhereInput
  }

  /**
   * TaskAssignment without action
   */
  export type TaskAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyAvgAggregateOutputType = {
    id: number | null
    founded: number | null
    employees: number | null
  }

  export type CompanySumAggregateOutputType = {
    id: number | null
    founded: number | null
    employees: number | null
  }

  export type CompanyMinAggregateOutputType = {
    id: number | null
    symbol: string | null
    name: string | null
    founded: number | null
    employees: number | null
    address: string | null
    city: string | null
    country: string | null
    zipCode: string | null
    phone: string | null
    website: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: number | null
    symbol: string | null
    name: string | null
    founded: number | null
    employees: number | null
    address: string | null
    city: string | null
    country: string | null
    zipCode: string | null
    phone: string | null
    website: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    symbol: number
    name: number
    founded: number
    employees: number
    address: number
    city: number
    country: number
    zipCode: number
    phone: number
    website: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyAvgAggregateInputType = {
    id?: true
    founded?: true
    employees?: true
  }

  export type CompanySumAggregateInputType = {
    id?: true
    founded?: true
    employees?: true
  }

  export type CompanyMinAggregateInputType = {
    id?: true
    symbol?: true
    name?: true
    founded?: true
    employees?: true
    address?: true
    city?: true
    country?: true
    zipCode?: true
    phone?: true
    website?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    symbol?: true
    name?: true
    founded?: true
    employees?: true
    address?: true
    city?: true
    country?: true
    zipCode?: true
    phone?: true
    website?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    symbol?: true
    name?: true
    founded?: true
    employees?: true
    address?: true
    city?: true
    country?: true
    zipCode?: true
    phone?: true
    website?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _avg?: CompanyAvgAggregateInputType
    _sum?: CompanySumAggregateInputType
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: number
    symbol: string
    name: string
    founded: number
    employees: number
    address: string
    city: string
    country: string
    zipCode: string
    phone: string
    website: string
    description: string
    createdAt: Date
    updatedAt: Date | null
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol?: boolean
    name?: boolean
    founded?: boolean
    employees?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    zipCode?: boolean
    phone?: boolean
    website?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stocks?: boolean | Company$stocksArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol?: boolean
    name?: boolean
    founded?: boolean
    employees?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    zipCode?: boolean
    phone?: boolean
    website?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["company"]>


  export type CompanySelectScalar = {
    id?: boolean
    symbol?: boolean
    name?: boolean
    founded?: boolean
    employees?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    zipCode?: boolean
    phone?: boolean
    website?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompanyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "symbol" | "name" | "founded" | "employees" | "address" | "city" | "country" | "zipCode" | "phone" | "website" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["company"]>
  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stocks?: boolean | Company$stocksArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      stocks: Prisma.$StockPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      symbol: string
      name: string
      founded: number
      employees: number
      address: string
      city: string
      country: string
      zipCode: string
      phone: string
      website: string
      description: string
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFindManyArgs>(args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends CompanyCreateArgs>(args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCreateManyArgs>(args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {CompanyCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends CompanyDeleteArgs>(args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUpdateArgs>(args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDeleteManyArgs>(args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUpdateManyArgs>(args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stocks<T extends Company$stocksArgs<ExtArgs> = {}>(args?: Subset<T, Company$stocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Company model
   */ 
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'Int'>
    readonly symbol: FieldRef<"Company", 'String'>
    readonly name: FieldRef<"Company", 'String'>
    readonly founded: FieldRef<"Company", 'Int'>
    readonly employees: FieldRef<"Company", 'Int'>
    readonly address: FieldRef<"Company", 'String'>
    readonly city: FieldRef<"Company", 'String'>
    readonly country: FieldRef<"Company", 'String'>
    readonly zipCode: FieldRef<"Company", 'String'>
    readonly phone: FieldRef<"Company", 'String'>
    readonly website: FieldRef<"Company", 'String'>
    readonly description: FieldRef<"Company", 'String'>
    readonly createdAt: FieldRef<"Company", 'DateTime'>
    readonly updatedAt: FieldRef<"Company", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company createManyAndReturn
   */
  export type CompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
  }

  /**
   * Company.stocks
   */
  export type Company$stocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    where?: StockWhereInput
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    cursor?: StockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockScalarFieldEnum | StockScalarFieldEnum[]
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
  }


  /**
   * Model Stock
   */

  export type AggregateStock = {
    _count: StockCountAggregateOutputType | null
    _avg: StockAvgAggregateOutputType | null
    _sum: StockSumAggregateOutputType | null
    _min: StockMinAggregateOutputType | null
    _max: StockMaxAggregateOutputType | null
  }

  export type StockAvgAggregateOutputType = {
    stock_id: number | null
    company_id: number | null
    change: number | null
  }

  export type StockSumAggregateOutputType = {
    stock_id: number | null
    company_id: number | null
    change: number | null
  }

  export type StockMinAggregateOutputType = {
    stock_id: number | null
    symbol: string | null
    sector: string | null
    company_id: number | null
    change: number | null
  }

  export type StockMaxAggregateOutputType = {
    stock_id: number | null
    symbol: string | null
    sector: string | null
    company_id: number | null
    change: number | null
  }

  export type StockCountAggregateOutputType = {
    stock_id: number
    symbol: number
    sector: number
    company_id: number
    change: number
    _all: number
  }


  export type StockAvgAggregateInputType = {
    stock_id?: true
    company_id?: true
    change?: true
  }

  export type StockSumAggregateInputType = {
    stock_id?: true
    company_id?: true
    change?: true
  }

  export type StockMinAggregateInputType = {
    stock_id?: true
    symbol?: true
    sector?: true
    company_id?: true
    change?: true
  }

  export type StockMaxAggregateInputType = {
    stock_id?: true
    symbol?: true
    sector?: true
    company_id?: true
    change?: true
  }

  export type StockCountAggregateInputType = {
    stock_id?: true
    symbol?: true
    sector?: true
    company_id?: true
    change?: true
    _all?: true
  }

  export type StockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stock to aggregate.
     */
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stocks
    **/
    _count?: true | StockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockMaxAggregateInputType
  }

  export type GetStockAggregateType<T extends StockAggregateArgs> = {
        [P in keyof T & keyof AggregateStock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStock[P]>
      : GetScalarType<T[P], AggregateStock[P]>
  }




  export type StockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockWhereInput
    orderBy?: StockOrderByWithAggregationInput | StockOrderByWithAggregationInput[]
    by: StockScalarFieldEnum[] | StockScalarFieldEnum
    having?: StockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockCountAggregateInputType | true
    _avg?: StockAvgAggregateInputType
    _sum?: StockSumAggregateInputType
    _min?: StockMinAggregateInputType
    _max?: StockMaxAggregateInputType
  }

  export type StockGroupByOutputType = {
    stock_id: number
    symbol: string
    sector: string | null
    company_id: number | null
    change: number | null
    _count: StockCountAggregateOutputType | null
    _avg: StockAvgAggregateOutputType | null
    _sum: StockSumAggregateOutputType | null
    _min: StockMinAggregateOutputType | null
    _max: StockMaxAggregateOutputType | null
  }

  type GetStockGroupByPayload<T extends StockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockGroupByOutputType[P]>
            : GetScalarType<T[P], StockGroupByOutputType[P]>
        }
      >
    >


  export type StockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    stock_id?: boolean
    symbol?: boolean
    sector?: boolean
    company_id?: boolean
    change?: boolean
    favoriteStock?: boolean | Stock$favoriteStockArgs<ExtArgs>
    hist_prices?: boolean | Stock$hist_pricesArgs<ExtArgs>
    limitOrder?: boolean | Stock$limitOrderArgs<ExtArgs>
    company?: boolean | Stock$companyArgs<ExtArgs>
    trading?: boolean | Stock$tradingArgs<ExtArgs>
    _count?: boolean | StockCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stock"]>

  export type StockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    stock_id?: boolean
    symbol?: boolean
    sector?: boolean
    company_id?: boolean
    change?: boolean
    company?: boolean | Stock$companyArgs<ExtArgs>
  }, ExtArgs["result"]["stock"]>


  export type StockSelectScalar = {
    stock_id?: boolean
    symbol?: boolean
    sector?: boolean
    company_id?: boolean
    change?: boolean
  }

  export type StockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"stock_id" | "symbol" | "sector" | "company_id" | "change", ExtArgs["result"]["stock"]>
  export type StockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    favoriteStock?: boolean | Stock$favoriteStockArgs<ExtArgs>
    hist_prices?: boolean | Stock$hist_pricesArgs<ExtArgs>
    limitOrder?: boolean | Stock$limitOrderArgs<ExtArgs>
    company?: boolean | Stock$companyArgs<ExtArgs>
    trading?: boolean | Stock$tradingArgs<ExtArgs>
    _count?: boolean | StockCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StockIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | Stock$companyArgs<ExtArgs>
  }

  export type $StockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Stock"
    objects: {
      favoriteStock: Prisma.$FavoriteStockPayload<ExtArgs>[]
      hist_prices: Prisma.$HistPricePayload<ExtArgs>[]
      limitOrder: Prisma.$LimitOrderPayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs> | null
      trading: Prisma.$TradePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      stock_id: number
      symbol: string
      sector: string | null
      company_id: number | null
      change: number | null
    }, ExtArgs["result"]["stock"]>
    composites: {}
  }

  type StockGetPayload<S extends boolean | null | undefined | StockDefaultArgs> = $Result.GetResult<Prisma.$StockPayload, S>

  type StockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StockCountAggregateInputType | true
    }

  export interface StockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Stock'], meta: { name: 'Stock' } }
    /**
     * Find zero or one Stock that matches the filter.
     * @param {StockFindUniqueArgs} args - Arguments to find a Stock
     * @example
     * // Get one Stock
     * const stock = await prisma.stock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockFindUniqueArgs>(args: SelectSubset<T, StockFindUniqueArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Stock that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StockFindUniqueOrThrowArgs} args - Arguments to find a Stock
     * @example
     * // Get one Stock
     * const stock = await prisma.stock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockFindUniqueOrThrowArgs>(args: SelectSubset<T, StockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Stock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockFindFirstArgs} args - Arguments to find a Stock
     * @example
     * // Get one Stock
     * const stock = await prisma.stock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockFindFirstArgs>(args?: SelectSubset<T, StockFindFirstArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Stock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockFindFirstOrThrowArgs} args - Arguments to find a Stock
     * @example
     * // Get one Stock
     * const stock = await prisma.stock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockFindFirstOrThrowArgs>(args?: SelectSubset<T, StockFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Stocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stocks
     * const stocks = await prisma.stock.findMany()
     * 
     * // Get first 10 Stocks
     * const stocks = await prisma.stock.findMany({ take: 10 })
     * 
     * // Only select the `stock_id`
     * const stockWithStock_idOnly = await prisma.stock.findMany({ select: { stock_id: true } })
     * 
     */
    findMany<T extends StockFindManyArgs>(args?: SelectSubset<T, StockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Stock.
     * @param {StockCreateArgs} args - Arguments to create a Stock.
     * @example
     * // Create one Stock
     * const Stock = await prisma.stock.create({
     *   data: {
     *     // ... data to create a Stock
     *   }
     * })
     * 
     */
    create<T extends StockCreateArgs>(args: SelectSubset<T, StockCreateArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Stocks.
     * @param {StockCreateManyArgs} args - Arguments to create many Stocks.
     * @example
     * // Create many Stocks
     * const stock = await prisma.stock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockCreateManyArgs>(args?: SelectSubset<T, StockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stocks and returns the data saved in the database.
     * @param {StockCreateManyAndReturnArgs} args - Arguments to create many Stocks.
     * @example
     * // Create many Stocks
     * const stock = await prisma.stock.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stocks and only return the `stock_id`
     * const stockWithStock_idOnly = await prisma.stock.createManyAndReturn({
     *   select: { stock_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StockCreateManyAndReturnArgs>(args?: SelectSubset<T, StockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Stock.
     * @param {StockDeleteArgs} args - Arguments to delete one Stock.
     * @example
     * // Delete one Stock
     * const Stock = await prisma.stock.delete({
     *   where: {
     *     // ... filter to delete one Stock
     *   }
     * })
     * 
     */
    delete<T extends StockDeleteArgs>(args: SelectSubset<T, StockDeleteArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Stock.
     * @param {StockUpdateArgs} args - Arguments to update one Stock.
     * @example
     * // Update one Stock
     * const stock = await prisma.stock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockUpdateArgs>(args: SelectSubset<T, StockUpdateArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Stocks.
     * @param {StockDeleteManyArgs} args - Arguments to filter Stocks to delete.
     * @example
     * // Delete a few Stocks
     * const { count } = await prisma.stock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockDeleteManyArgs>(args?: SelectSubset<T, StockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stocks
     * const stock = await prisma.stock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockUpdateManyArgs>(args: SelectSubset<T, StockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Stock.
     * @param {StockUpsertArgs} args - Arguments to update or create a Stock.
     * @example
     * // Update or create a Stock
     * const stock = await prisma.stock.upsert({
     *   create: {
     *     // ... data to create a Stock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stock we want to update
     *   }
     * })
     */
    upsert<T extends StockUpsertArgs>(args: SelectSubset<T, StockUpsertArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Stocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockCountArgs} args - Arguments to filter Stocks to count.
     * @example
     * // Count the number of Stocks
     * const count = await prisma.stock.count({
     *   where: {
     *     // ... the filter for the Stocks we want to count
     *   }
     * })
    **/
    count<T extends StockCountArgs>(
      args?: Subset<T, StockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockAggregateArgs>(args: Subset<T, StockAggregateArgs>): Prisma.PrismaPromise<GetStockAggregateType<T>>

    /**
     * Group by Stock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockGroupByArgs['orderBy'] }
        : { orderBy?: StockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Stock model
   */
  readonly fields: StockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Stock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    favoriteStock<T extends Stock$favoriteStockArgs<ExtArgs> = {}>(args?: Subset<T, Stock$favoriteStockArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoriteStockPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    hist_prices<T extends Stock$hist_pricesArgs<ExtArgs> = {}>(args?: Subset<T, Stock$hist_pricesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistPricePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    limitOrder<T extends Stock$limitOrderArgs<ExtArgs> = {}>(args?: Subset<T, Stock$limitOrderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LimitOrderPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    company<T extends Stock$companyArgs<ExtArgs> = {}>(args?: Subset<T, Stock$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    trading<T extends Stock$tradingArgs<ExtArgs> = {}>(args?: Subset<T, Stock$tradingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Stock model
   */ 
  interface StockFieldRefs {
    readonly stock_id: FieldRef<"Stock", 'Int'>
    readonly symbol: FieldRef<"Stock", 'String'>
    readonly sector: FieldRef<"Stock", 'String'>
    readonly company_id: FieldRef<"Stock", 'Int'>
    readonly change: FieldRef<"Stock", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Stock findUnique
   */
  export type StockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stock to fetch.
     */
    where: StockWhereUniqueInput
  }

  /**
   * Stock findUniqueOrThrow
   */
  export type StockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stock to fetch.
     */
    where: StockWhereUniqueInput
  }

  /**
   * Stock findFirst
   */
  export type StockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stock to fetch.
     */
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stocks.
     */
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stocks.
     */
    distinct?: StockScalarFieldEnum | StockScalarFieldEnum[]
  }

  /**
   * Stock findFirstOrThrow
   */
  export type StockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stock to fetch.
     */
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stocks.
     */
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stocks.
     */
    distinct?: StockScalarFieldEnum | StockScalarFieldEnum[]
  }

  /**
   * Stock findMany
   */
  export type StockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stocks to fetch.
     */
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stocks.
     */
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    distinct?: StockScalarFieldEnum | StockScalarFieldEnum[]
  }

  /**
   * Stock create
   */
  export type StockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * The data needed to create a Stock.
     */
    data: XOR<StockCreateInput, StockUncheckedCreateInput>
  }

  /**
   * Stock createMany
   */
  export type StockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stocks.
     */
    data: StockCreateManyInput | StockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Stock createManyAndReturn
   */
  export type StockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * The data used to create many Stocks.
     */
    data: StockCreateManyInput | StockCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Stock update
   */
  export type StockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * The data needed to update a Stock.
     */
    data: XOR<StockUpdateInput, StockUncheckedUpdateInput>
    /**
     * Choose, which Stock to update.
     */
    where: StockWhereUniqueInput
  }

  /**
   * Stock updateMany
   */
  export type StockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stocks.
     */
    data: XOR<StockUpdateManyMutationInput, StockUncheckedUpdateManyInput>
    /**
     * Filter which Stocks to update
     */
    where?: StockWhereInput
  }

  /**
   * Stock upsert
   */
  export type StockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * The filter to search for the Stock to update in case it exists.
     */
    where: StockWhereUniqueInput
    /**
     * In case the Stock found by the `where` argument doesn't exist, create a new Stock with this data.
     */
    create: XOR<StockCreateInput, StockUncheckedCreateInput>
    /**
     * In case the Stock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockUpdateInput, StockUncheckedUpdateInput>
  }

  /**
   * Stock delete
   */
  export type StockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter which Stock to delete.
     */
    where: StockWhereUniqueInput
  }

  /**
   * Stock deleteMany
   */
  export type StockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stocks to delete
     */
    where?: StockWhereInput
  }

  /**
   * Stock.favoriteStock
   */
  export type Stock$favoriteStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteStock
     */
    select?: FavoriteStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteStock
     */
    omit?: FavoriteStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteStockInclude<ExtArgs> | null
    where?: FavoriteStockWhereInput
    orderBy?: FavoriteStockOrderByWithRelationInput | FavoriteStockOrderByWithRelationInput[]
    cursor?: FavoriteStockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavoriteStockScalarFieldEnum | FavoriteStockScalarFieldEnum[]
  }

  /**
   * Stock.hist_prices
   */
  export type Stock$hist_pricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistPrice
     */
    select?: HistPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistPrice
     */
    omit?: HistPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistPriceInclude<ExtArgs> | null
    where?: HistPriceWhereInput
    orderBy?: HistPriceOrderByWithRelationInput | HistPriceOrderByWithRelationInput[]
    cursor?: HistPriceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HistPriceScalarFieldEnum | HistPriceScalarFieldEnum[]
  }

  /**
   * Stock.limitOrder
   */
  export type Stock$limitOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LimitOrder
     */
    select?: LimitOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LimitOrder
     */
    omit?: LimitOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LimitOrderInclude<ExtArgs> | null
    where?: LimitOrderWhereInput
    orderBy?: LimitOrderOrderByWithRelationInput | LimitOrderOrderByWithRelationInput[]
    cursor?: LimitOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LimitOrderScalarFieldEnum | LimitOrderScalarFieldEnum[]
  }

  /**
   * Stock.company
   */
  export type Stock$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * Stock.trading
   */
  export type Stock$tradingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trade
     */
    omit?: TradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    where?: TradeWhereInput
    orderBy?: TradeOrderByWithRelationInput | TradeOrderByWithRelationInput[]
    cursor?: TradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TradeScalarFieldEnum | TradeScalarFieldEnum[]
  }

  /**
   * Stock without action
   */
  export type StockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
  }


  /**
   * Model FavoriteStock
   */

  export type AggregateFavoriteStock = {
    _count: FavoriteStockCountAggregateOutputType | null
    _avg: FavoriteStockAvgAggregateOutputType | null
    _sum: FavoriteStockSumAggregateOutputType | null
    _min: FavoriteStockMinAggregateOutputType | null
    _max: FavoriteStockMaxAggregateOutputType | null
  }

  export type FavoriteStockAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    stockId: number | null
  }

  export type FavoriteStockSumAggregateOutputType = {
    id: number | null
    userId: number | null
    stockId: number | null
  }

  export type FavoriteStockMinAggregateOutputType = {
    id: number | null
    userId: number | null
    stockId: number | null
  }

  export type FavoriteStockMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    stockId: number | null
  }

  export type FavoriteStockCountAggregateOutputType = {
    id: number
    userId: number
    stockId: number
    _all: number
  }


  export type FavoriteStockAvgAggregateInputType = {
    id?: true
    userId?: true
    stockId?: true
  }

  export type FavoriteStockSumAggregateInputType = {
    id?: true
    userId?: true
    stockId?: true
  }

  export type FavoriteStockMinAggregateInputType = {
    id?: true
    userId?: true
    stockId?: true
  }

  export type FavoriteStockMaxAggregateInputType = {
    id?: true
    userId?: true
    stockId?: true
  }

  export type FavoriteStockCountAggregateInputType = {
    id?: true
    userId?: true
    stockId?: true
    _all?: true
  }

  export type FavoriteStockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FavoriteStock to aggregate.
     */
    where?: FavoriteStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FavoriteStocks to fetch.
     */
    orderBy?: FavoriteStockOrderByWithRelationInput | FavoriteStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FavoriteStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FavoriteStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FavoriteStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FavoriteStocks
    **/
    _count?: true | FavoriteStockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FavoriteStockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FavoriteStockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FavoriteStockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FavoriteStockMaxAggregateInputType
  }

  export type GetFavoriteStockAggregateType<T extends FavoriteStockAggregateArgs> = {
        [P in keyof T & keyof AggregateFavoriteStock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFavoriteStock[P]>
      : GetScalarType<T[P], AggregateFavoriteStock[P]>
  }




  export type FavoriteStockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteStockWhereInput
    orderBy?: FavoriteStockOrderByWithAggregationInput | FavoriteStockOrderByWithAggregationInput[]
    by: FavoriteStockScalarFieldEnum[] | FavoriteStockScalarFieldEnum
    having?: FavoriteStockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FavoriteStockCountAggregateInputType | true
    _avg?: FavoriteStockAvgAggregateInputType
    _sum?: FavoriteStockSumAggregateInputType
    _min?: FavoriteStockMinAggregateInputType
    _max?: FavoriteStockMaxAggregateInputType
  }

  export type FavoriteStockGroupByOutputType = {
    id: number
    userId: number
    stockId: number
    _count: FavoriteStockCountAggregateOutputType | null
    _avg: FavoriteStockAvgAggregateOutputType | null
    _sum: FavoriteStockSumAggregateOutputType | null
    _min: FavoriteStockMinAggregateOutputType | null
    _max: FavoriteStockMaxAggregateOutputType | null
  }

  type GetFavoriteStockGroupByPayload<T extends FavoriteStockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FavoriteStockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FavoriteStockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FavoriteStockGroupByOutputType[P]>
            : GetScalarType<T[P], FavoriteStockGroupByOutputType[P]>
        }
      >
    >


  export type FavoriteStockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    stockId?: boolean
    stock?: boolean | StockDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favoriteStock"]>

  export type FavoriteStockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    stockId?: boolean
    stock?: boolean | StockDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favoriteStock"]>


  export type FavoriteStockSelectScalar = {
    id?: boolean
    userId?: boolean
    stockId?: boolean
  }

  export type FavoriteStockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "stockId", ExtArgs["result"]["favoriteStock"]>
  export type FavoriteStockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stock?: boolean | StockDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FavoriteStockIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stock?: boolean | StockDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FavoriteStockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FavoriteStock"
    objects: {
      stock: Prisma.$StockPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      stockId: number
    }, ExtArgs["result"]["favoriteStock"]>
    composites: {}
  }

  type FavoriteStockGetPayload<S extends boolean | null | undefined | FavoriteStockDefaultArgs> = $Result.GetResult<Prisma.$FavoriteStockPayload, S>

  type FavoriteStockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FavoriteStockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FavoriteStockCountAggregateInputType | true
    }

  export interface FavoriteStockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FavoriteStock'], meta: { name: 'FavoriteStock' } }
    /**
     * Find zero or one FavoriteStock that matches the filter.
     * @param {FavoriteStockFindUniqueArgs} args - Arguments to find a FavoriteStock
     * @example
     * // Get one FavoriteStock
     * const favoriteStock = await prisma.favoriteStock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FavoriteStockFindUniqueArgs>(args: SelectSubset<T, FavoriteStockFindUniqueArgs<ExtArgs>>): Prisma__FavoriteStockClient<$Result.GetResult<Prisma.$FavoriteStockPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one FavoriteStock that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FavoriteStockFindUniqueOrThrowArgs} args - Arguments to find a FavoriteStock
     * @example
     * // Get one FavoriteStock
     * const favoriteStock = await prisma.favoriteStock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FavoriteStockFindUniqueOrThrowArgs>(args: SelectSubset<T, FavoriteStockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FavoriteStockClient<$Result.GetResult<Prisma.$FavoriteStockPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first FavoriteStock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteStockFindFirstArgs} args - Arguments to find a FavoriteStock
     * @example
     * // Get one FavoriteStock
     * const favoriteStock = await prisma.favoriteStock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FavoriteStockFindFirstArgs>(args?: SelectSubset<T, FavoriteStockFindFirstArgs<ExtArgs>>): Prisma__FavoriteStockClient<$Result.GetResult<Prisma.$FavoriteStockPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first FavoriteStock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteStockFindFirstOrThrowArgs} args - Arguments to find a FavoriteStock
     * @example
     * // Get one FavoriteStock
     * const favoriteStock = await prisma.favoriteStock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FavoriteStockFindFirstOrThrowArgs>(args?: SelectSubset<T, FavoriteStockFindFirstOrThrowArgs<ExtArgs>>): Prisma__FavoriteStockClient<$Result.GetResult<Prisma.$FavoriteStockPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more FavoriteStocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteStockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FavoriteStocks
     * const favoriteStocks = await prisma.favoriteStock.findMany()
     * 
     * // Get first 10 FavoriteStocks
     * const favoriteStocks = await prisma.favoriteStock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const favoriteStockWithIdOnly = await prisma.favoriteStock.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FavoriteStockFindManyArgs>(args?: SelectSubset<T, FavoriteStockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoriteStockPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a FavoriteStock.
     * @param {FavoriteStockCreateArgs} args - Arguments to create a FavoriteStock.
     * @example
     * // Create one FavoriteStock
     * const FavoriteStock = await prisma.favoriteStock.create({
     *   data: {
     *     // ... data to create a FavoriteStock
     *   }
     * })
     * 
     */
    create<T extends FavoriteStockCreateArgs>(args: SelectSubset<T, FavoriteStockCreateArgs<ExtArgs>>): Prisma__FavoriteStockClient<$Result.GetResult<Prisma.$FavoriteStockPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many FavoriteStocks.
     * @param {FavoriteStockCreateManyArgs} args - Arguments to create many FavoriteStocks.
     * @example
     * // Create many FavoriteStocks
     * const favoriteStock = await prisma.favoriteStock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FavoriteStockCreateManyArgs>(args?: SelectSubset<T, FavoriteStockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FavoriteStocks and returns the data saved in the database.
     * @param {FavoriteStockCreateManyAndReturnArgs} args - Arguments to create many FavoriteStocks.
     * @example
     * // Create many FavoriteStocks
     * const favoriteStock = await prisma.favoriteStock.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FavoriteStocks and only return the `id`
     * const favoriteStockWithIdOnly = await prisma.favoriteStock.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FavoriteStockCreateManyAndReturnArgs>(args?: SelectSubset<T, FavoriteStockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoriteStockPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a FavoriteStock.
     * @param {FavoriteStockDeleteArgs} args - Arguments to delete one FavoriteStock.
     * @example
     * // Delete one FavoriteStock
     * const FavoriteStock = await prisma.favoriteStock.delete({
     *   where: {
     *     // ... filter to delete one FavoriteStock
     *   }
     * })
     * 
     */
    delete<T extends FavoriteStockDeleteArgs>(args: SelectSubset<T, FavoriteStockDeleteArgs<ExtArgs>>): Prisma__FavoriteStockClient<$Result.GetResult<Prisma.$FavoriteStockPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one FavoriteStock.
     * @param {FavoriteStockUpdateArgs} args - Arguments to update one FavoriteStock.
     * @example
     * // Update one FavoriteStock
     * const favoriteStock = await prisma.favoriteStock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FavoriteStockUpdateArgs>(args: SelectSubset<T, FavoriteStockUpdateArgs<ExtArgs>>): Prisma__FavoriteStockClient<$Result.GetResult<Prisma.$FavoriteStockPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more FavoriteStocks.
     * @param {FavoriteStockDeleteManyArgs} args - Arguments to filter FavoriteStocks to delete.
     * @example
     * // Delete a few FavoriteStocks
     * const { count } = await prisma.favoriteStock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FavoriteStockDeleteManyArgs>(args?: SelectSubset<T, FavoriteStockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FavoriteStocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteStockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FavoriteStocks
     * const favoriteStock = await prisma.favoriteStock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FavoriteStockUpdateManyArgs>(args: SelectSubset<T, FavoriteStockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FavoriteStock.
     * @param {FavoriteStockUpsertArgs} args - Arguments to update or create a FavoriteStock.
     * @example
     * // Update or create a FavoriteStock
     * const favoriteStock = await prisma.favoriteStock.upsert({
     *   create: {
     *     // ... data to create a FavoriteStock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FavoriteStock we want to update
     *   }
     * })
     */
    upsert<T extends FavoriteStockUpsertArgs>(args: SelectSubset<T, FavoriteStockUpsertArgs<ExtArgs>>): Prisma__FavoriteStockClient<$Result.GetResult<Prisma.$FavoriteStockPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of FavoriteStocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteStockCountArgs} args - Arguments to filter FavoriteStocks to count.
     * @example
     * // Count the number of FavoriteStocks
     * const count = await prisma.favoriteStock.count({
     *   where: {
     *     // ... the filter for the FavoriteStocks we want to count
     *   }
     * })
    **/
    count<T extends FavoriteStockCountArgs>(
      args?: Subset<T, FavoriteStockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FavoriteStockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FavoriteStock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteStockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FavoriteStockAggregateArgs>(args: Subset<T, FavoriteStockAggregateArgs>): Prisma.PrismaPromise<GetFavoriteStockAggregateType<T>>

    /**
     * Group by FavoriteStock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteStockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FavoriteStockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FavoriteStockGroupByArgs['orderBy'] }
        : { orderBy?: FavoriteStockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FavoriteStockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFavoriteStockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FavoriteStock model
   */
  readonly fields: FavoriteStockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FavoriteStock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FavoriteStockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stock<T extends StockDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StockDefaultArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FavoriteStock model
   */ 
  interface FavoriteStockFieldRefs {
    readonly id: FieldRef<"FavoriteStock", 'Int'>
    readonly userId: FieldRef<"FavoriteStock", 'Int'>
    readonly stockId: FieldRef<"FavoriteStock", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * FavoriteStock findUnique
   */
  export type FavoriteStockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteStock
     */
    select?: FavoriteStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteStock
     */
    omit?: FavoriteStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteStockInclude<ExtArgs> | null
    /**
     * Filter, which FavoriteStock to fetch.
     */
    where: FavoriteStockWhereUniqueInput
  }

  /**
   * FavoriteStock findUniqueOrThrow
   */
  export type FavoriteStockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteStock
     */
    select?: FavoriteStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteStock
     */
    omit?: FavoriteStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteStockInclude<ExtArgs> | null
    /**
     * Filter, which FavoriteStock to fetch.
     */
    where: FavoriteStockWhereUniqueInput
  }

  /**
   * FavoriteStock findFirst
   */
  export type FavoriteStockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteStock
     */
    select?: FavoriteStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteStock
     */
    omit?: FavoriteStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteStockInclude<ExtArgs> | null
    /**
     * Filter, which FavoriteStock to fetch.
     */
    where?: FavoriteStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FavoriteStocks to fetch.
     */
    orderBy?: FavoriteStockOrderByWithRelationInput | FavoriteStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FavoriteStocks.
     */
    cursor?: FavoriteStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FavoriteStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FavoriteStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FavoriteStocks.
     */
    distinct?: FavoriteStockScalarFieldEnum | FavoriteStockScalarFieldEnum[]
  }

  /**
   * FavoriteStock findFirstOrThrow
   */
  export type FavoriteStockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteStock
     */
    select?: FavoriteStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteStock
     */
    omit?: FavoriteStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteStockInclude<ExtArgs> | null
    /**
     * Filter, which FavoriteStock to fetch.
     */
    where?: FavoriteStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FavoriteStocks to fetch.
     */
    orderBy?: FavoriteStockOrderByWithRelationInput | FavoriteStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FavoriteStocks.
     */
    cursor?: FavoriteStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FavoriteStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FavoriteStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FavoriteStocks.
     */
    distinct?: FavoriteStockScalarFieldEnum | FavoriteStockScalarFieldEnum[]
  }

  /**
   * FavoriteStock findMany
   */
  export type FavoriteStockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteStock
     */
    select?: FavoriteStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteStock
     */
    omit?: FavoriteStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteStockInclude<ExtArgs> | null
    /**
     * Filter, which FavoriteStocks to fetch.
     */
    where?: FavoriteStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FavoriteStocks to fetch.
     */
    orderBy?: FavoriteStockOrderByWithRelationInput | FavoriteStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FavoriteStocks.
     */
    cursor?: FavoriteStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FavoriteStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FavoriteStocks.
     */
    skip?: number
    distinct?: FavoriteStockScalarFieldEnum | FavoriteStockScalarFieldEnum[]
  }

  /**
   * FavoriteStock create
   */
  export type FavoriteStockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteStock
     */
    select?: FavoriteStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteStock
     */
    omit?: FavoriteStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteStockInclude<ExtArgs> | null
    /**
     * The data needed to create a FavoriteStock.
     */
    data: XOR<FavoriteStockCreateInput, FavoriteStockUncheckedCreateInput>
  }

  /**
   * FavoriteStock createMany
   */
  export type FavoriteStockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FavoriteStocks.
     */
    data: FavoriteStockCreateManyInput | FavoriteStockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FavoriteStock createManyAndReturn
   */
  export type FavoriteStockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteStock
     */
    select?: FavoriteStockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteStock
     */
    omit?: FavoriteStockOmit<ExtArgs> | null
    /**
     * The data used to create many FavoriteStocks.
     */
    data: FavoriteStockCreateManyInput | FavoriteStockCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteStockIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FavoriteStock update
   */
  export type FavoriteStockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteStock
     */
    select?: FavoriteStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteStock
     */
    omit?: FavoriteStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteStockInclude<ExtArgs> | null
    /**
     * The data needed to update a FavoriteStock.
     */
    data: XOR<FavoriteStockUpdateInput, FavoriteStockUncheckedUpdateInput>
    /**
     * Choose, which FavoriteStock to update.
     */
    where: FavoriteStockWhereUniqueInput
  }

  /**
   * FavoriteStock updateMany
   */
  export type FavoriteStockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FavoriteStocks.
     */
    data: XOR<FavoriteStockUpdateManyMutationInput, FavoriteStockUncheckedUpdateManyInput>
    /**
     * Filter which FavoriteStocks to update
     */
    where?: FavoriteStockWhereInput
  }

  /**
   * FavoriteStock upsert
   */
  export type FavoriteStockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteStock
     */
    select?: FavoriteStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteStock
     */
    omit?: FavoriteStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteStockInclude<ExtArgs> | null
    /**
     * The filter to search for the FavoriteStock to update in case it exists.
     */
    where: FavoriteStockWhereUniqueInput
    /**
     * In case the FavoriteStock found by the `where` argument doesn't exist, create a new FavoriteStock with this data.
     */
    create: XOR<FavoriteStockCreateInput, FavoriteStockUncheckedCreateInput>
    /**
     * In case the FavoriteStock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FavoriteStockUpdateInput, FavoriteStockUncheckedUpdateInput>
  }

  /**
   * FavoriteStock delete
   */
  export type FavoriteStockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteStock
     */
    select?: FavoriteStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteStock
     */
    omit?: FavoriteStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteStockInclude<ExtArgs> | null
    /**
     * Filter which FavoriteStock to delete.
     */
    where: FavoriteStockWhereUniqueInput
  }

  /**
   * FavoriteStock deleteMany
   */
  export type FavoriteStockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FavoriteStocks to delete
     */
    where?: FavoriteStockWhereInput
  }

  /**
   * FavoriteStock without action
   */
  export type FavoriteStockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteStock
     */
    select?: FavoriteStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteStock
     */
    omit?: FavoriteStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteStockInclude<ExtArgs> | null
  }


  /**
   * Model HistPrice
   */

  export type AggregateHistPrice = {
    _count: HistPriceCountAggregateOutputType | null
    _avg: HistPriceAvgAggregateOutputType | null
    _sum: HistPriceSumAggregateOutputType | null
    _min: HistPriceMinAggregateOutputType | null
    _max: HistPriceMaxAggregateOutputType | null
  }

  export type HistPriceAvgAggregateOutputType = {
    price_id: number | null
    stock_id: number | null
    open_price: Decimal | null
    high_price: Decimal | null
    low_price: Decimal | null
    close_price: Decimal | null
    volume: number | null
  }

  export type HistPriceSumAggregateOutputType = {
    price_id: number | null
    stock_id: number | null
    open_price: Decimal | null
    high_price: Decimal | null
    low_price: Decimal | null
    close_price: Decimal | null
    volume: bigint | null
  }

  export type HistPriceMinAggregateOutputType = {
    price_id: number | null
    stock_id: number | null
    date: Date | null
    open_price: Decimal | null
    high_price: Decimal | null
    low_price: Decimal | null
    close_price: Decimal | null
    volume: bigint | null
  }

  export type HistPriceMaxAggregateOutputType = {
    price_id: number | null
    stock_id: number | null
    date: Date | null
    open_price: Decimal | null
    high_price: Decimal | null
    low_price: Decimal | null
    close_price: Decimal | null
    volume: bigint | null
  }

  export type HistPriceCountAggregateOutputType = {
    price_id: number
    stock_id: number
    date: number
    open_price: number
    high_price: number
    low_price: number
    close_price: number
    volume: number
    _all: number
  }


  export type HistPriceAvgAggregateInputType = {
    price_id?: true
    stock_id?: true
    open_price?: true
    high_price?: true
    low_price?: true
    close_price?: true
    volume?: true
  }

  export type HistPriceSumAggregateInputType = {
    price_id?: true
    stock_id?: true
    open_price?: true
    high_price?: true
    low_price?: true
    close_price?: true
    volume?: true
  }

  export type HistPriceMinAggregateInputType = {
    price_id?: true
    stock_id?: true
    date?: true
    open_price?: true
    high_price?: true
    low_price?: true
    close_price?: true
    volume?: true
  }

  export type HistPriceMaxAggregateInputType = {
    price_id?: true
    stock_id?: true
    date?: true
    open_price?: true
    high_price?: true
    low_price?: true
    close_price?: true
    volume?: true
  }

  export type HistPriceCountAggregateInputType = {
    price_id?: true
    stock_id?: true
    date?: true
    open_price?: true
    high_price?: true
    low_price?: true
    close_price?: true
    volume?: true
    _all?: true
  }

  export type HistPriceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HistPrice to aggregate.
     */
    where?: HistPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistPrices to fetch.
     */
    orderBy?: HistPriceOrderByWithRelationInput | HistPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HistPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HistPrices
    **/
    _count?: true | HistPriceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HistPriceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HistPriceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HistPriceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HistPriceMaxAggregateInputType
  }

  export type GetHistPriceAggregateType<T extends HistPriceAggregateArgs> = {
        [P in keyof T & keyof AggregateHistPrice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistPrice[P]>
      : GetScalarType<T[P], AggregateHistPrice[P]>
  }




  export type HistPriceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HistPriceWhereInput
    orderBy?: HistPriceOrderByWithAggregationInput | HistPriceOrderByWithAggregationInput[]
    by: HistPriceScalarFieldEnum[] | HistPriceScalarFieldEnum
    having?: HistPriceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HistPriceCountAggregateInputType | true
    _avg?: HistPriceAvgAggregateInputType
    _sum?: HistPriceSumAggregateInputType
    _min?: HistPriceMinAggregateInputType
    _max?: HistPriceMaxAggregateInputType
  }

  export type HistPriceGroupByOutputType = {
    price_id: number
    stock_id: number
    date: Date
    open_price: Decimal | null
    high_price: Decimal | null
    low_price: Decimal | null
    close_price: Decimal
    volume: bigint | null
    _count: HistPriceCountAggregateOutputType | null
    _avg: HistPriceAvgAggregateOutputType | null
    _sum: HistPriceSumAggregateOutputType | null
    _min: HistPriceMinAggregateOutputType | null
    _max: HistPriceMaxAggregateOutputType | null
  }

  type GetHistPriceGroupByPayload<T extends HistPriceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HistPriceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HistPriceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HistPriceGroupByOutputType[P]>
            : GetScalarType<T[P], HistPriceGroupByOutputType[P]>
        }
      >
    >


  export type HistPriceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    price_id?: boolean
    stock_id?: boolean
    date?: boolean
    open_price?: boolean
    high_price?: boolean
    low_price?: boolean
    close_price?: boolean
    volume?: boolean
    stock?: boolean | StockDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["histPrice"]>

  export type HistPriceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    price_id?: boolean
    stock_id?: boolean
    date?: boolean
    open_price?: boolean
    high_price?: boolean
    low_price?: boolean
    close_price?: boolean
    volume?: boolean
    stock?: boolean | StockDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["histPrice"]>


  export type HistPriceSelectScalar = {
    price_id?: boolean
    stock_id?: boolean
    date?: boolean
    open_price?: boolean
    high_price?: boolean
    low_price?: boolean
    close_price?: boolean
    volume?: boolean
  }

  export type HistPriceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"price_id" | "stock_id" | "date" | "open_price" | "high_price" | "low_price" | "close_price" | "volume", ExtArgs["result"]["histPrice"]>
  export type HistPriceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stock?: boolean | StockDefaultArgs<ExtArgs>
  }
  export type HistPriceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stock?: boolean | StockDefaultArgs<ExtArgs>
  }

  export type $HistPricePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HistPrice"
    objects: {
      stock: Prisma.$StockPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      price_id: number
      stock_id: number
      date: Date
      open_price: Prisma.Decimal | null
      high_price: Prisma.Decimal | null
      low_price: Prisma.Decimal | null
      close_price: Prisma.Decimal
      volume: bigint | null
    }, ExtArgs["result"]["histPrice"]>
    composites: {}
  }

  type HistPriceGetPayload<S extends boolean | null | undefined | HistPriceDefaultArgs> = $Result.GetResult<Prisma.$HistPricePayload, S>

  type HistPriceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HistPriceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HistPriceCountAggregateInputType | true
    }

  export interface HistPriceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HistPrice'], meta: { name: 'HistPrice' } }
    /**
     * Find zero or one HistPrice that matches the filter.
     * @param {HistPriceFindUniqueArgs} args - Arguments to find a HistPrice
     * @example
     * // Get one HistPrice
     * const histPrice = await prisma.histPrice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HistPriceFindUniqueArgs>(args: SelectSubset<T, HistPriceFindUniqueArgs<ExtArgs>>): Prisma__HistPriceClient<$Result.GetResult<Prisma.$HistPricePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one HistPrice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HistPriceFindUniqueOrThrowArgs} args - Arguments to find a HistPrice
     * @example
     * // Get one HistPrice
     * const histPrice = await prisma.histPrice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HistPriceFindUniqueOrThrowArgs>(args: SelectSubset<T, HistPriceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HistPriceClient<$Result.GetResult<Prisma.$HistPricePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first HistPrice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistPriceFindFirstArgs} args - Arguments to find a HistPrice
     * @example
     * // Get one HistPrice
     * const histPrice = await prisma.histPrice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HistPriceFindFirstArgs>(args?: SelectSubset<T, HistPriceFindFirstArgs<ExtArgs>>): Prisma__HistPriceClient<$Result.GetResult<Prisma.$HistPricePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first HistPrice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistPriceFindFirstOrThrowArgs} args - Arguments to find a HistPrice
     * @example
     * // Get one HistPrice
     * const histPrice = await prisma.histPrice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HistPriceFindFirstOrThrowArgs>(args?: SelectSubset<T, HistPriceFindFirstOrThrowArgs<ExtArgs>>): Prisma__HistPriceClient<$Result.GetResult<Prisma.$HistPricePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more HistPrices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistPriceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HistPrices
     * const histPrices = await prisma.histPrice.findMany()
     * 
     * // Get first 10 HistPrices
     * const histPrices = await prisma.histPrice.findMany({ take: 10 })
     * 
     * // Only select the `price_id`
     * const histPriceWithPrice_idOnly = await prisma.histPrice.findMany({ select: { price_id: true } })
     * 
     */
    findMany<T extends HistPriceFindManyArgs>(args?: SelectSubset<T, HistPriceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistPricePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a HistPrice.
     * @param {HistPriceCreateArgs} args - Arguments to create a HistPrice.
     * @example
     * // Create one HistPrice
     * const HistPrice = await prisma.histPrice.create({
     *   data: {
     *     // ... data to create a HistPrice
     *   }
     * })
     * 
     */
    create<T extends HistPriceCreateArgs>(args: SelectSubset<T, HistPriceCreateArgs<ExtArgs>>): Prisma__HistPriceClient<$Result.GetResult<Prisma.$HistPricePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many HistPrices.
     * @param {HistPriceCreateManyArgs} args - Arguments to create many HistPrices.
     * @example
     * // Create many HistPrices
     * const histPrice = await prisma.histPrice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HistPriceCreateManyArgs>(args?: SelectSubset<T, HistPriceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HistPrices and returns the data saved in the database.
     * @param {HistPriceCreateManyAndReturnArgs} args - Arguments to create many HistPrices.
     * @example
     * // Create many HistPrices
     * const histPrice = await prisma.histPrice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HistPrices and only return the `price_id`
     * const histPriceWithPrice_idOnly = await prisma.histPrice.createManyAndReturn({
     *   select: { price_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HistPriceCreateManyAndReturnArgs>(args?: SelectSubset<T, HistPriceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistPricePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a HistPrice.
     * @param {HistPriceDeleteArgs} args - Arguments to delete one HistPrice.
     * @example
     * // Delete one HistPrice
     * const HistPrice = await prisma.histPrice.delete({
     *   where: {
     *     // ... filter to delete one HistPrice
     *   }
     * })
     * 
     */
    delete<T extends HistPriceDeleteArgs>(args: SelectSubset<T, HistPriceDeleteArgs<ExtArgs>>): Prisma__HistPriceClient<$Result.GetResult<Prisma.$HistPricePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one HistPrice.
     * @param {HistPriceUpdateArgs} args - Arguments to update one HistPrice.
     * @example
     * // Update one HistPrice
     * const histPrice = await prisma.histPrice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HistPriceUpdateArgs>(args: SelectSubset<T, HistPriceUpdateArgs<ExtArgs>>): Prisma__HistPriceClient<$Result.GetResult<Prisma.$HistPricePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more HistPrices.
     * @param {HistPriceDeleteManyArgs} args - Arguments to filter HistPrices to delete.
     * @example
     * // Delete a few HistPrices
     * const { count } = await prisma.histPrice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HistPriceDeleteManyArgs>(args?: SelectSubset<T, HistPriceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HistPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistPriceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HistPrices
     * const histPrice = await prisma.histPrice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HistPriceUpdateManyArgs>(args: SelectSubset<T, HistPriceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HistPrice.
     * @param {HistPriceUpsertArgs} args - Arguments to update or create a HistPrice.
     * @example
     * // Update or create a HistPrice
     * const histPrice = await prisma.histPrice.upsert({
     *   create: {
     *     // ... data to create a HistPrice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HistPrice we want to update
     *   }
     * })
     */
    upsert<T extends HistPriceUpsertArgs>(args: SelectSubset<T, HistPriceUpsertArgs<ExtArgs>>): Prisma__HistPriceClient<$Result.GetResult<Prisma.$HistPricePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of HistPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistPriceCountArgs} args - Arguments to filter HistPrices to count.
     * @example
     * // Count the number of HistPrices
     * const count = await prisma.histPrice.count({
     *   where: {
     *     // ... the filter for the HistPrices we want to count
     *   }
     * })
    **/
    count<T extends HistPriceCountArgs>(
      args?: Subset<T, HistPriceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HistPriceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HistPrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistPriceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HistPriceAggregateArgs>(args: Subset<T, HistPriceAggregateArgs>): Prisma.PrismaPromise<GetHistPriceAggregateType<T>>

    /**
     * Group by HistPrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistPriceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HistPriceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HistPriceGroupByArgs['orderBy'] }
        : { orderBy?: HistPriceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HistPriceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistPriceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HistPrice model
   */
  readonly fields: HistPriceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HistPrice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HistPriceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stock<T extends StockDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StockDefaultArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HistPrice model
   */ 
  interface HistPriceFieldRefs {
    readonly price_id: FieldRef<"HistPrice", 'Int'>
    readonly stock_id: FieldRef<"HistPrice", 'Int'>
    readonly date: FieldRef<"HistPrice", 'DateTime'>
    readonly open_price: FieldRef<"HistPrice", 'Decimal'>
    readonly high_price: FieldRef<"HistPrice", 'Decimal'>
    readonly low_price: FieldRef<"HistPrice", 'Decimal'>
    readonly close_price: FieldRef<"HistPrice", 'Decimal'>
    readonly volume: FieldRef<"HistPrice", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * HistPrice findUnique
   */
  export type HistPriceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistPrice
     */
    select?: HistPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistPrice
     */
    omit?: HistPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistPriceInclude<ExtArgs> | null
    /**
     * Filter, which HistPrice to fetch.
     */
    where: HistPriceWhereUniqueInput
  }

  /**
   * HistPrice findUniqueOrThrow
   */
  export type HistPriceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistPrice
     */
    select?: HistPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistPrice
     */
    omit?: HistPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistPriceInclude<ExtArgs> | null
    /**
     * Filter, which HistPrice to fetch.
     */
    where: HistPriceWhereUniqueInput
  }

  /**
   * HistPrice findFirst
   */
  export type HistPriceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistPrice
     */
    select?: HistPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistPrice
     */
    omit?: HistPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistPriceInclude<ExtArgs> | null
    /**
     * Filter, which HistPrice to fetch.
     */
    where?: HistPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistPrices to fetch.
     */
    orderBy?: HistPriceOrderByWithRelationInput | HistPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HistPrices.
     */
    cursor?: HistPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HistPrices.
     */
    distinct?: HistPriceScalarFieldEnum | HistPriceScalarFieldEnum[]
  }

  /**
   * HistPrice findFirstOrThrow
   */
  export type HistPriceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistPrice
     */
    select?: HistPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistPrice
     */
    omit?: HistPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistPriceInclude<ExtArgs> | null
    /**
     * Filter, which HistPrice to fetch.
     */
    where?: HistPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistPrices to fetch.
     */
    orderBy?: HistPriceOrderByWithRelationInput | HistPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HistPrices.
     */
    cursor?: HistPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HistPrices.
     */
    distinct?: HistPriceScalarFieldEnum | HistPriceScalarFieldEnum[]
  }

  /**
   * HistPrice findMany
   */
  export type HistPriceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistPrice
     */
    select?: HistPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistPrice
     */
    omit?: HistPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistPriceInclude<ExtArgs> | null
    /**
     * Filter, which HistPrices to fetch.
     */
    where?: HistPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistPrices to fetch.
     */
    orderBy?: HistPriceOrderByWithRelationInput | HistPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HistPrices.
     */
    cursor?: HistPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistPrices.
     */
    skip?: number
    distinct?: HistPriceScalarFieldEnum | HistPriceScalarFieldEnum[]
  }

  /**
   * HistPrice create
   */
  export type HistPriceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistPrice
     */
    select?: HistPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistPrice
     */
    omit?: HistPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistPriceInclude<ExtArgs> | null
    /**
     * The data needed to create a HistPrice.
     */
    data: XOR<HistPriceCreateInput, HistPriceUncheckedCreateInput>
  }

  /**
   * HistPrice createMany
   */
  export type HistPriceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HistPrices.
     */
    data: HistPriceCreateManyInput | HistPriceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HistPrice createManyAndReturn
   */
  export type HistPriceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistPrice
     */
    select?: HistPriceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HistPrice
     */
    omit?: HistPriceOmit<ExtArgs> | null
    /**
     * The data used to create many HistPrices.
     */
    data: HistPriceCreateManyInput | HistPriceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistPriceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HistPrice update
   */
  export type HistPriceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistPrice
     */
    select?: HistPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistPrice
     */
    omit?: HistPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistPriceInclude<ExtArgs> | null
    /**
     * The data needed to update a HistPrice.
     */
    data: XOR<HistPriceUpdateInput, HistPriceUncheckedUpdateInput>
    /**
     * Choose, which HistPrice to update.
     */
    where: HistPriceWhereUniqueInput
  }

  /**
   * HistPrice updateMany
   */
  export type HistPriceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HistPrices.
     */
    data: XOR<HistPriceUpdateManyMutationInput, HistPriceUncheckedUpdateManyInput>
    /**
     * Filter which HistPrices to update
     */
    where?: HistPriceWhereInput
  }

  /**
   * HistPrice upsert
   */
  export type HistPriceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistPrice
     */
    select?: HistPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistPrice
     */
    omit?: HistPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistPriceInclude<ExtArgs> | null
    /**
     * The filter to search for the HistPrice to update in case it exists.
     */
    where: HistPriceWhereUniqueInput
    /**
     * In case the HistPrice found by the `where` argument doesn't exist, create a new HistPrice with this data.
     */
    create: XOR<HistPriceCreateInput, HistPriceUncheckedCreateInput>
    /**
     * In case the HistPrice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HistPriceUpdateInput, HistPriceUncheckedUpdateInput>
  }

  /**
   * HistPrice delete
   */
  export type HistPriceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistPrice
     */
    select?: HistPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistPrice
     */
    omit?: HistPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistPriceInclude<ExtArgs> | null
    /**
     * Filter which HistPrice to delete.
     */
    where: HistPriceWhereUniqueInput
  }

  /**
   * HistPrice deleteMany
   */
  export type HistPriceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HistPrices to delete
     */
    where?: HistPriceWhereInput
  }

  /**
   * HistPrice without action
   */
  export type HistPriceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistPrice
     */
    select?: HistPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistPrice
     */
    omit?: HistPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistPriceInclude<ExtArgs> | null
  }


  /**
   * Model LimitOrder
   */

  export type AggregateLimitOrder = {
    _count: LimitOrderCountAggregateOutputType | null
    _avg: LimitOrderAvgAggregateOutputType | null
    _sum: LimitOrderSumAggregateOutputType | null
    _min: LimitOrderMinAggregateOutputType | null
    _max: LimitOrderMaxAggregateOutputType | null
  }

  export type LimitOrderAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    stockId: number | null
    quantity: number | null
    limitPrice: Decimal | null
  }

  export type LimitOrderSumAggregateOutputType = {
    id: number | null
    userId: number | null
    stockId: number | null
    quantity: number | null
    limitPrice: Decimal | null
  }

  export type LimitOrderMinAggregateOutputType = {
    id: number | null
    userId: number | null
    stockId: number | null
    quantity: number | null
    limitPrice: Decimal | null
    orderType: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LimitOrderMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    stockId: number | null
    quantity: number | null
    limitPrice: Decimal | null
    orderType: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LimitOrderCountAggregateOutputType = {
    id: number
    userId: number
    stockId: number
    quantity: number
    limitPrice: number
    orderType: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LimitOrderAvgAggregateInputType = {
    id?: true
    userId?: true
    stockId?: true
    quantity?: true
    limitPrice?: true
  }

  export type LimitOrderSumAggregateInputType = {
    id?: true
    userId?: true
    stockId?: true
    quantity?: true
    limitPrice?: true
  }

  export type LimitOrderMinAggregateInputType = {
    id?: true
    userId?: true
    stockId?: true
    quantity?: true
    limitPrice?: true
    orderType?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LimitOrderMaxAggregateInputType = {
    id?: true
    userId?: true
    stockId?: true
    quantity?: true
    limitPrice?: true
    orderType?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LimitOrderCountAggregateInputType = {
    id?: true
    userId?: true
    stockId?: true
    quantity?: true
    limitPrice?: true
    orderType?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LimitOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LimitOrder to aggregate.
     */
    where?: LimitOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LimitOrders to fetch.
     */
    orderBy?: LimitOrderOrderByWithRelationInput | LimitOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LimitOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LimitOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LimitOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LimitOrders
    **/
    _count?: true | LimitOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LimitOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LimitOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LimitOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LimitOrderMaxAggregateInputType
  }

  export type GetLimitOrderAggregateType<T extends LimitOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateLimitOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLimitOrder[P]>
      : GetScalarType<T[P], AggregateLimitOrder[P]>
  }




  export type LimitOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LimitOrderWhereInput
    orderBy?: LimitOrderOrderByWithAggregationInput | LimitOrderOrderByWithAggregationInput[]
    by: LimitOrderScalarFieldEnum[] | LimitOrderScalarFieldEnum
    having?: LimitOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LimitOrderCountAggregateInputType | true
    _avg?: LimitOrderAvgAggregateInputType
    _sum?: LimitOrderSumAggregateInputType
    _min?: LimitOrderMinAggregateInputType
    _max?: LimitOrderMaxAggregateInputType
  }

  export type LimitOrderGroupByOutputType = {
    id: number
    userId: number
    stockId: number
    quantity: number
    limitPrice: Decimal
    orderType: string
    status: string
    createdAt: Date
    updatedAt: Date
    _count: LimitOrderCountAggregateOutputType | null
    _avg: LimitOrderAvgAggregateOutputType | null
    _sum: LimitOrderSumAggregateOutputType | null
    _min: LimitOrderMinAggregateOutputType | null
    _max: LimitOrderMaxAggregateOutputType | null
  }

  type GetLimitOrderGroupByPayload<T extends LimitOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LimitOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LimitOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LimitOrderGroupByOutputType[P]>
            : GetScalarType<T[P], LimitOrderGroupByOutputType[P]>
        }
      >
    >


  export type LimitOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    stockId?: boolean
    quantity?: boolean
    limitPrice?: boolean
    orderType?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stock?: boolean | StockDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["limitOrder"]>

  export type LimitOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    stockId?: boolean
    quantity?: boolean
    limitPrice?: boolean
    orderType?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stock?: boolean | StockDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["limitOrder"]>


  export type LimitOrderSelectScalar = {
    id?: boolean
    userId?: boolean
    stockId?: boolean
    quantity?: boolean
    limitPrice?: boolean
    orderType?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LimitOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "stockId" | "quantity" | "limitPrice" | "orderType" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["limitOrder"]>
  export type LimitOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stock?: boolean | StockDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LimitOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stock?: boolean | StockDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LimitOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LimitOrder"
    objects: {
      stock: Prisma.$StockPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      stockId: number
      quantity: number
      limitPrice: Prisma.Decimal
      orderType: string
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["limitOrder"]>
    composites: {}
  }

  type LimitOrderGetPayload<S extends boolean | null | undefined | LimitOrderDefaultArgs> = $Result.GetResult<Prisma.$LimitOrderPayload, S>

  type LimitOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LimitOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LimitOrderCountAggregateInputType | true
    }

  export interface LimitOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LimitOrder'], meta: { name: 'LimitOrder' } }
    /**
     * Find zero or one LimitOrder that matches the filter.
     * @param {LimitOrderFindUniqueArgs} args - Arguments to find a LimitOrder
     * @example
     * // Get one LimitOrder
     * const limitOrder = await prisma.limitOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LimitOrderFindUniqueArgs>(args: SelectSubset<T, LimitOrderFindUniqueArgs<ExtArgs>>): Prisma__LimitOrderClient<$Result.GetResult<Prisma.$LimitOrderPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one LimitOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LimitOrderFindUniqueOrThrowArgs} args - Arguments to find a LimitOrder
     * @example
     * // Get one LimitOrder
     * const limitOrder = await prisma.limitOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LimitOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, LimitOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LimitOrderClient<$Result.GetResult<Prisma.$LimitOrderPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first LimitOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LimitOrderFindFirstArgs} args - Arguments to find a LimitOrder
     * @example
     * // Get one LimitOrder
     * const limitOrder = await prisma.limitOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LimitOrderFindFirstArgs>(args?: SelectSubset<T, LimitOrderFindFirstArgs<ExtArgs>>): Prisma__LimitOrderClient<$Result.GetResult<Prisma.$LimitOrderPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first LimitOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LimitOrderFindFirstOrThrowArgs} args - Arguments to find a LimitOrder
     * @example
     * // Get one LimitOrder
     * const limitOrder = await prisma.limitOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LimitOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, LimitOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__LimitOrderClient<$Result.GetResult<Prisma.$LimitOrderPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more LimitOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LimitOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LimitOrders
     * const limitOrders = await prisma.limitOrder.findMany()
     * 
     * // Get first 10 LimitOrders
     * const limitOrders = await prisma.limitOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const limitOrderWithIdOnly = await prisma.limitOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LimitOrderFindManyArgs>(args?: SelectSubset<T, LimitOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LimitOrderPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a LimitOrder.
     * @param {LimitOrderCreateArgs} args - Arguments to create a LimitOrder.
     * @example
     * // Create one LimitOrder
     * const LimitOrder = await prisma.limitOrder.create({
     *   data: {
     *     // ... data to create a LimitOrder
     *   }
     * })
     * 
     */
    create<T extends LimitOrderCreateArgs>(args: SelectSubset<T, LimitOrderCreateArgs<ExtArgs>>): Prisma__LimitOrderClient<$Result.GetResult<Prisma.$LimitOrderPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many LimitOrders.
     * @param {LimitOrderCreateManyArgs} args - Arguments to create many LimitOrders.
     * @example
     * // Create many LimitOrders
     * const limitOrder = await prisma.limitOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LimitOrderCreateManyArgs>(args?: SelectSubset<T, LimitOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LimitOrders and returns the data saved in the database.
     * @param {LimitOrderCreateManyAndReturnArgs} args - Arguments to create many LimitOrders.
     * @example
     * // Create many LimitOrders
     * const limitOrder = await prisma.limitOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LimitOrders and only return the `id`
     * const limitOrderWithIdOnly = await prisma.limitOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LimitOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, LimitOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LimitOrderPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a LimitOrder.
     * @param {LimitOrderDeleteArgs} args - Arguments to delete one LimitOrder.
     * @example
     * // Delete one LimitOrder
     * const LimitOrder = await prisma.limitOrder.delete({
     *   where: {
     *     // ... filter to delete one LimitOrder
     *   }
     * })
     * 
     */
    delete<T extends LimitOrderDeleteArgs>(args: SelectSubset<T, LimitOrderDeleteArgs<ExtArgs>>): Prisma__LimitOrderClient<$Result.GetResult<Prisma.$LimitOrderPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one LimitOrder.
     * @param {LimitOrderUpdateArgs} args - Arguments to update one LimitOrder.
     * @example
     * // Update one LimitOrder
     * const limitOrder = await prisma.limitOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LimitOrderUpdateArgs>(args: SelectSubset<T, LimitOrderUpdateArgs<ExtArgs>>): Prisma__LimitOrderClient<$Result.GetResult<Prisma.$LimitOrderPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more LimitOrders.
     * @param {LimitOrderDeleteManyArgs} args - Arguments to filter LimitOrders to delete.
     * @example
     * // Delete a few LimitOrders
     * const { count } = await prisma.limitOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LimitOrderDeleteManyArgs>(args?: SelectSubset<T, LimitOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LimitOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LimitOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LimitOrders
     * const limitOrder = await prisma.limitOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LimitOrderUpdateManyArgs>(args: SelectSubset<T, LimitOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LimitOrder.
     * @param {LimitOrderUpsertArgs} args - Arguments to update or create a LimitOrder.
     * @example
     * // Update or create a LimitOrder
     * const limitOrder = await prisma.limitOrder.upsert({
     *   create: {
     *     // ... data to create a LimitOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LimitOrder we want to update
     *   }
     * })
     */
    upsert<T extends LimitOrderUpsertArgs>(args: SelectSubset<T, LimitOrderUpsertArgs<ExtArgs>>): Prisma__LimitOrderClient<$Result.GetResult<Prisma.$LimitOrderPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of LimitOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LimitOrderCountArgs} args - Arguments to filter LimitOrders to count.
     * @example
     * // Count the number of LimitOrders
     * const count = await prisma.limitOrder.count({
     *   where: {
     *     // ... the filter for the LimitOrders we want to count
     *   }
     * })
    **/
    count<T extends LimitOrderCountArgs>(
      args?: Subset<T, LimitOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LimitOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LimitOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LimitOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LimitOrderAggregateArgs>(args: Subset<T, LimitOrderAggregateArgs>): Prisma.PrismaPromise<GetLimitOrderAggregateType<T>>

    /**
     * Group by LimitOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LimitOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LimitOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LimitOrderGroupByArgs['orderBy'] }
        : { orderBy?: LimitOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LimitOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLimitOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LimitOrder model
   */
  readonly fields: LimitOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LimitOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LimitOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stock<T extends StockDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StockDefaultArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LimitOrder model
   */ 
  interface LimitOrderFieldRefs {
    readonly id: FieldRef<"LimitOrder", 'Int'>
    readonly userId: FieldRef<"LimitOrder", 'Int'>
    readonly stockId: FieldRef<"LimitOrder", 'Int'>
    readonly quantity: FieldRef<"LimitOrder", 'Int'>
    readonly limitPrice: FieldRef<"LimitOrder", 'Decimal'>
    readonly orderType: FieldRef<"LimitOrder", 'String'>
    readonly status: FieldRef<"LimitOrder", 'String'>
    readonly createdAt: FieldRef<"LimitOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"LimitOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LimitOrder findUnique
   */
  export type LimitOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LimitOrder
     */
    select?: LimitOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LimitOrder
     */
    omit?: LimitOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LimitOrderInclude<ExtArgs> | null
    /**
     * Filter, which LimitOrder to fetch.
     */
    where: LimitOrderWhereUniqueInput
  }

  /**
   * LimitOrder findUniqueOrThrow
   */
  export type LimitOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LimitOrder
     */
    select?: LimitOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LimitOrder
     */
    omit?: LimitOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LimitOrderInclude<ExtArgs> | null
    /**
     * Filter, which LimitOrder to fetch.
     */
    where: LimitOrderWhereUniqueInput
  }

  /**
   * LimitOrder findFirst
   */
  export type LimitOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LimitOrder
     */
    select?: LimitOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LimitOrder
     */
    omit?: LimitOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LimitOrderInclude<ExtArgs> | null
    /**
     * Filter, which LimitOrder to fetch.
     */
    where?: LimitOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LimitOrders to fetch.
     */
    orderBy?: LimitOrderOrderByWithRelationInput | LimitOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LimitOrders.
     */
    cursor?: LimitOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LimitOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LimitOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LimitOrders.
     */
    distinct?: LimitOrderScalarFieldEnum | LimitOrderScalarFieldEnum[]
  }

  /**
   * LimitOrder findFirstOrThrow
   */
  export type LimitOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LimitOrder
     */
    select?: LimitOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LimitOrder
     */
    omit?: LimitOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LimitOrderInclude<ExtArgs> | null
    /**
     * Filter, which LimitOrder to fetch.
     */
    where?: LimitOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LimitOrders to fetch.
     */
    orderBy?: LimitOrderOrderByWithRelationInput | LimitOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LimitOrders.
     */
    cursor?: LimitOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LimitOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LimitOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LimitOrders.
     */
    distinct?: LimitOrderScalarFieldEnum | LimitOrderScalarFieldEnum[]
  }

  /**
   * LimitOrder findMany
   */
  export type LimitOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LimitOrder
     */
    select?: LimitOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LimitOrder
     */
    omit?: LimitOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LimitOrderInclude<ExtArgs> | null
    /**
     * Filter, which LimitOrders to fetch.
     */
    where?: LimitOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LimitOrders to fetch.
     */
    orderBy?: LimitOrderOrderByWithRelationInput | LimitOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LimitOrders.
     */
    cursor?: LimitOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LimitOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LimitOrders.
     */
    skip?: number
    distinct?: LimitOrderScalarFieldEnum | LimitOrderScalarFieldEnum[]
  }

  /**
   * LimitOrder create
   */
  export type LimitOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LimitOrder
     */
    select?: LimitOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LimitOrder
     */
    omit?: LimitOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LimitOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a LimitOrder.
     */
    data: XOR<LimitOrderCreateInput, LimitOrderUncheckedCreateInput>
  }

  /**
   * LimitOrder createMany
   */
  export type LimitOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LimitOrders.
     */
    data: LimitOrderCreateManyInput | LimitOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LimitOrder createManyAndReturn
   */
  export type LimitOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LimitOrder
     */
    select?: LimitOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LimitOrder
     */
    omit?: LimitOrderOmit<ExtArgs> | null
    /**
     * The data used to create many LimitOrders.
     */
    data: LimitOrderCreateManyInput | LimitOrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LimitOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LimitOrder update
   */
  export type LimitOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LimitOrder
     */
    select?: LimitOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LimitOrder
     */
    omit?: LimitOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LimitOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a LimitOrder.
     */
    data: XOR<LimitOrderUpdateInput, LimitOrderUncheckedUpdateInput>
    /**
     * Choose, which LimitOrder to update.
     */
    where: LimitOrderWhereUniqueInput
  }

  /**
   * LimitOrder updateMany
   */
  export type LimitOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LimitOrders.
     */
    data: XOR<LimitOrderUpdateManyMutationInput, LimitOrderUncheckedUpdateManyInput>
    /**
     * Filter which LimitOrders to update
     */
    where?: LimitOrderWhereInput
  }

  /**
   * LimitOrder upsert
   */
  export type LimitOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LimitOrder
     */
    select?: LimitOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LimitOrder
     */
    omit?: LimitOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LimitOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the LimitOrder to update in case it exists.
     */
    where: LimitOrderWhereUniqueInput
    /**
     * In case the LimitOrder found by the `where` argument doesn't exist, create a new LimitOrder with this data.
     */
    create: XOR<LimitOrderCreateInput, LimitOrderUncheckedCreateInput>
    /**
     * In case the LimitOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LimitOrderUpdateInput, LimitOrderUncheckedUpdateInput>
  }

  /**
   * LimitOrder delete
   */
  export type LimitOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LimitOrder
     */
    select?: LimitOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LimitOrder
     */
    omit?: LimitOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LimitOrderInclude<ExtArgs> | null
    /**
     * Filter which LimitOrder to delete.
     */
    where: LimitOrderWhereUniqueInput
  }

  /**
   * LimitOrder deleteMany
   */
  export type LimitOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LimitOrders to delete
     */
    where?: LimitOrderWhereInput
  }

  /**
   * LimitOrder without action
   */
  export type LimitOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LimitOrder
     */
    select?: LimitOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LimitOrder
     */
    omit?: LimitOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LimitOrderInclude<ExtArgs> | null
  }


  /**
   * Model Trade
   */

  export type AggregateTrade = {
    _count: TradeCountAggregateOutputType | null
    _avg: TradeAvgAggregateOutputType | null
    _sum: TradeSumAggregateOutputType | null
    _min: TradeMinAggregateOutputType | null
    _max: TradeMaxAggregateOutputType | null
  }

  export type TradeAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    stockId: number | null
    quantity: number | null
    price: Decimal | null
    totalAmount: Decimal | null
  }

  export type TradeSumAggregateOutputType = {
    id: number | null
    userId: number | null
    stockId: number | null
    quantity: number | null
    price: Decimal | null
    totalAmount: Decimal | null
  }

  export type TradeMinAggregateOutputType = {
    id: number | null
    userId: number | null
    stockId: number | null
    quantity: number | null
    price: Decimal | null
    totalAmount: Decimal | null
    tradeType: string | null
    tradeDate: Date | null
  }

  export type TradeMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    stockId: number | null
    quantity: number | null
    price: Decimal | null
    totalAmount: Decimal | null
    tradeType: string | null
    tradeDate: Date | null
  }

  export type TradeCountAggregateOutputType = {
    id: number
    userId: number
    stockId: number
    quantity: number
    price: number
    totalAmount: number
    tradeType: number
    tradeDate: number
    _all: number
  }


  export type TradeAvgAggregateInputType = {
    id?: true
    userId?: true
    stockId?: true
    quantity?: true
    price?: true
    totalAmount?: true
  }

  export type TradeSumAggregateInputType = {
    id?: true
    userId?: true
    stockId?: true
    quantity?: true
    price?: true
    totalAmount?: true
  }

  export type TradeMinAggregateInputType = {
    id?: true
    userId?: true
    stockId?: true
    quantity?: true
    price?: true
    totalAmount?: true
    tradeType?: true
    tradeDate?: true
  }

  export type TradeMaxAggregateInputType = {
    id?: true
    userId?: true
    stockId?: true
    quantity?: true
    price?: true
    totalAmount?: true
    tradeType?: true
    tradeDate?: true
  }

  export type TradeCountAggregateInputType = {
    id?: true
    userId?: true
    stockId?: true
    quantity?: true
    price?: true
    totalAmount?: true
    tradeType?: true
    tradeDate?: true
    _all?: true
  }

  export type TradeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trade to aggregate.
     */
    where?: TradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trades to fetch.
     */
    orderBy?: TradeOrderByWithRelationInput | TradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Trades
    **/
    _count?: true | TradeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TradeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TradeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TradeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TradeMaxAggregateInputType
  }

  export type GetTradeAggregateType<T extends TradeAggregateArgs> = {
        [P in keyof T & keyof AggregateTrade]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrade[P]>
      : GetScalarType<T[P], AggregateTrade[P]>
  }




  export type TradeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TradeWhereInput
    orderBy?: TradeOrderByWithAggregationInput | TradeOrderByWithAggregationInput[]
    by: TradeScalarFieldEnum[] | TradeScalarFieldEnum
    having?: TradeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TradeCountAggregateInputType | true
    _avg?: TradeAvgAggregateInputType
    _sum?: TradeSumAggregateInputType
    _min?: TradeMinAggregateInputType
    _max?: TradeMaxAggregateInputType
  }

  export type TradeGroupByOutputType = {
    id: number
    userId: number | null
    stockId: number
    quantity: number
    price: Decimal
    totalAmount: Decimal
    tradeType: string
    tradeDate: Date
    _count: TradeCountAggregateOutputType | null
    _avg: TradeAvgAggregateOutputType | null
    _sum: TradeSumAggregateOutputType | null
    _min: TradeMinAggregateOutputType | null
    _max: TradeMaxAggregateOutputType | null
  }

  type GetTradeGroupByPayload<T extends TradeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TradeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TradeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TradeGroupByOutputType[P]>
            : GetScalarType<T[P], TradeGroupByOutputType[P]>
        }
      >
    >


  export type TradeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    stockId?: boolean
    quantity?: boolean
    price?: boolean
    totalAmount?: boolean
    tradeType?: boolean
    tradeDate?: boolean
    stock?: boolean | StockDefaultArgs<ExtArgs>
    user?: boolean | Trade$userArgs<ExtArgs>
  }, ExtArgs["result"]["trade"]>

  export type TradeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    stockId?: boolean
    quantity?: boolean
    price?: boolean
    totalAmount?: boolean
    tradeType?: boolean
    tradeDate?: boolean
    stock?: boolean | StockDefaultArgs<ExtArgs>
    user?: boolean | Trade$userArgs<ExtArgs>
  }, ExtArgs["result"]["trade"]>


  export type TradeSelectScalar = {
    id?: boolean
    userId?: boolean
    stockId?: boolean
    quantity?: boolean
    price?: boolean
    totalAmount?: boolean
    tradeType?: boolean
    tradeDate?: boolean
  }

  export type TradeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "stockId" | "quantity" | "price" | "totalAmount" | "tradeType" | "tradeDate", ExtArgs["result"]["trade"]>
  export type TradeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stock?: boolean | StockDefaultArgs<ExtArgs>
    user?: boolean | Trade$userArgs<ExtArgs>
  }
  export type TradeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stock?: boolean | StockDefaultArgs<ExtArgs>
    user?: boolean | Trade$userArgs<ExtArgs>
  }

  export type $TradePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Trade"
    objects: {
      stock: Prisma.$StockPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
      stockId: number
      quantity: number
      price: Prisma.Decimal
      totalAmount: Prisma.Decimal
      tradeType: string
      tradeDate: Date
    }, ExtArgs["result"]["trade"]>
    composites: {}
  }

  type TradeGetPayload<S extends boolean | null | undefined | TradeDefaultArgs> = $Result.GetResult<Prisma.$TradePayload, S>

  type TradeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TradeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TradeCountAggregateInputType | true
    }

  export interface TradeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Trade'], meta: { name: 'Trade' } }
    /**
     * Find zero or one Trade that matches the filter.
     * @param {TradeFindUniqueArgs} args - Arguments to find a Trade
     * @example
     * // Get one Trade
     * const trade = await prisma.trade.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TradeFindUniqueArgs>(args: SelectSubset<T, TradeFindUniqueArgs<ExtArgs>>): Prisma__TradeClient<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Trade that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TradeFindUniqueOrThrowArgs} args - Arguments to find a Trade
     * @example
     * // Get one Trade
     * const trade = await prisma.trade.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TradeFindUniqueOrThrowArgs>(args: SelectSubset<T, TradeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TradeClient<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Trade that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeFindFirstArgs} args - Arguments to find a Trade
     * @example
     * // Get one Trade
     * const trade = await prisma.trade.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TradeFindFirstArgs>(args?: SelectSubset<T, TradeFindFirstArgs<ExtArgs>>): Prisma__TradeClient<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Trade that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeFindFirstOrThrowArgs} args - Arguments to find a Trade
     * @example
     * // Get one Trade
     * const trade = await prisma.trade.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TradeFindFirstOrThrowArgs>(args?: SelectSubset<T, TradeFindFirstOrThrowArgs<ExtArgs>>): Prisma__TradeClient<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Trades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trades
     * const trades = await prisma.trade.findMany()
     * 
     * // Get first 10 Trades
     * const trades = await prisma.trade.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tradeWithIdOnly = await prisma.trade.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TradeFindManyArgs>(args?: SelectSubset<T, TradeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Trade.
     * @param {TradeCreateArgs} args - Arguments to create a Trade.
     * @example
     * // Create one Trade
     * const Trade = await prisma.trade.create({
     *   data: {
     *     // ... data to create a Trade
     *   }
     * })
     * 
     */
    create<T extends TradeCreateArgs>(args: SelectSubset<T, TradeCreateArgs<ExtArgs>>): Prisma__TradeClient<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Trades.
     * @param {TradeCreateManyArgs} args - Arguments to create many Trades.
     * @example
     * // Create many Trades
     * const trade = await prisma.trade.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TradeCreateManyArgs>(args?: SelectSubset<T, TradeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Trades and returns the data saved in the database.
     * @param {TradeCreateManyAndReturnArgs} args - Arguments to create many Trades.
     * @example
     * // Create many Trades
     * const trade = await prisma.trade.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Trades and only return the `id`
     * const tradeWithIdOnly = await prisma.trade.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TradeCreateManyAndReturnArgs>(args?: SelectSubset<T, TradeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Trade.
     * @param {TradeDeleteArgs} args - Arguments to delete one Trade.
     * @example
     * // Delete one Trade
     * const Trade = await prisma.trade.delete({
     *   where: {
     *     // ... filter to delete one Trade
     *   }
     * })
     * 
     */
    delete<T extends TradeDeleteArgs>(args: SelectSubset<T, TradeDeleteArgs<ExtArgs>>): Prisma__TradeClient<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Trade.
     * @param {TradeUpdateArgs} args - Arguments to update one Trade.
     * @example
     * // Update one Trade
     * const trade = await prisma.trade.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TradeUpdateArgs>(args: SelectSubset<T, TradeUpdateArgs<ExtArgs>>): Prisma__TradeClient<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Trades.
     * @param {TradeDeleteManyArgs} args - Arguments to filter Trades to delete.
     * @example
     * // Delete a few Trades
     * const { count } = await prisma.trade.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TradeDeleteManyArgs>(args?: SelectSubset<T, TradeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trades
     * const trade = await prisma.trade.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TradeUpdateManyArgs>(args: SelectSubset<T, TradeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Trade.
     * @param {TradeUpsertArgs} args - Arguments to update or create a Trade.
     * @example
     * // Update or create a Trade
     * const trade = await prisma.trade.upsert({
     *   create: {
     *     // ... data to create a Trade
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trade we want to update
     *   }
     * })
     */
    upsert<T extends TradeUpsertArgs>(args: SelectSubset<T, TradeUpsertArgs<ExtArgs>>): Prisma__TradeClient<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Trades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeCountArgs} args - Arguments to filter Trades to count.
     * @example
     * // Count the number of Trades
     * const count = await prisma.trade.count({
     *   where: {
     *     // ... the filter for the Trades we want to count
     *   }
     * })
    **/
    count<T extends TradeCountArgs>(
      args?: Subset<T, TradeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TradeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TradeAggregateArgs>(args: Subset<T, TradeAggregateArgs>): Prisma.PrismaPromise<GetTradeAggregateType<T>>

    /**
     * Group by Trade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TradeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TradeGroupByArgs['orderBy'] }
        : { orderBy?: TradeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TradeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTradeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Trade model
   */
  readonly fields: TradeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Trade.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TradeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stock<T extends StockDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StockDefaultArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    user<T extends Trade$userArgs<ExtArgs> = {}>(args?: Subset<T, Trade$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Trade model
   */ 
  interface TradeFieldRefs {
    readonly id: FieldRef<"Trade", 'Int'>
    readonly userId: FieldRef<"Trade", 'Int'>
    readonly stockId: FieldRef<"Trade", 'Int'>
    readonly quantity: FieldRef<"Trade", 'Int'>
    readonly price: FieldRef<"Trade", 'Decimal'>
    readonly totalAmount: FieldRef<"Trade", 'Decimal'>
    readonly tradeType: FieldRef<"Trade", 'String'>
    readonly tradeDate: FieldRef<"Trade", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Trade findUnique
   */
  export type TradeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trade
     */
    omit?: TradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    /**
     * Filter, which Trade to fetch.
     */
    where: TradeWhereUniqueInput
  }

  /**
   * Trade findUniqueOrThrow
   */
  export type TradeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trade
     */
    omit?: TradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    /**
     * Filter, which Trade to fetch.
     */
    where: TradeWhereUniqueInput
  }

  /**
   * Trade findFirst
   */
  export type TradeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trade
     */
    omit?: TradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    /**
     * Filter, which Trade to fetch.
     */
    where?: TradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trades to fetch.
     */
    orderBy?: TradeOrderByWithRelationInput | TradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trades.
     */
    cursor?: TradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trades.
     */
    distinct?: TradeScalarFieldEnum | TradeScalarFieldEnum[]
  }

  /**
   * Trade findFirstOrThrow
   */
  export type TradeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trade
     */
    omit?: TradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    /**
     * Filter, which Trade to fetch.
     */
    where?: TradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trades to fetch.
     */
    orderBy?: TradeOrderByWithRelationInput | TradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trades.
     */
    cursor?: TradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trades.
     */
    distinct?: TradeScalarFieldEnum | TradeScalarFieldEnum[]
  }

  /**
   * Trade findMany
   */
  export type TradeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trade
     */
    omit?: TradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    /**
     * Filter, which Trades to fetch.
     */
    where?: TradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trades to fetch.
     */
    orderBy?: TradeOrderByWithRelationInput | TradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Trades.
     */
    cursor?: TradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trades.
     */
    skip?: number
    distinct?: TradeScalarFieldEnum | TradeScalarFieldEnum[]
  }

  /**
   * Trade create
   */
  export type TradeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trade
     */
    omit?: TradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    /**
     * The data needed to create a Trade.
     */
    data: XOR<TradeCreateInput, TradeUncheckedCreateInput>
  }

  /**
   * Trade createMany
   */
  export type TradeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Trades.
     */
    data: TradeCreateManyInput | TradeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Trade createManyAndReturn
   */
  export type TradeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Trade
     */
    omit?: TradeOmit<ExtArgs> | null
    /**
     * The data used to create many Trades.
     */
    data: TradeCreateManyInput | TradeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Trade update
   */
  export type TradeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trade
     */
    omit?: TradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    /**
     * The data needed to update a Trade.
     */
    data: XOR<TradeUpdateInput, TradeUncheckedUpdateInput>
    /**
     * Choose, which Trade to update.
     */
    where: TradeWhereUniqueInput
  }

  /**
   * Trade updateMany
   */
  export type TradeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Trades.
     */
    data: XOR<TradeUpdateManyMutationInput, TradeUncheckedUpdateManyInput>
    /**
     * Filter which Trades to update
     */
    where?: TradeWhereInput
  }

  /**
   * Trade upsert
   */
  export type TradeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trade
     */
    omit?: TradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    /**
     * The filter to search for the Trade to update in case it exists.
     */
    where: TradeWhereUniqueInput
    /**
     * In case the Trade found by the `where` argument doesn't exist, create a new Trade with this data.
     */
    create: XOR<TradeCreateInput, TradeUncheckedCreateInput>
    /**
     * In case the Trade was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TradeUpdateInput, TradeUncheckedUpdateInput>
  }

  /**
   * Trade delete
   */
  export type TradeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trade
     */
    omit?: TradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    /**
     * Filter which Trade to delete.
     */
    where: TradeWhereUniqueInput
  }

  /**
   * Trade deleteMany
   */
  export type TradeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trades to delete
     */
    where?: TradeWhereInput
  }

  /**
   * Trade.user
   */
  export type Trade$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Trade without action
   */
  export type TradeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trade
     */
    omit?: TradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
  }


  /**
   * Model News
   */

  export type AggregateNews = {
    _count: NewsCountAggregateOutputType | null
    _avg: NewsAvgAggregateOutputType | null
    _sum: NewsSumAggregateOutputType | null
    _min: NewsMinAggregateOutputType | null
    _max: NewsMaxAggregateOutputType | null
  }

  export type NewsAvgAggregateOutputType = {
    news_id: number | null
  }

  export type NewsSumAggregateOutputType = {
    news_id: number | null
  }

  export type NewsMinAggregateOutputType = {
    news_id: number | null
    image_url: string | null
    title: string | null
    caption: string | null
    content: string | null
    category: string | null
  }

  export type NewsMaxAggregateOutputType = {
    news_id: number | null
    image_url: string | null
    title: string | null
    caption: string | null
    content: string | null
    category: string | null
  }

  export type NewsCountAggregateOutputType = {
    news_id: number
    image_url: number
    title: number
    caption: number
    content: number
    category: number
    tags: number
    _all: number
  }


  export type NewsAvgAggregateInputType = {
    news_id?: true
  }

  export type NewsSumAggregateInputType = {
    news_id?: true
  }

  export type NewsMinAggregateInputType = {
    news_id?: true
    image_url?: true
    title?: true
    caption?: true
    content?: true
    category?: true
  }

  export type NewsMaxAggregateInputType = {
    news_id?: true
    image_url?: true
    title?: true
    caption?: true
    content?: true
    category?: true
  }

  export type NewsCountAggregateInputType = {
    news_id?: true
    image_url?: true
    title?: true
    caption?: true
    content?: true
    category?: true
    tags?: true
    _all?: true
  }

  export type NewsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which News to aggregate.
     */
    where?: NewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of News to fetch.
     */
    orderBy?: NewsOrderByWithRelationInput | NewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned News
    **/
    _count?: true | NewsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NewsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NewsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsMaxAggregateInputType
  }

  export type GetNewsAggregateType<T extends NewsAggregateArgs> = {
        [P in keyof T & keyof AggregateNews]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNews[P]>
      : GetScalarType<T[P], AggregateNews[P]>
  }




  export type NewsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsWhereInput
    orderBy?: NewsOrderByWithAggregationInput | NewsOrderByWithAggregationInput[]
    by: NewsScalarFieldEnum[] | NewsScalarFieldEnum
    having?: NewsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsCountAggregateInputType | true
    _avg?: NewsAvgAggregateInputType
    _sum?: NewsSumAggregateInputType
    _min?: NewsMinAggregateInputType
    _max?: NewsMaxAggregateInputType
  }

  export type NewsGroupByOutputType = {
    news_id: number
    image_url: string
    title: string
    caption: string
    content: string
    category: string
    tags: string[]
    _count: NewsCountAggregateOutputType | null
    _avg: NewsAvgAggregateOutputType | null
    _sum: NewsSumAggregateOutputType | null
    _min: NewsMinAggregateOutputType | null
    _max: NewsMaxAggregateOutputType | null
  }

  type GetNewsGroupByPayload<T extends NewsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsGroupByOutputType[P]>
            : GetScalarType<T[P], NewsGroupByOutputType[P]>
        }
      >
    >


  export type NewsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    news_id?: boolean
    image_url?: boolean
    title?: boolean
    caption?: boolean
    content?: boolean
    category?: boolean
    tags?: boolean
  }, ExtArgs["result"]["news"]>

  export type NewsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    news_id?: boolean
    image_url?: boolean
    title?: boolean
    caption?: boolean
    content?: boolean
    category?: boolean
    tags?: boolean
  }, ExtArgs["result"]["news"]>


  export type NewsSelectScalar = {
    news_id?: boolean
    image_url?: boolean
    title?: boolean
    caption?: boolean
    content?: boolean
    category?: boolean
    tags?: boolean
  }

  export type NewsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"news_id" | "image_url" | "title" | "caption" | "content" | "category" | "tags", ExtArgs["result"]["news"]>

  export type $NewsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "News"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      news_id: number
      image_url: string
      title: string
      caption: string
      content: string
      category: string
      tags: string[]
    }, ExtArgs["result"]["news"]>
    composites: {}
  }

  type NewsGetPayload<S extends boolean | null | undefined | NewsDefaultArgs> = $Result.GetResult<Prisma.$NewsPayload, S>

  type NewsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NewsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NewsCountAggregateInputType | true
    }

  export interface NewsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['News'], meta: { name: 'News' } }
    /**
     * Find zero or one News that matches the filter.
     * @param {NewsFindUniqueArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NewsFindUniqueArgs>(args: SelectSubset<T, NewsFindUniqueArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one News that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NewsFindUniqueOrThrowArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NewsFindUniqueOrThrowArgs>(args: SelectSubset<T, NewsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first News that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsFindFirstArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NewsFindFirstArgs>(args?: SelectSubset<T, NewsFindFirstArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first News that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsFindFirstOrThrowArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NewsFindFirstOrThrowArgs>(args?: SelectSubset<T, NewsFindFirstOrThrowArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more News that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all News
     * const news = await prisma.news.findMany()
     * 
     * // Get first 10 News
     * const news = await prisma.news.findMany({ take: 10 })
     * 
     * // Only select the `news_id`
     * const newsWithNews_idOnly = await prisma.news.findMany({ select: { news_id: true } })
     * 
     */
    findMany<T extends NewsFindManyArgs>(args?: SelectSubset<T, NewsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a News.
     * @param {NewsCreateArgs} args - Arguments to create a News.
     * @example
     * // Create one News
     * const News = await prisma.news.create({
     *   data: {
     *     // ... data to create a News
     *   }
     * })
     * 
     */
    create<T extends NewsCreateArgs>(args: SelectSubset<T, NewsCreateArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many News.
     * @param {NewsCreateManyArgs} args - Arguments to create many News.
     * @example
     * // Create many News
     * const news = await prisma.news.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NewsCreateManyArgs>(args?: SelectSubset<T, NewsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many News and returns the data saved in the database.
     * @param {NewsCreateManyAndReturnArgs} args - Arguments to create many News.
     * @example
     * // Create many News
     * const news = await prisma.news.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many News and only return the `news_id`
     * const newsWithNews_idOnly = await prisma.news.createManyAndReturn({
     *   select: { news_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NewsCreateManyAndReturnArgs>(args?: SelectSubset<T, NewsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a News.
     * @param {NewsDeleteArgs} args - Arguments to delete one News.
     * @example
     * // Delete one News
     * const News = await prisma.news.delete({
     *   where: {
     *     // ... filter to delete one News
     *   }
     * })
     * 
     */
    delete<T extends NewsDeleteArgs>(args: SelectSubset<T, NewsDeleteArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one News.
     * @param {NewsUpdateArgs} args - Arguments to update one News.
     * @example
     * // Update one News
     * const news = await prisma.news.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NewsUpdateArgs>(args: SelectSubset<T, NewsUpdateArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more News.
     * @param {NewsDeleteManyArgs} args - Arguments to filter News to delete.
     * @example
     * // Delete a few News
     * const { count } = await prisma.news.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NewsDeleteManyArgs>(args?: SelectSubset<T, NewsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many News
     * const news = await prisma.news.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NewsUpdateManyArgs>(args: SelectSubset<T, NewsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one News.
     * @param {NewsUpsertArgs} args - Arguments to update or create a News.
     * @example
     * // Update or create a News
     * const news = await prisma.news.upsert({
     *   create: {
     *     // ... data to create a News
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the News we want to update
     *   }
     * })
     */
    upsert<T extends NewsUpsertArgs>(args: SelectSubset<T, NewsUpsertArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsCountArgs} args - Arguments to filter News to count.
     * @example
     * // Count the number of News
     * const count = await prisma.news.count({
     *   where: {
     *     // ... the filter for the News we want to count
     *   }
     * })
    **/
    count<T extends NewsCountArgs>(
      args?: Subset<T, NewsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsAggregateArgs>(args: Subset<T, NewsAggregateArgs>): Prisma.PrismaPromise<GetNewsAggregateType<T>>

    /**
     * Group by News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewsGroupByArgs['orderBy'] }
        : { orderBy?: NewsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the News model
   */
  readonly fields: NewsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for News.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NewsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the News model
   */ 
  interface NewsFieldRefs {
    readonly news_id: FieldRef<"News", 'Int'>
    readonly image_url: FieldRef<"News", 'String'>
    readonly title: FieldRef<"News", 'String'>
    readonly caption: FieldRef<"News", 'String'>
    readonly content: FieldRef<"News", 'String'>
    readonly category: FieldRef<"News", 'String'>
    readonly tags: FieldRef<"News", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * News findUnique
   */
  export type NewsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where: NewsWhereUniqueInput
  }

  /**
   * News findUniqueOrThrow
   */
  export type NewsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where: NewsWhereUniqueInput
  }

  /**
   * News findFirst
   */
  export type NewsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where?: NewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of News to fetch.
     */
    orderBy?: NewsOrderByWithRelationInput | NewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for News.
     */
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of News.
     */
    distinct?: NewsScalarFieldEnum | NewsScalarFieldEnum[]
  }

  /**
   * News findFirstOrThrow
   */
  export type NewsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where?: NewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of News to fetch.
     */
    orderBy?: NewsOrderByWithRelationInput | NewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for News.
     */
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of News.
     */
    distinct?: NewsScalarFieldEnum | NewsScalarFieldEnum[]
  }

  /**
   * News findMany
   */
  export type NewsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where?: NewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of News to fetch.
     */
    orderBy?: NewsOrderByWithRelationInput | NewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing News.
     */
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
     */
    skip?: number
    distinct?: NewsScalarFieldEnum | NewsScalarFieldEnum[]
  }

  /**
   * News create
   */
  export type NewsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * The data needed to create a News.
     */
    data: XOR<NewsCreateInput, NewsUncheckedCreateInput>
  }

  /**
   * News createMany
   */
  export type NewsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many News.
     */
    data: NewsCreateManyInput | NewsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * News createManyAndReturn
   */
  export type NewsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * The data used to create many News.
     */
    data: NewsCreateManyInput | NewsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * News update
   */
  export type NewsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * The data needed to update a News.
     */
    data: XOR<NewsUpdateInput, NewsUncheckedUpdateInput>
    /**
     * Choose, which News to update.
     */
    where: NewsWhereUniqueInput
  }

  /**
   * News updateMany
   */
  export type NewsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update News.
     */
    data: XOR<NewsUpdateManyMutationInput, NewsUncheckedUpdateManyInput>
    /**
     * Filter which News to update
     */
    where?: NewsWhereInput
  }

  /**
   * News upsert
   */
  export type NewsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * The filter to search for the News to update in case it exists.
     */
    where: NewsWhereUniqueInput
    /**
     * In case the News found by the `where` argument doesn't exist, create a new News with this data.
     */
    create: XOR<NewsCreateInput, NewsUncheckedCreateInput>
    /**
     * In case the News was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NewsUpdateInput, NewsUncheckedUpdateInput>
  }

  /**
   * News delete
   */
  export type NewsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Filter which News to delete.
     */
    where: NewsWhereUniqueInput
  }

  /**
   * News deleteMany
   */
  export type NewsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which News to delete
     */
    where?: NewsWhereInput
  }

  /**
   * News without action
   */
  export type NewsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
  }


  /**
   * Model BlogPost
   */

  export type AggregateBlogPost = {
    _count: BlogPostCountAggregateOutputType | null
    _avg: BlogPostAvgAggregateOutputType | null
    _sum: BlogPostSumAggregateOutputType | null
    _min: BlogPostMinAggregateOutputType | null
    _max: BlogPostMaxAggregateOutputType | null
  }

  export type BlogPostAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type BlogPostSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type BlogPostMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    title: string | null
    content: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type BlogPostMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    title: string | null
    content: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type BlogPostCountAggregateOutputType = {
    id: number
    user_id: number
    title: number
    content: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type BlogPostAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type BlogPostSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type BlogPostMinAggregateInputType = {
    id?: true
    user_id?: true
    title?: true
    content?: true
    created_at?: true
    updated_at?: true
  }

  export type BlogPostMaxAggregateInputType = {
    id?: true
    user_id?: true
    title?: true
    content?: true
    created_at?: true
    updated_at?: true
  }

  export type BlogPostCountAggregateInputType = {
    id?: true
    user_id?: true
    title?: true
    content?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type BlogPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPost to aggregate.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlogPosts
    **/
    _count?: true | BlogPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlogPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlogPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogPostMaxAggregateInputType
  }

  export type GetBlogPostAggregateType<T extends BlogPostAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogPost[P]>
      : GetScalarType<T[P], AggregateBlogPost[P]>
  }




  export type BlogPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostWhereInput
    orderBy?: BlogPostOrderByWithAggregationInput | BlogPostOrderByWithAggregationInput[]
    by: BlogPostScalarFieldEnum[] | BlogPostScalarFieldEnum
    having?: BlogPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogPostCountAggregateInputType | true
    _avg?: BlogPostAvgAggregateInputType
    _sum?: BlogPostSumAggregateInputType
    _min?: BlogPostMinAggregateInputType
    _max?: BlogPostMaxAggregateInputType
  }

  export type BlogPostGroupByOutputType = {
    id: number
    user_id: number
    title: string
    content: string
    created_at: Date
    updated_at: Date
    _count: BlogPostCountAggregateOutputType | null
    _avg: BlogPostAvgAggregateOutputType | null
    _sum: BlogPostSumAggregateOutputType | null
    _min: BlogPostMinAggregateOutputType | null
    _max: BlogPostMaxAggregateOutputType | null
  }

  type GetBlogPostGroupByPayload<T extends BlogPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogPostGroupByOutputType[P]>
            : GetScalarType<T[P], BlogPostGroupByOutputType[P]>
        }
      >
    >


  export type BlogPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    title?: boolean
    content?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    BlogComment?: boolean | BlogPost$BlogCommentArgs<ExtArgs>
    _count?: boolean | BlogPostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogPost"]>

  export type BlogPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    title?: boolean
    content?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogPost"]>


  export type BlogPostSelectScalar = {
    id?: boolean
    user_id?: boolean
    title?: boolean
    content?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type BlogPostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "title" | "content" | "created_at" | "updated_at", ExtArgs["result"]["blogPost"]>
  export type BlogPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    BlogComment?: boolean | BlogPost$BlogCommentArgs<ExtArgs>
    _count?: boolean | BlogPostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BlogPostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BlogPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlogPost"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      BlogComment: Prisma.$BlogCommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      title: string
      content: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["blogPost"]>
    composites: {}
  }

  type BlogPostGetPayload<S extends boolean | null | undefined | BlogPostDefaultArgs> = $Result.GetResult<Prisma.$BlogPostPayload, S>

  type BlogPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlogPostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlogPostCountAggregateInputType | true
    }

  export interface BlogPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlogPost'], meta: { name: 'BlogPost' } }
    /**
     * Find zero or one BlogPost that matches the filter.
     * @param {BlogPostFindUniqueArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlogPostFindUniqueArgs>(args: SelectSubset<T, BlogPostFindUniqueArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one BlogPost that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlogPostFindUniqueOrThrowArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlogPostFindUniqueOrThrowArgs>(args: SelectSubset<T, BlogPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first BlogPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindFirstArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlogPostFindFirstArgs>(args?: SelectSubset<T, BlogPostFindFirstArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first BlogPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindFirstOrThrowArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlogPostFindFirstOrThrowArgs>(args?: SelectSubset<T, BlogPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more BlogPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlogPosts
     * const blogPosts = await prisma.blogPost.findMany()
     * 
     * // Get first 10 BlogPosts
     * const blogPosts = await prisma.blogPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogPostWithIdOnly = await prisma.blogPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlogPostFindManyArgs>(args?: SelectSubset<T, BlogPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a BlogPost.
     * @param {BlogPostCreateArgs} args - Arguments to create a BlogPost.
     * @example
     * // Create one BlogPost
     * const BlogPost = await prisma.blogPost.create({
     *   data: {
     *     // ... data to create a BlogPost
     *   }
     * })
     * 
     */
    create<T extends BlogPostCreateArgs>(args: SelectSubset<T, BlogPostCreateArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many BlogPosts.
     * @param {BlogPostCreateManyArgs} args - Arguments to create many BlogPosts.
     * @example
     * // Create many BlogPosts
     * const blogPost = await prisma.blogPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlogPostCreateManyArgs>(args?: SelectSubset<T, BlogPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlogPosts and returns the data saved in the database.
     * @param {BlogPostCreateManyAndReturnArgs} args - Arguments to create many BlogPosts.
     * @example
     * // Create many BlogPosts
     * const blogPost = await prisma.blogPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlogPosts and only return the `id`
     * const blogPostWithIdOnly = await prisma.blogPost.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlogPostCreateManyAndReturnArgs>(args?: SelectSubset<T, BlogPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a BlogPost.
     * @param {BlogPostDeleteArgs} args - Arguments to delete one BlogPost.
     * @example
     * // Delete one BlogPost
     * const BlogPost = await prisma.blogPost.delete({
     *   where: {
     *     // ... filter to delete one BlogPost
     *   }
     * })
     * 
     */
    delete<T extends BlogPostDeleteArgs>(args: SelectSubset<T, BlogPostDeleteArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one BlogPost.
     * @param {BlogPostUpdateArgs} args - Arguments to update one BlogPost.
     * @example
     * // Update one BlogPost
     * const blogPost = await prisma.blogPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlogPostUpdateArgs>(args: SelectSubset<T, BlogPostUpdateArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more BlogPosts.
     * @param {BlogPostDeleteManyArgs} args - Arguments to filter BlogPosts to delete.
     * @example
     * // Delete a few BlogPosts
     * const { count } = await prisma.blogPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlogPostDeleteManyArgs>(args?: SelectSubset<T, BlogPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlogPosts
     * const blogPost = await prisma.blogPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlogPostUpdateManyArgs>(args: SelectSubset<T, BlogPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BlogPost.
     * @param {BlogPostUpsertArgs} args - Arguments to update or create a BlogPost.
     * @example
     * // Update or create a BlogPost
     * const blogPost = await prisma.blogPost.upsert({
     *   create: {
     *     // ... data to create a BlogPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlogPost we want to update
     *   }
     * })
     */
    upsert<T extends BlogPostUpsertArgs>(args: SelectSubset<T, BlogPostUpsertArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of BlogPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostCountArgs} args - Arguments to filter BlogPosts to count.
     * @example
     * // Count the number of BlogPosts
     * const count = await prisma.blogPost.count({
     *   where: {
     *     // ... the filter for the BlogPosts we want to count
     *   }
     * })
    **/
    count<T extends BlogPostCountArgs>(
      args?: Subset<T, BlogPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlogPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogPostAggregateArgs>(args: Subset<T, BlogPostAggregateArgs>): Prisma.PrismaPromise<GetBlogPostAggregateType<T>>

    /**
     * Group by BlogPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogPostGroupByArgs['orderBy'] }
        : { orderBy?: BlogPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlogPost model
   */
  readonly fields: BlogPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlogPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    BlogComment<T extends BlogPost$BlogCommentArgs<ExtArgs> = {}>(args?: Subset<T, BlogPost$BlogCommentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogCommentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlogPost model
   */ 
  interface BlogPostFieldRefs {
    readonly id: FieldRef<"BlogPost", 'Int'>
    readonly user_id: FieldRef<"BlogPost", 'Int'>
    readonly title: FieldRef<"BlogPost", 'String'>
    readonly content: FieldRef<"BlogPost", 'String'>
    readonly created_at: FieldRef<"BlogPost", 'DateTime'>
    readonly updated_at: FieldRef<"BlogPost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlogPost findUnique
   */
  export type BlogPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost findUniqueOrThrow
   */
  export type BlogPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost findFirst
   */
  export type BlogPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPosts.
     */
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost findFirstOrThrow
   */
  export type BlogPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPosts.
     */
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost findMany
   */
  export type BlogPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPosts to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost create
   */
  export type BlogPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The data needed to create a BlogPost.
     */
    data: XOR<BlogPostCreateInput, BlogPostUncheckedCreateInput>
  }

  /**
   * BlogPost createMany
   */
  export type BlogPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlogPosts.
     */
    data: BlogPostCreateManyInput | BlogPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogPost createManyAndReturn
   */
  export type BlogPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * The data used to create many BlogPosts.
     */
    data: BlogPostCreateManyInput | BlogPostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlogPost update
   */
  export type BlogPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The data needed to update a BlogPost.
     */
    data: XOR<BlogPostUpdateInput, BlogPostUncheckedUpdateInput>
    /**
     * Choose, which BlogPost to update.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost updateMany
   */
  export type BlogPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlogPosts.
     */
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyInput>
    /**
     * Filter which BlogPosts to update
     */
    where?: BlogPostWhereInput
  }

  /**
   * BlogPost upsert
   */
  export type BlogPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The filter to search for the BlogPost to update in case it exists.
     */
    where: BlogPostWhereUniqueInput
    /**
     * In case the BlogPost found by the `where` argument doesn't exist, create a new BlogPost with this data.
     */
    create: XOR<BlogPostCreateInput, BlogPostUncheckedCreateInput>
    /**
     * In case the BlogPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogPostUpdateInput, BlogPostUncheckedUpdateInput>
  }

  /**
   * BlogPost delete
   */
  export type BlogPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter which BlogPost to delete.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost deleteMany
   */
  export type BlogPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPosts to delete
     */
    where?: BlogPostWhereInput
  }

  /**
   * BlogPost.BlogComment
   */
  export type BlogPost$BlogCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogComment
     */
    omit?: BlogCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentInclude<ExtArgs> | null
    where?: BlogCommentWhereInput
    orderBy?: BlogCommentOrderByWithRelationInput | BlogCommentOrderByWithRelationInput[]
    cursor?: BlogCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogCommentScalarFieldEnum | BlogCommentScalarFieldEnum[]
  }

  /**
   * BlogPost without action
   */
  export type BlogPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
  }


  /**
   * Model BlogComment
   */

  export type AggregateBlogComment = {
    _count: BlogCommentCountAggregateOutputType | null
    _avg: BlogCommentAvgAggregateOutputType | null
    _sum: BlogCommentSumAggregateOutputType | null
    _min: BlogCommentMinAggregateOutputType | null
    _max: BlogCommentMaxAggregateOutputType | null
  }

  export type BlogCommentAvgAggregateOutputType = {
    id: number | null
    post_id: number | null
    user_id: number | null
  }

  export type BlogCommentSumAggregateOutputType = {
    id: number | null
    post_id: number | null
    user_id: number | null
  }

  export type BlogCommentMinAggregateOutputType = {
    id: number | null
    post_id: number | null
    user_id: number | null
    comment: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type BlogCommentMaxAggregateOutputType = {
    id: number | null
    post_id: number | null
    user_id: number | null
    comment: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type BlogCommentCountAggregateOutputType = {
    id: number
    post_id: number
    user_id: number
    comment: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type BlogCommentAvgAggregateInputType = {
    id?: true
    post_id?: true
    user_id?: true
  }

  export type BlogCommentSumAggregateInputType = {
    id?: true
    post_id?: true
    user_id?: true
  }

  export type BlogCommentMinAggregateInputType = {
    id?: true
    post_id?: true
    user_id?: true
    comment?: true
    created_at?: true
    updated_at?: true
  }

  export type BlogCommentMaxAggregateInputType = {
    id?: true
    post_id?: true
    user_id?: true
    comment?: true
    created_at?: true
    updated_at?: true
  }

  export type BlogCommentCountAggregateInputType = {
    id?: true
    post_id?: true
    user_id?: true
    comment?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type BlogCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogComment to aggregate.
     */
    where?: BlogCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogComments to fetch.
     */
    orderBy?: BlogCommentOrderByWithRelationInput | BlogCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlogComments
    **/
    _count?: true | BlogCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlogCommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlogCommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogCommentMaxAggregateInputType
  }

  export type GetBlogCommentAggregateType<T extends BlogCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogComment[P]>
      : GetScalarType<T[P], AggregateBlogComment[P]>
  }




  export type BlogCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogCommentWhereInput
    orderBy?: BlogCommentOrderByWithAggregationInput | BlogCommentOrderByWithAggregationInput[]
    by: BlogCommentScalarFieldEnum[] | BlogCommentScalarFieldEnum
    having?: BlogCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogCommentCountAggregateInputType | true
    _avg?: BlogCommentAvgAggregateInputType
    _sum?: BlogCommentSumAggregateInputType
    _min?: BlogCommentMinAggregateInputType
    _max?: BlogCommentMaxAggregateInputType
  }

  export type BlogCommentGroupByOutputType = {
    id: number
    post_id: number
    user_id: number
    comment: string
    created_at: Date
    updated_at: Date
    _count: BlogCommentCountAggregateOutputType | null
    _avg: BlogCommentAvgAggregateOutputType | null
    _sum: BlogCommentSumAggregateOutputType | null
    _min: BlogCommentMinAggregateOutputType | null
    _max: BlogCommentMaxAggregateOutputType | null
  }

  type GetBlogCommentGroupByPayload<T extends BlogCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogCommentGroupByOutputType[P]>
            : GetScalarType<T[P], BlogCommentGroupByOutputType[P]>
        }
      >
    >


  export type BlogCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    post_id?: boolean
    user_id?: boolean
    comment?: boolean
    created_at?: boolean
    updated_at?: boolean
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogComment"]>

  export type BlogCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    post_id?: boolean
    user_id?: boolean
    comment?: boolean
    created_at?: boolean
    updated_at?: boolean
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogComment"]>


  export type BlogCommentSelectScalar = {
    id?: boolean
    post_id?: boolean
    user_id?: boolean
    comment?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type BlogCommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "post_id" | "user_id" | "comment" | "created_at" | "updated_at", ExtArgs["result"]["blogComment"]>
  export type BlogCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BlogCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BlogCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlogComment"
    objects: {
      post: Prisma.$BlogPostPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      post_id: number
      user_id: number
      comment: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["blogComment"]>
    composites: {}
  }

  type BlogCommentGetPayload<S extends boolean | null | undefined | BlogCommentDefaultArgs> = $Result.GetResult<Prisma.$BlogCommentPayload, S>

  type BlogCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlogCommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlogCommentCountAggregateInputType | true
    }

  export interface BlogCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlogComment'], meta: { name: 'BlogComment' } }
    /**
     * Find zero or one BlogComment that matches the filter.
     * @param {BlogCommentFindUniqueArgs} args - Arguments to find a BlogComment
     * @example
     * // Get one BlogComment
     * const blogComment = await prisma.blogComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlogCommentFindUniqueArgs>(args: SelectSubset<T, BlogCommentFindUniqueArgs<ExtArgs>>): Prisma__BlogCommentClient<$Result.GetResult<Prisma.$BlogCommentPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one BlogComment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlogCommentFindUniqueOrThrowArgs} args - Arguments to find a BlogComment
     * @example
     * // Get one BlogComment
     * const blogComment = await prisma.blogComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlogCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, BlogCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlogCommentClient<$Result.GetResult<Prisma.$BlogCommentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first BlogComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCommentFindFirstArgs} args - Arguments to find a BlogComment
     * @example
     * // Get one BlogComment
     * const blogComment = await prisma.blogComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlogCommentFindFirstArgs>(args?: SelectSubset<T, BlogCommentFindFirstArgs<ExtArgs>>): Prisma__BlogCommentClient<$Result.GetResult<Prisma.$BlogCommentPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first BlogComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCommentFindFirstOrThrowArgs} args - Arguments to find a BlogComment
     * @example
     * // Get one BlogComment
     * const blogComment = await prisma.blogComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlogCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, BlogCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlogCommentClient<$Result.GetResult<Prisma.$BlogCommentPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more BlogComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlogComments
     * const blogComments = await prisma.blogComment.findMany()
     * 
     * // Get first 10 BlogComments
     * const blogComments = await prisma.blogComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogCommentWithIdOnly = await prisma.blogComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlogCommentFindManyArgs>(args?: SelectSubset<T, BlogCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogCommentPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a BlogComment.
     * @param {BlogCommentCreateArgs} args - Arguments to create a BlogComment.
     * @example
     * // Create one BlogComment
     * const BlogComment = await prisma.blogComment.create({
     *   data: {
     *     // ... data to create a BlogComment
     *   }
     * })
     * 
     */
    create<T extends BlogCommentCreateArgs>(args: SelectSubset<T, BlogCommentCreateArgs<ExtArgs>>): Prisma__BlogCommentClient<$Result.GetResult<Prisma.$BlogCommentPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many BlogComments.
     * @param {BlogCommentCreateManyArgs} args - Arguments to create many BlogComments.
     * @example
     * // Create many BlogComments
     * const blogComment = await prisma.blogComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlogCommentCreateManyArgs>(args?: SelectSubset<T, BlogCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlogComments and returns the data saved in the database.
     * @param {BlogCommentCreateManyAndReturnArgs} args - Arguments to create many BlogComments.
     * @example
     * // Create many BlogComments
     * const blogComment = await prisma.blogComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlogComments and only return the `id`
     * const blogCommentWithIdOnly = await prisma.blogComment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlogCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, BlogCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogCommentPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a BlogComment.
     * @param {BlogCommentDeleteArgs} args - Arguments to delete one BlogComment.
     * @example
     * // Delete one BlogComment
     * const BlogComment = await prisma.blogComment.delete({
     *   where: {
     *     // ... filter to delete one BlogComment
     *   }
     * })
     * 
     */
    delete<T extends BlogCommentDeleteArgs>(args: SelectSubset<T, BlogCommentDeleteArgs<ExtArgs>>): Prisma__BlogCommentClient<$Result.GetResult<Prisma.$BlogCommentPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one BlogComment.
     * @param {BlogCommentUpdateArgs} args - Arguments to update one BlogComment.
     * @example
     * // Update one BlogComment
     * const blogComment = await prisma.blogComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlogCommentUpdateArgs>(args: SelectSubset<T, BlogCommentUpdateArgs<ExtArgs>>): Prisma__BlogCommentClient<$Result.GetResult<Prisma.$BlogCommentPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more BlogComments.
     * @param {BlogCommentDeleteManyArgs} args - Arguments to filter BlogComments to delete.
     * @example
     * // Delete a few BlogComments
     * const { count } = await prisma.blogComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlogCommentDeleteManyArgs>(args?: SelectSubset<T, BlogCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlogComments
     * const blogComment = await prisma.blogComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlogCommentUpdateManyArgs>(args: SelectSubset<T, BlogCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BlogComment.
     * @param {BlogCommentUpsertArgs} args - Arguments to update or create a BlogComment.
     * @example
     * // Update or create a BlogComment
     * const blogComment = await prisma.blogComment.upsert({
     *   create: {
     *     // ... data to create a BlogComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlogComment we want to update
     *   }
     * })
     */
    upsert<T extends BlogCommentUpsertArgs>(args: SelectSubset<T, BlogCommentUpsertArgs<ExtArgs>>): Prisma__BlogCommentClient<$Result.GetResult<Prisma.$BlogCommentPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of BlogComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCommentCountArgs} args - Arguments to filter BlogComments to count.
     * @example
     * // Count the number of BlogComments
     * const count = await prisma.blogComment.count({
     *   where: {
     *     // ... the filter for the BlogComments we want to count
     *   }
     * })
    **/
    count<T extends BlogCommentCountArgs>(
      args?: Subset<T, BlogCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlogComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogCommentAggregateArgs>(args: Subset<T, BlogCommentAggregateArgs>): Prisma.PrismaPromise<GetBlogCommentAggregateType<T>>

    /**
     * Group by BlogComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogCommentGroupByArgs['orderBy'] }
        : { orderBy?: BlogCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlogComment model
   */
  readonly fields: BlogCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlogComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends BlogPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlogPostDefaultArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlogComment model
   */ 
  interface BlogCommentFieldRefs {
    readonly id: FieldRef<"BlogComment", 'Int'>
    readonly post_id: FieldRef<"BlogComment", 'Int'>
    readonly user_id: FieldRef<"BlogComment", 'Int'>
    readonly comment: FieldRef<"BlogComment", 'String'>
    readonly created_at: FieldRef<"BlogComment", 'DateTime'>
    readonly updated_at: FieldRef<"BlogComment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlogComment findUnique
   */
  export type BlogCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogComment
     */
    omit?: BlogCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentInclude<ExtArgs> | null
    /**
     * Filter, which BlogComment to fetch.
     */
    where: BlogCommentWhereUniqueInput
  }

  /**
   * BlogComment findUniqueOrThrow
   */
  export type BlogCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogComment
     */
    omit?: BlogCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentInclude<ExtArgs> | null
    /**
     * Filter, which BlogComment to fetch.
     */
    where: BlogCommentWhereUniqueInput
  }

  /**
   * BlogComment findFirst
   */
  export type BlogCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogComment
     */
    omit?: BlogCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentInclude<ExtArgs> | null
    /**
     * Filter, which BlogComment to fetch.
     */
    where?: BlogCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogComments to fetch.
     */
    orderBy?: BlogCommentOrderByWithRelationInput | BlogCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogComments.
     */
    cursor?: BlogCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogComments.
     */
    distinct?: BlogCommentScalarFieldEnum | BlogCommentScalarFieldEnum[]
  }

  /**
   * BlogComment findFirstOrThrow
   */
  export type BlogCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogComment
     */
    omit?: BlogCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentInclude<ExtArgs> | null
    /**
     * Filter, which BlogComment to fetch.
     */
    where?: BlogCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogComments to fetch.
     */
    orderBy?: BlogCommentOrderByWithRelationInput | BlogCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogComments.
     */
    cursor?: BlogCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogComments.
     */
    distinct?: BlogCommentScalarFieldEnum | BlogCommentScalarFieldEnum[]
  }

  /**
   * BlogComment findMany
   */
  export type BlogCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogComment
     */
    omit?: BlogCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentInclude<ExtArgs> | null
    /**
     * Filter, which BlogComments to fetch.
     */
    where?: BlogCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogComments to fetch.
     */
    orderBy?: BlogCommentOrderByWithRelationInput | BlogCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlogComments.
     */
    cursor?: BlogCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogComments.
     */
    skip?: number
    distinct?: BlogCommentScalarFieldEnum | BlogCommentScalarFieldEnum[]
  }

  /**
   * BlogComment create
   */
  export type BlogCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogComment
     */
    omit?: BlogCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a BlogComment.
     */
    data: XOR<BlogCommentCreateInput, BlogCommentUncheckedCreateInput>
  }

  /**
   * BlogComment createMany
   */
  export type BlogCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlogComments.
     */
    data: BlogCommentCreateManyInput | BlogCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogComment createManyAndReturn
   */
  export type BlogCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogComment
     */
    omit?: BlogCommentOmit<ExtArgs> | null
    /**
     * The data used to create many BlogComments.
     */
    data: BlogCommentCreateManyInput | BlogCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlogComment update
   */
  export type BlogCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogComment
     */
    omit?: BlogCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a BlogComment.
     */
    data: XOR<BlogCommentUpdateInput, BlogCommentUncheckedUpdateInput>
    /**
     * Choose, which BlogComment to update.
     */
    where: BlogCommentWhereUniqueInput
  }

  /**
   * BlogComment updateMany
   */
  export type BlogCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlogComments.
     */
    data: XOR<BlogCommentUpdateManyMutationInput, BlogCommentUncheckedUpdateManyInput>
    /**
     * Filter which BlogComments to update
     */
    where?: BlogCommentWhereInput
  }

  /**
   * BlogComment upsert
   */
  export type BlogCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogComment
     */
    omit?: BlogCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the BlogComment to update in case it exists.
     */
    where: BlogCommentWhereUniqueInput
    /**
     * In case the BlogComment found by the `where` argument doesn't exist, create a new BlogComment with this data.
     */
    create: XOR<BlogCommentCreateInput, BlogCommentUncheckedCreateInput>
    /**
     * In case the BlogComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogCommentUpdateInput, BlogCommentUncheckedUpdateInput>
  }

  /**
   * BlogComment delete
   */
  export type BlogCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogComment
     */
    omit?: BlogCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentInclude<ExtArgs> | null
    /**
     * Filter which BlogComment to delete.
     */
    where: BlogCommentWhereUniqueInput
  }

  /**
   * BlogComment deleteMany
   */
  export type BlogCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogComments to delete
     */
    where?: BlogCommentWhereInput
  }

  /**
   * BlogComment without action
   */
  export type BlogCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogComment
     */
    omit?: BlogCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    wallet: number | null
    referredById: number | null
    phoneNumber: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    wallet: number | null
    referredById: number | null
    phoneNumber: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    wallet: number | null
    createdAt: Date | null
    referredById: number | null
    status: string | null
    userReferralLink: string | null
    username: string | null
    updatedAt: Date | null
    name: string | null
    phoneNumber: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    wallet: number | null
    createdAt: Date | null
    referredById: number | null
    status: string | null
    userReferralLink: string | null
    username: string | null
    updatedAt: Date | null
    name: string | null
    phoneNumber: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    wallet: number
    createdAt: number
    referredById: number
    status: number
    userReferralLink: number
    username: number
    updatedAt: number
    name: number
    phoneNumber: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    wallet?: true
    referredById?: true
    phoneNumber?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    wallet?: true
    referredById?: true
    phoneNumber?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    wallet?: true
    createdAt?: true
    referredById?: true
    status?: true
    userReferralLink?: true
    username?: true
    updatedAt?: true
    name?: true
    phoneNumber?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    wallet?: true
    createdAt?: true
    referredById?: true
    status?: true
    userReferralLink?: true
    username?: true
    updatedAt?: true
    name?: true
    phoneNumber?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    wallet?: true
    createdAt?: true
    referredById?: true
    status?: true
    userReferralLink?: true
    username?: true
    updatedAt?: true
    name?: true
    phoneNumber?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    password: string
    wallet: number
    createdAt: Date
    referredById: number | null
    status: string
    userReferralLink: string | null
    username: string
    updatedAt: Date
    name: string | null
    phoneNumber: number | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    wallet?: boolean
    createdAt?: boolean
    referredById?: boolean
    status?: boolean
    userReferralLink?: boolean
    username?: boolean
    updatedAt?: boolean
    name?: boolean
    phoneNumber?: boolean
    BlogComment?: boolean | User$BlogCommentArgs<ExtArgs>
    BlogPost?: boolean | User$BlogPostArgs<ExtArgs>
    Comment?: boolean | User$CommentArgs<ExtArgs>
    FavoriteApi?: boolean | User$FavoriteApiArgs<ExtArgs>
    favoriteStocks?: boolean | User$favoriteStocksArgs<ExtArgs>
    Goal?: boolean | User$GoalArgs<ExtArgs>
    limitOrders?: boolean | User$limitOrdersArgs<ExtArgs>
    RedeemBy?: boolean | User$RedeemByArgs<ExtArgs>
    referrals?: boolean | User$referralsArgs<ExtArgs>
    referralUsages?: boolean | User$referralUsagesArgs<ExtArgs>
    trading?: boolean | User$tradingArgs<ExtArgs>
    referredBy?: boolean | User$referredByArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    wallet?: boolean
    createdAt?: boolean
    referredById?: boolean
    status?: boolean
    userReferralLink?: boolean
    username?: boolean
    updatedAt?: boolean
    name?: boolean
    phoneNumber?: boolean
    referredBy?: boolean | User$referredByArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>


  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    wallet?: boolean
    createdAt?: boolean
    referredById?: boolean
    status?: boolean
    userReferralLink?: boolean
    username?: boolean
    updatedAt?: boolean
    name?: boolean
    phoneNumber?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "wallet" | "createdAt" | "referredById" | "status" | "userReferralLink" | "username" | "updatedAt" | "name" | "phoneNumber", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BlogComment?: boolean | User$BlogCommentArgs<ExtArgs>
    BlogPost?: boolean | User$BlogPostArgs<ExtArgs>
    Comment?: boolean | User$CommentArgs<ExtArgs>
    FavoriteApi?: boolean | User$FavoriteApiArgs<ExtArgs>
    favoriteStocks?: boolean | User$favoriteStocksArgs<ExtArgs>
    Goal?: boolean | User$GoalArgs<ExtArgs>
    limitOrders?: boolean | User$limitOrdersArgs<ExtArgs>
    RedeemBy?: boolean | User$RedeemByArgs<ExtArgs>
    referrals?: boolean | User$referralsArgs<ExtArgs>
    referralUsages?: boolean | User$referralUsagesArgs<ExtArgs>
    trading?: boolean | User$tradingArgs<ExtArgs>
    referredBy?: boolean | User$referredByArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referredBy?: boolean | User$referredByArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      BlogComment: Prisma.$BlogCommentPayload<ExtArgs>[]
      BlogPost: Prisma.$BlogPostPayload<ExtArgs>[]
      Comment: Prisma.$CommentPayload<ExtArgs>[]
      FavoriteApi: Prisma.$FavoriteApiPayload<ExtArgs>[]
      favoriteStocks: Prisma.$FavoriteStockPayload<ExtArgs>[]
      Goal: Prisma.$GoalPayload<ExtArgs>[]
      limitOrders: Prisma.$LimitOrderPayload<ExtArgs>[]
      RedeemBy: Prisma.$RedeemByPayload<ExtArgs>[]
      referrals: Prisma.$ReferralPayload<ExtArgs>[]
      referralUsages: Prisma.$ReferralUsagePayload<ExtArgs>[]
      trading: Prisma.$TradePayload<ExtArgs>[]
      referredBy: Prisma.$ReferralPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      wallet: number
      createdAt: Date
      referredById: number | null
      status: string
      userReferralLink: string | null
      username: string
      updatedAt: Date
      name: string | null
      phoneNumber: number | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    BlogComment<T extends User$BlogCommentArgs<ExtArgs> = {}>(args?: Subset<T, User$BlogCommentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogCommentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    BlogPost<T extends User$BlogPostArgs<ExtArgs> = {}>(args?: Subset<T, User$BlogPostArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Comment<T extends User$CommentArgs<ExtArgs> = {}>(args?: Subset<T, User$CommentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    FavoriteApi<T extends User$FavoriteApiArgs<ExtArgs> = {}>(args?: Subset<T, User$FavoriteApiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoriteApiPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    favoriteStocks<T extends User$favoriteStocksArgs<ExtArgs> = {}>(args?: Subset<T, User$favoriteStocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoriteStockPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Goal<T extends User$GoalArgs<ExtArgs> = {}>(args?: Subset<T, User$GoalArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    limitOrders<T extends User$limitOrdersArgs<ExtArgs> = {}>(args?: Subset<T, User$limitOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LimitOrderPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    RedeemBy<T extends User$RedeemByArgs<ExtArgs> = {}>(args?: Subset<T, User$RedeemByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RedeemByPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    referrals<T extends User$referralsArgs<ExtArgs> = {}>(args?: Subset<T, User$referralsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    referralUsages<T extends User$referralUsagesArgs<ExtArgs> = {}>(args?: Subset<T, User$referralUsagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralUsagePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    trading<T extends User$tradingArgs<ExtArgs> = {}>(args?: Subset<T, User$tradingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    referredBy<T extends User$referredByArgs<ExtArgs> = {}>(args?: Subset<T, User$referredByArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly wallet: FieldRef<"User", 'Int'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly referredById: FieldRef<"User", 'Int'>
    readonly status: FieldRef<"User", 'String'>
    readonly userReferralLink: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly name: FieldRef<"User", 'String'>
    readonly phoneNumber: FieldRef<"User", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.BlogComment
   */
  export type User$BlogCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogComment
     */
    omit?: BlogCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentInclude<ExtArgs> | null
    where?: BlogCommentWhereInput
    orderBy?: BlogCommentOrderByWithRelationInput | BlogCommentOrderByWithRelationInput[]
    cursor?: BlogCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogCommentScalarFieldEnum | BlogCommentScalarFieldEnum[]
  }

  /**
   * User.BlogPost
   */
  export type User$BlogPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    where?: BlogPostWhereInput
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    cursor?: BlogPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * User.Comment
   */
  export type User$CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.FavoriteApi
   */
  export type User$FavoriteApiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteApi
     */
    select?: FavoriteApiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteApi
     */
    omit?: FavoriteApiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteApiInclude<ExtArgs> | null
    where?: FavoriteApiWhereInput
    orderBy?: FavoriteApiOrderByWithRelationInput | FavoriteApiOrderByWithRelationInput[]
    cursor?: FavoriteApiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavoriteApiScalarFieldEnum | FavoriteApiScalarFieldEnum[]
  }

  /**
   * User.favoriteStocks
   */
  export type User$favoriteStocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteStock
     */
    select?: FavoriteStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteStock
     */
    omit?: FavoriteStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteStockInclude<ExtArgs> | null
    where?: FavoriteStockWhereInput
    orderBy?: FavoriteStockOrderByWithRelationInput | FavoriteStockOrderByWithRelationInput[]
    cursor?: FavoriteStockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavoriteStockScalarFieldEnum | FavoriteStockScalarFieldEnum[]
  }

  /**
   * User.Goal
   */
  export type User$GoalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    where?: GoalWhereInput
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[]
    cursor?: GoalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GoalScalarFieldEnum | GoalScalarFieldEnum[]
  }

  /**
   * User.limitOrders
   */
  export type User$limitOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LimitOrder
     */
    select?: LimitOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LimitOrder
     */
    omit?: LimitOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LimitOrderInclude<ExtArgs> | null
    where?: LimitOrderWhereInput
    orderBy?: LimitOrderOrderByWithRelationInput | LimitOrderOrderByWithRelationInput[]
    cursor?: LimitOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LimitOrderScalarFieldEnum | LimitOrderScalarFieldEnum[]
  }

  /**
   * User.RedeemBy
   */
  export type User$RedeemByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemBy
     */
    select?: RedeemBySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemBy
     */
    omit?: RedeemByOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemByInclude<ExtArgs> | null
    where?: RedeemByWhereInput
    orderBy?: RedeemByOrderByWithRelationInput | RedeemByOrderByWithRelationInput[]
    cursor?: RedeemByWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RedeemByScalarFieldEnum | RedeemByScalarFieldEnum[]
  }

  /**
   * User.referrals
   */
  export type User$referralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    cursor?: ReferralWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * User.referralUsages
   */
  export type User$referralUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralUsage
     */
    select?: ReferralUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferralUsage
     */
    omit?: ReferralUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralUsageInclude<ExtArgs> | null
    where?: ReferralUsageWhereInput
    orderBy?: ReferralUsageOrderByWithRelationInput | ReferralUsageOrderByWithRelationInput[]
    cursor?: ReferralUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralUsageScalarFieldEnum | ReferralUsageScalarFieldEnum[]
  }

  /**
   * User.trading
   */
  export type User$tradingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trade
     */
    omit?: TradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    where?: TradeWhereInput
    orderBy?: TradeOrderByWithRelationInput | TradeOrderByWithRelationInput[]
    cursor?: TradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TradeScalarFieldEnum | TradeScalarFieldEnum[]
  }

  /**
   * User.referredBy
   */
  export type User$referredByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    where?: ReferralWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Referral
   */

  export type AggregateReferral = {
    _count: ReferralCountAggregateOutputType | null
    _avg: ReferralAvgAggregateOutputType | null
    _sum: ReferralSumAggregateOutputType | null
    _min: ReferralMinAggregateOutputType | null
    _max: ReferralMaxAggregateOutputType | null
  }

  export type ReferralAvgAggregateOutputType = {
    id: number | null
    referralSignups: number | null
    successfulReferrals: number | null
    rewardsExchanged: number | null
    creditsEarned: number | null
    userId: number | null
    wallet: number | null
  }

  export type ReferralSumAggregateOutputType = {
    id: number | null
    referralSignups: number | null
    successfulReferrals: number | null
    rewardsExchanged: number | null
    creditsEarned: number | null
    userId: number | null
    wallet: number | null
  }

  export type ReferralMinAggregateOutputType = {
    id: number | null
    referralLink: string | null
    referralSignups: number | null
    successfulReferrals: number | null
    rewardsExchanged: number | null
    creditsEarned: number | null
    userId: number | null
    wallet: number | null
  }

  export type ReferralMaxAggregateOutputType = {
    id: number | null
    referralLink: string | null
    referralSignups: number | null
    successfulReferrals: number | null
    rewardsExchanged: number | null
    creditsEarned: number | null
    userId: number | null
    wallet: number | null
  }

  export type ReferralCountAggregateOutputType = {
    id: number
    referralLink: number
    referralSignups: number
    successfulReferrals: number
    rewardsExchanged: number
    creditsEarned: number
    userId: number
    wallet: number
    _all: number
  }


  export type ReferralAvgAggregateInputType = {
    id?: true
    referralSignups?: true
    successfulReferrals?: true
    rewardsExchanged?: true
    creditsEarned?: true
    userId?: true
    wallet?: true
  }

  export type ReferralSumAggregateInputType = {
    id?: true
    referralSignups?: true
    successfulReferrals?: true
    rewardsExchanged?: true
    creditsEarned?: true
    userId?: true
    wallet?: true
  }

  export type ReferralMinAggregateInputType = {
    id?: true
    referralLink?: true
    referralSignups?: true
    successfulReferrals?: true
    rewardsExchanged?: true
    creditsEarned?: true
    userId?: true
    wallet?: true
  }

  export type ReferralMaxAggregateInputType = {
    id?: true
    referralLink?: true
    referralSignups?: true
    successfulReferrals?: true
    rewardsExchanged?: true
    creditsEarned?: true
    userId?: true
    wallet?: true
  }

  export type ReferralCountAggregateInputType = {
    id?: true
    referralLink?: true
    referralSignups?: true
    successfulReferrals?: true
    rewardsExchanged?: true
    creditsEarned?: true
    userId?: true
    wallet?: true
    _all?: true
  }

  export type ReferralAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Referral to aggregate.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Referrals
    **/
    _count?: true | ReferralCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReferralAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReferralSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferralMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferralMaxAggregateInputType
  }

  export type GetReferralAggregateType<T extends ReferralAggregateArgs> = {
        [P in keyof T & keyof AggregateReferral]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferral[P]>
      : GetScalarType<T[P], AggregateReferral[P]>
  }




  export type ReferralGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithAggregationInput | ReferralOrderByWithAggregationInput[]
    by: ReferralScalarFieldEnum[] | ReferralScalarFieldEnum
    having?: ReferralScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferralCountAggregateInputType | true
    _avg?: ReferralAvgAggregateInputType
    _sum?: ReferralSumAggregateInputType
    _min?: ReferralMinAggregateInputType
    _max?: ReferralMaxAggregateInputType
  }

  export type ReferralGroupByOutputType = {
    id: number
    referralLink: string
    referralSignups: number
    successfulReferrals: number
    rewardsExchanged: number
    creditsEarned: number
    userId: number | null
    wallet: number
    _count: ReferralCountAggregateOutputType | null
    _avg: ReferralAvgAggregateOutputType | null
    _sum: ReferralSumAggregateOutputType | null
    _min: ReferralMinAggregateOutputType | null
    _max: ReferralMaxAggregateOutputType | null
  }

  type GetReferralGroupByPayload<T extends ReferralGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferralGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferralGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferralGroupByOutputType[P]>
            : GetScalarType<T[P], ReferralGroupByOutputType[P]>
        }
      >
    >


  export type ReferralSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referralLink?: boolean
    referralSignups?: boolean
    successfulReferrals?: boolean
    rewardsExchanged?: boolean
    creditsEarned?: boolean
    userId?: boolean
    wallet?: boolean
    user?: boolean | Referral$userArgs<ExtArgs>
    referralUsages?: boolean | Referral$referralUsagesArgs<ExtArgs>
    referredUsers?: boolean | Referral$referredUsersArgs<ExtArgs>
    _count?: boolean | ReferralCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referral"]>

  export type ReferralSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referralLink?: boolean
    referralSignups?: boolean
    successfulReferrals?: boolean
    rewardsExchanged?: boolean
    creditsEarned?: boolean
    userId?: boolean
    wallet?: boolean
    user?: boolean | Referral$userArgs<ExtArgs>
  }, ExtArgs["result"]["referral"]>


  export type ReferralSelectScalar = {
    id?: boolean
    referralLink?: boolean
    referralSignups?: boolean
    successfulReferrals?: boolean
    rewardsExchanged?: boolean
    creditsEarned?: boolean
    userId?: boolean
    wallet?: boolean
  }

  export type ReferralOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "referralLink" | "referralSignups" | "successfulReferrals" | "rewardsExchanged" | "creditsEarned" | "userId" | "wallet", ExtArgs["result"]["referral"]>
  export type ReferralInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Referral$userArgs<ExtArgs>
    referralUsages?: boolean | Referral$referralUsagesArgs<ExtArgs>
    referredUsers?: boolean | Referral$referredUsersArgs<ExtArgs>
    _count?: boolean | ReferralCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReferralIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Referral$userArgs<ExtArgs>
  }

  export type $ReferralPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Referral"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      referralUsages: Prisma.$ReferralUsagePayload<ExtArgs>[]
      referredUsers: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      referralLink: string
      referralSignups: number
      successfulReferrals: number
      rewardsExchanged: number
      creditsEarned: number
      userId: number | null
      wallet: number
    }, ExtArgs["result"]["referral"]>
    composites: {}
  }

  type ReferralGetPayload<S extends boolean | null | undefined | ReferralDefaultArgs> = $Result.GetResult<Prisma.$ReferralPayload, S>

  type ReferralCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReferralFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReferralCountAggregateInputType | true
    }

  export interface ReferralDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Referral'], meta: { name: 'Referral' } }
    /**
     * Find zero or one Referral that matches the filter.
     * @param {ReferralFindUniqueArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReferralFindUniqueArgs>(args: SelectSubset<T, ReferralFindUniqueArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Referral that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReferralFindUniqueOrThrowArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReferralFindUniqueOrThrowArgs>(args: SelectSubset<T, ReferralFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Referral that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindFirstArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReferralFindFirstArgs>(args?: SelectSubset<T, ReferralFindFirstArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Referral that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindFirstOrThrowArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReferralFindFirstOrThrowArgs>(args?: SelectSubset<T, ReferralFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Referrals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Referrals
     * const referrals = await prisma.referral.findMany()
     * 
     * // Get first 10 Referrals
     * const referrals = await prisma.referral.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referralWithIdOnly = await prisma.referral.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReferralFindManyArgs>(args?: SelectSubset<T, ReferralFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Referral.
     * @param {ReferralCreateArgs} args - Arguments to create a Referral.
     * @example
     * // Create one Referral
     * const Referral = await prisma.referral.create({
     *   data: {
     *     // ... data to create a Referral
     *   }
     * })
     * 
     */
    create<T extends ReferralCreateArgs>(args: SelectSubset<T, ReferralCreateArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Referrals.
     * @param {ReferralCreateManyArgs} args - Arguments to create many Referrals.
     * @example
     * // Create many Referrals
     * const referral = await prisma.referral.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReferralCreateManyArgs>(args?: SelectSubset<T, ReferralCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Referrals and returns the data saved in the database.
     * @param {ReferralCreateManyAndReturnArgs} args - Arguments to create many Referrals.
     * @example
     * // Create many Referrals
     * const referral = await prisma.referral.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Referrals and only return the `id`
     * const referralWithIdOnly = await prisma.referral.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReferralCreateManyAndReturnArgs>(args?: SelectSubset<T, ReferralCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Referral.
     * @param {ReferralDeleteArgs} args - Arguments to delete one Referral.
     * @example
     * // Delete one Referral
     * const Referral = await prisma.referral.delete({
     *   where: {
     *     // ... filter to delete one Referral
     *   }
     * })
     * 
     */
    delete<T extends ReferralDeleteArgs>(args: SelectSubset<T, ReferralDeleteArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Referral.
     * @param {ReferralUpdateArgs} args - Arguments to update one Referral.
     * @example
     * // Update one Referral
     * const referral = await prisma.referral.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReferralUpdateArgs>(args: SelectSubset<T, ReferralUpdateArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Referrals.
     * @param {ReferralDeleteManyArgs} args - Arguments to filter Referrals to delete.
     * @example
     * // Delete a few Referrals
     * const { count } = await prisma.referral.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReferralDeleteManyArgs>(args?: SelectSubset<T, ReferralDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Referrals
     * const referral = await prisma.referral.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReferralUpdateManyArgs>(args: SelectSubset<T, ReferralUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Referral.
     * @param {ReferralUpsertArgs} args - Arguments to update or create a Referral.
     * @example
     * // Update or create a Referral
     * const referral = await prisma.referral.upsert({
     *   create: {
     *     // ... data to create a Referral
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Referral we want to update
     *   }
     * })
     */
    upsert<T extends ReferralUpsertArgs>(args: SelectSubset<T, ReferralUpsertArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralCountArgs} args - Arguments to filter Referrals to count.
     * @example
     * // Count the number of Referrals
     * const count = await prisma.referral.count({
     *   where: {
     *     // ... the filter for the Referrals we want to count
     *   }
     * })
    **/
    count<T extends ReferralCountArgs>(
      args?: Subset<T, ReferralCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferralCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Referral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferralAggregateArgs>(args: Subset<T, ReferralAggregateArgs>): Prisma.PrismaPromise<GetReferralAggregateType<T>>

    /**
     * Group by Referral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferralGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferralGroupByArgs['orderBy'] }
        : { orderBy?: ReferralGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferralGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferralGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Referral model
   */
  readonly fields: ReferralFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Referral.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReferralClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Referral$userArgs<ExtArgs> = {}>(args?: Subset<T, Referral$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    referralUsages<T extends Referral$referralUsagesArgs<ExtArgs> = {}>(args?: Subset<T, Referral$referralUsagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralUsagePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    referredUsers<T extends Referral$referredUsersArgs<ExtArgs> = {}>(args?: Subset<T, Referral$referredUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Referral model
   */ 
  interface ReferralFieldRefs {
    readonly id: FieldRef<"Referral", 'Int'>
    readonly referralLink: FieldRef<"Referral", 'String'>
    readonly referralSignups: FieldRef<"Referral", 'Int'>
    readonly successfulReferrals: FieldRef<"Referral", 'Int'>
    readonly rewardsExchanged: FieldRef<"Referral", 'Int'>
    readonly creditsEarned: FieldRef<"Referral", 'Int'>
    readonly userId: FieldRef<"Referral", 'Int'>
    readonly wallet: FieldRef<"Referral", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Referral findUnique
   */
  export type ReferralFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral findUniqueOrThrow
   */
  export type ReferralFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral findFirst
   */
  export type ReferralFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referrals.
     */
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral findFirstOrThrow
   */
  export type ReferralFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referrals.
     */
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral findMany
   */
  export type ReferralFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referrals to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral create
   */
  export type ReferralCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The data needed to create a Referral.
     */
    data: XOR<ReferralCreateInput, ReferralUncheckedCreateInput>
  }

  /**
   * Referral createMany
   */
  export type ReferralCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Referrals.
     */
    data: ReferralCreateManyInput | ReferralCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Referral createManyAndReturn
   */
  export type ReferralCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * The data used to create many Referrals.
     */
    data: ReferralCreateManyInput | ReferralCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Referral update
   */
  export type ReferralUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The data needed to update a Referral.
     */
    data: XOR<ReferralUpdateInput, ReferralUncheckedUpdateInput>
    /**
     * Choose, which Referral to update.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral updateMany
   */
  export type ReferralUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Referrals.
     */
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyInput>
    /**
     * Filter which Referrals to update
     */
    where?: ReferralWhereInput
  }

  /**
   * Referral upsert
   */
  export type ReferralUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The filter to search for the Referral to update in case it exists.
     */
    where: ReferralWhereUniqueInput
    /**
     * In case the Referral found by the `where` argument doesn't exist, create a new Referral with this data.
     */
    create: XOR<ReferralCreateInput, ReferralUncheckedCreateInput>
    /**
     * In case the Referral was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReferralUpdateInput, ReferralUncheckedUpdateInput>
  }

  /**
   * Referral delete
   */
  export type ReferralDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter which Referral to delete.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral deleteMany
   */
  export type ReferralDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Referrals to delete
     */
    where?: ReferralWhereInput
  }

  /**
   * Referral.user
   */
  export type Referral$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Referral.referralUsages
   */
  export type Referral$referralUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralUsage
     */
    select?: ReferralUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferralUsage
     */
    omit?: ReferralUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralUsageInclude<ExtArgs> | null
    where?: ReferralUsageWhereInput
    orderBy?: ReferralUsageOrderByWithRelationInput | ReferralUsageOrderByWithRelationInput[]
    cursor?: ReferralUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralUsageScalarFieldEnum | ReferralUsageScalarFieldEnum[]
  }

  /**
   * Referral.referredUsers
   */
  export type Referral$referredUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Referral without action
   */
  export type ReferralDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
  }


  /**
   * Model ReferralUsage
   */

  export type AggregateReferralUsage = {
    _count: ReferralUsageCountAggregateOutputType | null
    _avg: ReferralUsageAvgAggregateOutputType | null
    _sum: ReferralUsageSumAggregateOutputType | null
    _min: ReferralUsageMinAggregateOutputType | null
    _max: ReferralUsageMaxAggregateOutputType | null
  }

  export type ReferralUsageAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    referralId: number | null
  }

  export type ReferralUsageSumAggregateOutputType = {
    id: number | null
    userId: number | null
    referralId: number | null
  }

  export type ReferralUsageMinAggregateOutputType = {
    id: number | null
    userId: number | null
    referralId: number | null
    createdAt: Date | null
  }

  export type ReferralUsageMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    referralId: number | null
    createdAt: Date | null
  }

  export type ReferralUsageCountAggregateOutputType = {
    id: number
    userId: number
    referralId: number
    createdAt: number
    _all: number
  }


  export type ReferralUsageAvgAggregateInputType = {
    id?: true
    userId?: true
    referralId?: true
  }

  export type ReferralUsageSumAggregateInputType = {
    id?: true
    userId?: true
    referralId?: true
  }

  export type ReferralUsageMinAggregateInputType = {
    id?: true
    userId?: true
    referralId?: true
    createdAt?: true
  }

  export type ReferralUsageMaxAggregateInputType = {
    id?: true
    userId?: true
    referralId?: true
    createdAt?: true
  }

  export type ReferralUsageCountAggregateInputType = {
    id?: true
    userId?: true
    referralId?: true
    createdAt?: true
    _all?: true
  }

  export type ReferralUsageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReferralUsage to aggregate.
     */
    where?: ReferralUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralUsages to fetch.
     */
    orderBy?: ReferralUsageOrderByWithRelationInput | ReferralUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReferralUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReferralUsages
    **/
    _count?: true | ReferralUsageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReferralUsageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReferralUsageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferralUsageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferralUsageMaxAggregateInputType
  }

  export type GetReferralUsageAggregateType<T extends ReferralUsageAggregateArgs> = {
        [P in keyof T & keyof AggregateReferralUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferralUsage[P]>
      : GetScalarType<T[P], AggregateReferralUsage[P]>
  }




  export type ReferralUsageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralUsageWhereInput
    orderBy?: ReferralUsageOrderByWithAggregationInput | ReferralUsageOrderByWithAggregationInput[]
    by: ReferralUsageScalarFieldEnum[] | ReferralUsageScalarFieldEnum
    having?: ReferralUsageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferralUsageCountAggregateInputType | true
    _avg?: ReferralUsageAvgAggregateInputType
    _sum?: ReferralUsageSumAggregateInputType
    _min?: ReferralUsageMinAggregateInputType
    _max?: ReferralUsageMaxAggregateInputType
  }

  export type ReferralUsageGroupByOutputType = {
    id: number
    userId: number | null
    referralId: number | null
    createdAt: Date
    _count: ReferralUsageCountAggregateOutputType | null
    _avg: ReferralUsageAvgAggregateOutputType | null
    _sum: ReferralUsageSumAggregateOutputType | null
    _min: ReferralUsageMinAggregateOutputType | null
    _max: ReferralUsageMaxAggregateOutputType | null
  }

  type GetReferralUsageGroupByPayload<T extends ReferralUsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferralUsageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferralUsageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferralUsageGroupByOutputType[P]>
            : GetScalarType<T[P], ReferralUsageGroupByOutputType[P]>
        }
      >
    >


  export type ReferralUsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    referralId?: boolean
    createdAt?: boolean
    referral?: boolean | ReferralUsage$referralArgs<ExtArgs>
    user?: boolean | ReferralUsage$userArgs<ExtArgs>
  }, ExtArgs["result"]["referralUsage"]>

  export type ReferralUsageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    referralId?: boolean
    createdAt?: boolean
    referral?: boolean | ReferralUsage$referralArgs<ExtArgs>
    user?: boolean | ReferralUsage$userArgs<ExtArgs>
  }, ExtArgs["result"]["referralUsage"]>


  export type ReferralUsageSelectScalar = {
    id?: boolean
    userId?: boolean
    referralId?: boolean
    createdAt?: boolean
  }

  export type ReferralUsageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "referralId" | "createdAt", ExtArgs["result"]["referralUsage"]>
  export type ReferralUsageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referral?: boolean | ReferralUsage$referralArgs<ExtArgs>
    user?: boolean | ReferralUsage$userArgs<ExtArgs>
  }
  export type ReferralUsageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referral?: boolean | ReferralUsage$referralArgs<ExtArgs>
    user?: boolean | ReferralUsage$userArgs<ExtArgs>
  }

  export type $ReferralUsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReferralUsage"
    objects: {
      referral: Prisma.$ReferralPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
      referralId: number | null
      createdAt: Date
    }, ExtArgs["result"]["referralUsage"]>
    composites: {}
  }

  type ReferralUsageGetPayload<S extends boolean | null | undefined | ReferralUsageDefaultArgs> = $Result.GetResult<Prisma.$ReferralUsagePayload, S>

  type ReferralUsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReferralUsageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReferralUsageCountAggregateInputType | true
    }

  export interface ReferralUsageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReferralUsage'], meta: { name: 'ReferralUsage' } }
    /**
     * Find zero or one ReferralUsage that matches the filter.
     * @param {ReferralUsageFindUniqueArgs} args - Arguments to find a ReferralUsage
     * @example
     * // Get one ReferralUsage
     * const referralUsage = await prisma.referralUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReferralUsageFindUniqueArgs>(args: SelectSubset<T, ReferralUsageFindUniqueArgs<ExtArgs>>): Prisma__ReferralUsageClient<$Result.GetResult<Prisma.$ReferralUsagePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ReferralUsage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReferralUsageFindUniqueOrThrowArgs} args - Arguments to find a ReferralUsage
     * @example
     * // Get one ReferralUsage
     * const referralUsage = await prisma.referralUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReferralUsageFindUniqueOrThrowArgs>(args: SelectSubset<T, ReferralUsageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReferralUsageClient<$Result.GetResult<Prisma.$ReferralUsagePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ReferralUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralUsageFindFirstArgs} args - Arguments to find a ReferralUsage
     * @example
     * // Get one ReferralUsage
     * const referralUsage = await prisma.referralUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReferralUsageFindFirstArgs>(args?: SelectSubset<T, ReferralUsageFindFirstArgs<ExtArgs>>): Prisma__ReferralUsageClient<$Result.GetResult<Prisma.$ReferralUsagePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ReferralUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralUsageFindFirstOrThrowArgs} args - Arguments to find a ReferralUsage
     * @example
     * // Get one ReferralUsage
     * const referralUsage = await prisma.referralUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReferralUsageFindFirstOrThrowArgs>(args?: SelectSubset<T, ReferralUsageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReferralUsageClient<$Result.GetResult<Prisma.$ReferralUsagePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ReferralUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReferralUsages
     * const referralUsages = await prisma.referralUsage.findMany()
     * 
     * // Get first 10 ReferralUsages
     * const referralUsages = await prisma.referralUsage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referralUsageWithIdOnly = await prisma.referralUsage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReferralUsageFindManyArgs>(args?: SelectSubset<T, ReferralUsageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralUsagePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ReferralUsage.
     * @param {ReferralUsageCreateArgs} args - Arguments to create a ReferralUsage.
     * @example
     * // Create one ReferralUsage
     * const ReferralUsage = await prisma.referralUsage.create({
     *   data: {
     *     // ... data to create a ReferralUsage
     *   }
     * })
     * 
     */
    create<T extends ReferralUsageCreateArgs>(args: SelectSubset<T, ReferralUsageCreateArgs<ExtArgs>>): Prisma__ReferralUsageClient<$Result.GetResult<Prisma.$ReferralUsagePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ReferralUsages.
     * @param {ReferralUsageCreateManyArgs} args - Arguments to create many ReferralUsages.
     * @example
     * // Create many ReferralUsages
     * const referralUsage = await prisma.referralUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReferralUsageCreateManyArgs>(args?: SelectSubset<T, ReferralUsageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReferralUsages and returns the data saved in the database.
     * @param {ReferralUsageCreateManyAndReturnArgs} args - Arguments to create many ReferralUsages.
     * @example
     * // Create many ReferralUsages
     * const referralUsage = await prisma.referralUsage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReferralUsages and only return the `id`
     * const referralUsageWithIdOnly = await prisma.referralUsage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReferralUsageCreateManyAndReturnArgs>(args?: SelectSubset<T, ReferralUsageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralUsagePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ReferralUsage.
     * @param {ReferralUsageDeleteArgs} args - Arguments to delete one ReferralUsage.
     * @example
     * // Delete one ReferralUsage
     * const ReferralUsage = await prisma.referralUsage.delete({
     *   where: {
     *     // ... filter to delete one ReferralUsage
     *   }
     * })
     * 
     */
    delete<T extends ReferralUsageDeleteArgs>(args: SelectSubset<T, ReferralUsageDeleteArgs<ExtArgs>>): Prisma__ReferralUsageClient<$Result.GetResult<Prisma.$ReferralUsagePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ReferralUsage.
     * @param {ReferralUsageUpdateArgs} args - Arguments to update one ReferralUsage.
     * @example
     * // Update one ReferralUsage
     * const referralUsage = await prisma.referralUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReferralUsageUpdateArgs>(args: SelectSubset<T, ReferralUsageUpdateArgs<ExtArgs>>): Prisma__ReferralUsageClient<$Result.GetResult<Prisma.$ReferralUsagePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ReferralUsages.
     * @param {ReferralUsageDeleteManyArgs} args - Arguments to filter ReferralUsages to delete.
     * @example
     * // Delete a few ReferralUsages
     * const { count } = await prisma.referralUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReferralUsageDeleteManyArgs>(args?: SelectSubset<T, ReferralUsageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReferralUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReferralUsages
     * const referralUsage = await prisma.referralUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReferralUsageUpdateManyArgs>(args: SelectSubset<T, ReferralUsageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReferralUsage.
     * @param {ReferralUsageUpsertArgs} args - Arguments to update or create a ReferralUsage.
     * @example
     * // Update or create a ReferralUsage
     * const referralUsage = await prisma.referralUsage.upsert({
     *   create: {
     *     // ... data to create a ReferralUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReferralUsage we want to update
     *   }
     * })
     */
    upsert<T extends ReferralUsageUpsertArgs>(args: SelectSubset<T, ReferralUsageUpsertArgs<ExtArgs>>): Prisma__ReferralUsageClient<$Result.GetResult<Prisma.$ReferralUsagePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ReferralUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralUsageCountArgs} args - Arguments to filter ReferralUsages to count.
     * @example
     * // Count the number of ReferralUsages
     * const count = await prisma.referralUsage.count({
     *   where: {
     *     // ... the filter for the ReferralUsages we want to count
     *   }
     * })
    **/
    count<T extends ReferralUsageCountArgs>(
      args?: Subset<T, ReferralUsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferralUsageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReferralUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferralUsageAggregateArgs>(args: Subset<T, ReferralUsageAggregateArgs>): Prisma.PrismaPromise<GetReferralUsageAggregateType<T>>

    /**
     * Group by ReferralUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferralUsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferralUsageGroupByArgs['orderBy'] }
        : { orderBy?: ReferralUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferralUsageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferralUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReferralUsage model
   */
  readonly fields: ReferralUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReferralUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReferralUsageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    referral<T extends ReferralUsage$referralArgs<ExtArgs> = {}>(args?: Subset<T, ReferralUsage$referralArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    user<T extends ReferralUsage$userArgs<ExtArgs> = {}>(args?: Subset<T, ReferralUsage$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReferralUsage model
   */ 
  interface ReferralUsageFieldRefs {
    readonly id: FieldRef<"ReferralUsage", 'Int'>
    readonly userId: FieldRef<"ReferralUsage", 'Int'>
    readonly referralId: FieldRef<"ReferralUsage", 'Int'>
    readonly createdAt: FieldRef<"ReferralUsage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReferralUsage findUnique
   */
  export type ReferralUsageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralUsage
     */
    select?: ReferralUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferralUsage
     */
    omit?: ReferralUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralUsageInclude<ExtArgs> | null
    /**
     * Filter, which ReferralUsage to fetch.
     */
    where: ReferralUsageWhereUniqueInput
  }

  /**
   * ReferralUsage findUniqueOrThrow
   */
  export type ReferralUsageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralUsage
     */
    select?: ReferralUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferralUsage
     */
    omit?: ReferralUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralUsageInclude<ExtArgs> | null
    /**
     * Filter, which ReferralUsage to fetch.
     */
    where: ReferralUsageWhereUniqueInput
  }

  /**
   * ReferralUsage findFirst
   */
  export type ReferralUsageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralUsage
     */
    select?: ReferralUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferralUsage
     */
    omit?: ReferralUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralUsageInclude<ExtArgs> | null
    /**
     * Filter, which ReferralUsage to fetch.
     */
    where?: ReferralUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralUsages to fetch.
     */
    orderBy?: ReferralUsageOrderByWithRelationInput | ReferralUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferralUsages.
     */
    cursor?: ReferralUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferralUsages.
     */
    distinct?: ReferralUsageScalarFieldEnum | ReferralUsageScalarFieldEnum[]
  }

  /**
   * ReferralUsage findFirstOrThrow
   */
  export type ReferralUsageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralUsage
     */
    select?: ReferralUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferralUsage
     */
    omit?: ReferralUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralUsageInclude<ExtArgs> | null
    /**
     * Filter, which ReferralUsage to fetch.
     */
    where?: ReferralUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralUsages to fetch.
     */
    orderBy?: ReferralUsageOrderByWithRelationInput | ReferralUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferralUsages.
     */
    cursor?: ReferralUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferralUsages.
     */
    distinct?: ReferralUsageScalarFieldEnum | ReferralUsageScalarFieldEnum[]
  }

  /**
   * ReferralUsage findMany
   */
  export type ReferralUsageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralUsage
     */
    select?: ReferralUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferralUsage
     */
    omit?: ReferralUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralUsageInclude<ExtArgs> | null
    /**
     * Filter, which ReferralUsages to fetch.
     */
    where?: ReferralUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralUsages to fetch.
     */
    orderBy?: ReferralUsageOrderByWithRelationInput | ReferralUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReferralUsages.
     */
    cursor?: ReferralUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralUsages.
     */
    skip?: number
    distinct?: ReferralUsageScalarFieldEnum | ReferralUsageScalarFieldEnum[]
  }

  /**
   * ReferralUsage create
   */
  export type ReferralUsageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralUsage
     */
    select?: ReferralUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferralUsage
     */
    omit?: ReferralUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralUsageInclude<ExtArgs> | null
    /**
     * The data needed to create a ReferralUsage.
     */
    data?: XOR<ReferralUsageCreateInput, ReferralUsageUncheckedCreateInput>
  }

  /**
   * ReferralUsage createMany
   */
  export type ReferralUsageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReferralUsages.
     */
    data: ReferralUsageCreateManyInput | ReferralUsageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReferralUsage createManyAndReturn
   */
  export type ReferralUsageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralUsage
     */
    select?: ReferralUsageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReferralUsage
     */
    omit?: ReferralUsageOmit<ExtArgs> | null
    /**
     * The data used to create many ReferralUsages.
     */
    data: ReferralUsageCreateManyInput | ReferralUsageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralUsageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReferralUsage update
   */
  export type ReferralUsageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralUsage
     */
    select?: ReferralUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferralUsage
     */
    omit?: ReferralUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralUsageInclude<ExtArgs> | null
    /**
     * The data needed to update a ReferralUsage.
     */
    data: XOR<ReferralUsageUpdateInput, ReferralUsageUncheckedUpdateInput>
    /**
     * Choose, which ReferralUsage to update.
     */
    where: ReferralUsageWhereUniqueInput
  }

  /**
   * ReferralUsage updateMany
   */
  export type ReferralUsageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReferralUsages.
     */
    data: XOR<ReferralUsageUpdateManyMutationInput, ReferralUsageUncheckedUpdateManyInput>
    /**
     * Filter which ReferralUsages to update
     */
    where?: ReferralUsageWhereInput
  }

  /**
   * ReferralUsage upsert
   */
  export type ReferralUsageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralUsage
     */
    select?: ReferralUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferralUsage
     */
    omit?: ReferralUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralUsageInclude<ExtArgs> | null
    /**
     * The filter to search for the ReferralUsage to update in case it exists.
     */
    where: ReferralUsageWhereUniqueInput
    /**
     * In case the ReferralUsage found by the `where` argument doesn't exist, create a new ReferralUsage with this data.
     */
    create: XOR<ReferralUsageCreateInput, ReferralUsageUncheckedCreateInput>
    /**
     * In case the ReferralUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReferralUsageUpdateInput, ReferralUsageUncheckedUpdateInput>
  }

  /**
   * ReferralUsage delete
   */
  export type ReferralUsageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralUsage
     */
    select?: ReferralUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferralUsage
     */
    omit?: ReferralUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralUsageInclude<ExtArgs> | null
    /**
     * Filter which ReferralUsage to delete.
     */
    where: ReferralUsageWhereUniqueInput
  }

  /**
   * ReferralUsage deleteMany
   */
  export type ReferralUsageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReferralUsages to delete
     */
    where?: ReferralUsageWhereInput
  }

  /**
   * ReferralUsage.referral
   */
  export type ReferralUsage$referralArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    where?: ReferralWhereInput
  }

  /**
   * ReferralUsage.user
   */
  export type ReferralUsage$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ReferralUsage without action
   */
  export type ReferralUsageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralUsage
     */
    select?: ReferralUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferralUsage
     */
    omit?: ReferralUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralUsageInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    viewCount: number | null
  }

  export type CommentSumAggregateOutputType = {
    id: number | null
    userId: number | null
    viewCount: number | null
  }

  export type CommentMinAggregateOutputType = {
    id: number | null
    userId: number | null
    stockSymbol: string | null
    content: string | null
    createdAt: Date | null
    viewCount: number | null
  }

  export type CommentMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    stockSymbol: string | null
    content: string | null
    createdAt: Date | null
    viewCount: number | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    userId: number
    stockSymbol: number
    content: number
    createdAt: number
    viewCount: number
    _all: number
  }


  export type CommentAvgAggregateInputType = {
    id?: true
    userId?: true
    viewCount?: true
  }

  export type CommentSumAggregateInputType = {
    id?: true
    userId?: true
    viewCount?: true
  }

  export type CommentMinAggregateInputType = {
    id?: true
    userId?: true
    stockSymbol?: true
    content?: true
    createdAt?: true
    viewCount?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    userId?: true
    stockSymbol?: true
    content?: true
    createdAt?: true
    viewCount?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    userId?: true
    stockSymbol?: true
    content?: true
    createdAt?: true
    viewCount?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _avg?: CommentAvgAggregateInputType
    _sum?: CommentSumAggregateInputType
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: number
    userId: number
    stockSymbol: string
    content: string
    createdAt: Date
    viewCount: number
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    stockSymbol?: boolean
    content?: boolean
    createdAt?: boolean
    viewCount?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    stockSymbol?: boolean
    content?: boolean
    createdAt?: boolean
    viewCount?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>


  export type CommentSelectScalar = {
    id?: boolean
    userId?: boolean
    stockSymbol?: boolean
    content?: boolean
    createdAt?: boolean
    viewCount?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "stockSymbol" | "content" | "createdAt" | "viewCount", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      stockSymbol: string
      content: string
      createdAt: Date
      viewCount: number
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */ 
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'Int'>
    readonly userId: FieldRef<"Comment", 'Int'>
    readonly stockSymbol: FieldRef<"Comment", 'String'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly viewCount: FieldRef<"Comment", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model FavoriteApi
   */

  export type AggregateFavoriteApi = {
    _count: FavoriteApiCountAggregateOutputType | null
    _avg: FavoriteApiAvgAggregateOutputType | null
    _sum: FavoriteApiSumAggregateOutputType | null
    _min: FavoriteApiMinAggregateOutputType | null
    _max: FavoriteApiMaxAggregateOutputType | null
  }

  export type FavoriteApiAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type FavoriteApiSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type FavoriteApiMinAggregateOutputType = {
    id: number | null
    userId: number | null
    symbol: string | null
  }

  export type FavoriteApiMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    symbol: string | null
  }

  export type FavoriteApiCountAggregateOutputType = {
    id: number
    userId: number
    symbol: number
    _all: number
  }


  export type FavoriteApiAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type FavoriteApiSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type FavoriteApiMinAggregateInputType = {
    id?: true
    userId?: true
    symbol?: true
  }

  export type FavoriteApiMaxAggregateInputType = {
    id?: true
    userId?: true
    symbol?: true
  }

  export type FavoriteApiCountAggregateInputType = {
    id?: true
    userId?: true
    symbol?: true
    _all?: true
  }

  export type FavoriteApiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FavoriteApi to aggregate.
     */
    where?: FavoriteApiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FavoriteApis to fetch.
     */
    orderBy?: FavoriteApiOrderByWithRelationInput | FavoriteApiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FavoriteApiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FavoriteApis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FavoriteApis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FavoriteApis
    **/
    _count?: true | FavoriteApiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FavoriteApiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FavoriteApiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FavoriteApiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FavoriteApiMaxAggregateInputType
  }

  export type GetFavoriteApiAggregateType<T extends FavoriteApiAggregateArgs> = {
        [P in keyof T & keyof AggregateFavoriteApi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFavoriteApi[P]>
      : GetScalarType<T[P], AggregateFavoriteApi[P]>
  }




  export type FavoriteApiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteApiWhereInput
    orderBy?: FavoriteApiOrderByWithAggregationInput | FavoriteApiOrderByWithAggregationInput[]
    by: FavoriteApiScalarFieldEnum[] | FavoriteApiScalarFieldEnum
    having?: FavoriteApiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FavoriteApiCountAggregateInputType | true
    _avg?: FavoriteApiAvgAggregateInputType
    _sum?: FavoriteApiSumAggregateInputType
    _min?: FavoriteApiMinAggregateInputType
    _max?: FavoriteApiMaxAggregateInputType
  }

  export type FavoriteApiGroupByOutputType = {
    id: number
    userId: number
    symbol: string
    _count: FavoriteApiCountAggregateOutputType | null
    _avg: FavoriteApiAvgAggregateOutputType | null
    _sum: FavoriteApiSumAggregateOutputType | null
    _min: FavoriteApiMinAggregateOutputType | null
    _max: FavoriteApiMaxAggregateOutputType | null
  }

  type GetFavoriteApiGroupByPayload<T extends FavoriteApiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FavoriteApiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FavoriteApiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FavoriteApiGroupByOutputType[P]>
            : GetScalarType<T[P], FavoriteApiGroupByOutputType[P]>
        }
      >
    >


  export type FavoriteApiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    symbol?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favoriteApi"]>

  export type FavoriteApiSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    symbol?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favoriteApi"]>


  export type FavoriteApiSelectScalar = {
    id?: boolean
    userId?: boolean
    symbol?: boolean
  }

  export type FavoriteApiOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "symbol", ExtArgs["result"]["favoriteApi"]>
  export type FavoriteApiInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FavoriteApiIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FavoriteApiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FavoriteApi"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      symbol: string
    }, ExtArgs["result"]["favoriteApi"]>
    composites: {}
  }

  type FavoriteApiGetPayload<S extends boolean | null | undefined | FavoriteApiDefaultArgs> = $Result.GetResult<Prisma.$FavoriteApiPayload, S>

  type FavoriteApiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FavoriteApiFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FavoriteApiCountAggregateInputType | true
    }

  export interface FavoriteApiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FavoriteApi'], meta: { name: 'FavoriteApi' } }
    /**
     * Find zero or one FavoriteApi that matches the filter.
     * @param {FavoriteApiFindUniqueArgs} args - Arguments to find a FavoriteApi
     * @example
     * // Get one FavoriteApi
     * const favoriteApi = await prisma.favoriteApi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FavoriteApiFindUniqueArgs>(args: SelectSubset<T, FavoriteApiFindUniqueArgs<ExtArgs>>): Prisma__FavoriteApiClient<$Result.GetResult<Prisma.$FavoriteApiPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one FavoriteApi that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FavoriteApiFindUniqueOrThrowArgs} args - Arguments to find a FavoriteApi
     * @example
     * // Get one FavoriteApi
     * const favoriteApi = await prisma.favoriteApi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FavoriteApiFindUniqueOrThrowArgs>(args: SelectSubset<T, FavoriteApiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FavoriteApiClient<$Result.GetResult<Prisma.$FavoriteApiPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first FavoriteApi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteApiFindFirstArgs} args - Arguments to find a FavoriteApi
     * @example
     * // Get one FavoriteApi
     * const favoriteApi = await prisma.favoriteApi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FavoriteApiFindFirstArgs>(args?: SelectSubset<T, FavoriteApiFindFirstArgs<ExtArgs>>): Prisma__FavoriteApiClient<$Result.GetResult<Prisma.$FavoriteApiPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first FavoriteApi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteApiFindFirstOrThrowArgs} args - Arguments to find a FavoriteApi
     * @example
     * // Get one FavoriteApi
     * const favoriteApi = await prisma.favoriteApi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FavoriteApiFindFirstOrThrowArgs>(args?: SelectSubset<T, FavoriteApiFindFirstOrThrowArgs<ExtArgs>>): Prisma__FavoriteApiClient<$Result.GetResult<Prisma.$FavoriteApiPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more FavoriteApis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteApiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FavoriteApis
     * const favoriteApis = await prisma.favoriteApi.findMany()
     * 
     * // Get first 10 FavoriteApis
     * const favoriteApis = await prisma.favoriteApi.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const favoriteApiWithIdOnly = await prisma.favoriteApi.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FavoriteApiFindManyArgs>(args?: SelectSubset<T, FavoriteApiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoriteApiPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a FavoriteApi.
     * @param {FavoriteApiCreateArgs} args - Arguments to create a FavoriteApi.
     * @example
     * // Create one FavoriteApi
     * const FavoriteApi = await prisma.favoriteApi.create({
     *   data: {
     *     // ... data to create a FavoriteApi
     *   }
     * })
     * 
     */
    create<T extends FavoriteApiCreateArgs>(args: SelectSubset<T, FavoriteApiCreateArgs<ExtArgs>>): Prisma__FavoriteApiClient<$Result.GetResult<Prisma.$FavoriteApiPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many FavoriteApis.
     * @param {FavoriteApiCreateManyArgs} args - Arguments to create many FavoriteApis.
     * @example
     * // Create many FavoriteApis
     * const favoriteApi = await prisma.favoriteApi.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FavoriteApiCreateManyArgs>(args?: SelectSubset<T, FavoriteApiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FavoriteApis and returns the data saved in the database.
     * @param {FavoriteApiCreateManyAndReturnArgs} args - Arguments to create many FavoriteApis.
     * @example
     * // Create many FavoriteApis
     * const favoriteApi = await prisma.favoriteApi.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FavoriteApis and only return the `id`
     * const favoriteApiWithIdOnly = await prisma.favoriteApi.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FavoriteApiCreateManyAndReturnArgs>(args?: SelectSubset<T, FavoriteApiCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoriteApiPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a FavoriteApi.
     * @param {FavoriteApiDeleteArgs} args - Arguments to delete one FavoriteApi.
     * @example
     * // Delete one FavoriteApi
     * const FavoriteApi = await prisma.favoriteApi.delete({
     *   where: {
     *     // ... filter to delete one FavoriteApi
     *   }
     * })
     * 
     */
    delete<T extends FavoriteApiDeleteArgs>(args: SelectSubset<T, FavoriteApiDeleteArgs<ExtArgs>>): Prisma__FavoriteApiClient<$Result.GetResult<Prisma.$FavoriteApiPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one FavoriteApi.
     * @param {FavoriteApiUpdateArgs} args - Arguments to update one FavoriteApi.
     * @example
     * // Update one FavoriteApi
     * const favoriteApi = await prisma.favoriteApi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FavoriteApiUpdateArgs>(args: SelectSubset<T, FavoriteApiUpdateArgs<ExtArgs>>): Prisma__FavoriteApiClient<$Result.GetResult<Prisma.$FavoriteApiPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more FavoriteApis.
     * @param {FavoriteApiDeleteManyArgs} args - Arguments to filter FavoriteApis to delete.
     * @example
     * // Delete a few FavoriteApis
     * const { count } = await prisma.favoriteApi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FavoriteApiDeleteManyArgs>(args?: SelectSubset<T, FavoriteApiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FavoriteApis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteApiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FavoriteApis
     * const favoriteApi = await prisma.favoriteApi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FavoriteApiUpdateManyArgs>(args: SelectSubset<T, FavoriteApiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FavoriteApi.
     * @param {FavoriteApiUpsertArgs} args - Arguments to update or create a FavoriteApi.
     * @example
     * // Update or create a FavoriteApi
     * const favoriteApi = await prisma.favoriteApi.upsert({
     *   create: {
     *     // ... data to create a FavoriteApi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FavoriteApi we want to update
     *   }
     * })
     */
    upsert<T extends FavoriteApiUpsertArgs>(args: SelectSubset<T, FavoriteApiUpsertArgs<ExtArgs>>): Prisma__FavoriteApiClient<$Result.GetResult<Prisma.$FavoriteApiPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of FavoriteApis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteApiCountArgs} args - Arguments to filter FavoriteApis to count.
     * @example
     * // Count the number of FavoriteApis
     * const count = await prisma.favoriteApi.count({
     *   where: {
     *     // ... the filter for the FavoriteApis we want to count
     *   }
     * })
    **/
    count<T extends FavoriteApiCountArgs>(
      args?: Subset<T, FavoriteApiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FavoriteApiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FavoriteApi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteApiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FavoriteApiAggregateArgs>(args: Subset<T, FavoriteApiAggregateArgs>): Prisma.PrismaPromise<GetFavoriteApiAggregateType<T>>

    /**
     * Group by FavoriteApi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteApiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FavoriteApiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FavoriteApiGroupByArgs['orderBy'] }
        : { orderBy?: FavoriteApiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FavoriteApiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFavoriteApiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FavoriteApi model
   */
  readonly fields: FavoriteApiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FavoriteApi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FavoriteApiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FavoriteApi model
   */ 
  interface FavoriteApiFieldRefs {
    readonly id: FieldRef<"FavoriteApi", 'Int'>
    readonly userId: FieldRef<"FavoriteApi", 'Int'>
    readonly symbol: FieldRef<"FavoriteApi", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FavoriteApi findUnique
   */
  export type FavoriteApiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteApi
     */
    select?: FavoriteApiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteApi
     */
    omit?: FavoriteApiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteApiInclude<ExtArgs> | null
    /**
     * Filter, which FavoriteApi to fetch.
     */
    where: FavoriteApiWhereUniqueInput
  }

  /**
   * FavoriteApi findUniqueOrThrow
   */
  export type FavoriteApiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteApi
     */
    select?: FavoriteApiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteApi
     */
    omit?: FavoriteApiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteApiInclude<ExtArgs> | null
    /**
     * Filter, which FavoriteApi to fetch.
     */
    where: FavoriteApiWhereUniqueInput
  }

  /**
   * FavoriteApi findFirst
   */
  export type FavoriteApiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteApi
     */
    select?: FavoriteApiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteApi
     */
    omit?: FavoriteApiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteApiInclude<ExtArgs> | null
    /**
     * Filter, which FavoriteApi to fetch.
     */
    where?: FavoriteApiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FavoriteApis to fetch.
     */
    orderBy?: FavoriteApiOrderByWithRelationInput | FavoriteApiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FavoriteApis.
     */
    cursor?: FavoriteApiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FavoriteApis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FavoriteApis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FavoriteApis.
     */
    distinct?: FavoriteApiScalarFieldEnum | FavoriteApiScalarFieldEnum[]
  }

  /**
   * FavoriteApi findFirstOrThrow
   */
  export type FavoriteApiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteApi
     */
    select?: FavoriteApiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteApi
     */
    omit?: FavoriteApiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteApiInclude<ExtArgs> | null
    /**
     * Filter, which FavoriteApi to fetch.
     */
    where?: FavoriteApiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FavoriteApis to fetch.
     */
    orderBy?: FavoriteApiOrderByWithRelationInput | FavoriteApiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FavoriteApis.
     */
    cursor?: FavoriteApiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FavoriteApis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FavoriteApis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FavoriteApis.
     */
    distinct?: FavoriteApiScalarFieldEnum | FavoriteApiScalarFieldEnum[]
  }

  /**
   * FavoriteApi findMany
   */
  export type FavoriteApiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteApi
     */
    select?: FavoriteApiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteApi
     */
    omit?: FavoriteApiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteApiInclude<ExtArgs> | null
    /**
     * Filter, which FavoriteApis to fetch.
     */
    where?: FavoriteApiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FavoriteApis to fetch.
     */
    orderBy?: FavoriteApiOrderByWithRelationInput | FavoriteApiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FavoriteApis.
     */
    cursor?: FavoriteApiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FavoriteApis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FavoriteApis.
     */
    skip?: number
    distinct?: FavoriteApiScalarFieldEnum | FavoriteApiScalarFieldEnum[]
  }

  /**
   * FavoriteApi create
   */
  export type FavoriteApiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteApi
     */
    select?: FavoriteApiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteApi
     */
    omit?: FavoriteApiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteApiInclude<ExtArgs> | null
    /**
     * The data needed to create a FavoriteApi.
     */
    data: XOR<FavoriteApiCreateInput, FavoriteApiUncheckedCreateInput>
  }

  /**
   * FavoriteApi createMany
   */
  export type FavoriteApiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FavoriteApis.
     */
    data: FavoriteApiCreateManyInput | FavoriteApiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FavoriteApi createManyAndReturn
   */
  export type FavoriteApiCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteApi
     */
    select?: FavoriteApiSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteApi
     */
    omit?: FavoriteApiOmit<ExtArgs> | null
    /**
     * The data used to create many FavoriteApis.
     */
    data: FavoriteApiCreateManyInput | FavoriteApiCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteApiIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FavoriteApi update
   */
  export type FavoriteApiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteApi
     */
    select?: FavoriteApiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteApi
     */
    omit?: FavoriteApiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteApiInclude<ExtArgs> | null
    /**
     * The data needed to update a FavoriteApi.
     */
    data: XOR<FavoriteApiUpdateInput, FavoriteApiUncheckedUpdateInput>
    /**
     * Choose, which FavoriteApi to update.
     */
    where: FavoriteApiWhereUniqueInput
  }

  /**
   * FavoriteApi updateMany
   */
  export type FavoriteApiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FavoriteApis.
     */
    data: XOR<FavoriteApiUpdateManyMutationInput, FavoriteApiUncheckedUpdateManyInput>
    /**
     * Filter which FavoriteApis to update
     */
    where?: FavoriteApiWhereInput
  }

  /**
   * FavoriteApi upsert
   */
  export type FavoriteApiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteApi
     */
    select?: FavoriteApiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteApi
     */
    omit?: FavoriteApiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteApiInclude<ExtArgs> | null
    /**
     * The filter to search for the FavoriteApi to update in case it exists.
     */
    where: FavoriteApiWhereUniqueInput
    /**
     * In case the FavoriteApi found by the `where` argument doesn't exist, create a new FavoriteApi with this data.
     */
    create: XOR<FavoriteApiCreateInput, FavoriteApiUncheckedCreateInput>
    /**
     * In case the FavoriteApi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FavoriteApiUpdateInput, FavoriteApiUncheckedUpdateInput>
  }

  /**
   * FavoriteApi delete
   */
  export type FavoriteApiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteApi
     */
    select?: FavoriteApiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteApi
     */
    omit?: FavoriteApiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteApiInclude<ExtArgs> | null
    /**
     * Filter which FavoriteApi to delete.
     */
    where: FavoriteApiWhereUniqueInput
  }

  /**
   * FavoriteApi deleteMany
   */
  export type FavoriteApiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FavoriteApis to delete
     */
    where?: FavoriteApiWhereInput
  }

  /**
   * FavoriteApi without action
   */
  export type FavoriteApiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteApi
     */
    select?: FavoriteApiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteApi
     */
    omit?: FavoriteApiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteApiInclude<ExtArgs> | null
  }


  /**
   * Model Goal
   */

  export type AggregateGoal = {
    _count: GoalCountAggregateOutputType | null
    _avg: GoalAvgAggregateOutputType | null
    _sum: GoalSumAggregateOutputType | null
    _min: GoalMinAggregateOutputType | null
    _max: GoalMaxAggregateOutputType | null
  }

  export type GoalAvgAggregateOutputType = {
    id: number | null
    amount: number | null
    userId: number | null
  }

  export type GoalSumAggregateOutputType = {
    id: number | null
    amount: number | null
    userId: number | null
  }

  export type GoalMinAggregateOutputType = {
    id: number | null
    title: string | null
    amount: number | null
    deadline: Date | null
    createdAt: Date | null
    description: string | null
    userId: number | null
  }

  export type GoalMaxAggregateOutputType = {
    id: number | null
    title: string | null
    amount: number | null
    deadline: Date | null
    createdAt: Date | null
    description: string | null
    userId: number | null
  }

  export type GoalCountAggregateOutputType = {
    id: number
    title: number
    amount: number
    deadline: number
    createdAt: number
    description: number
    userId: number
    _all: number
  }


  export type GoalAvgAggregateInputType = {
    id?: true
    amount?: true
    userId?: true
  }

  export type GoalSumAggregateInputType = {
    id?: true
    amount?: true
    userId?: true
  }

  export type GoalMinAggregateInputType = {
    id?: true
    title?: true
    amount?: true
    deadline?: true
    createdAt?: true
    description?: true
    userId?: true
  }

  export type GoalMaxAggregateInputType = {
    id?: true
    title?: true
    amount?: true
    deadline?: true
    createdAt?: true
    description?: true
    userId?: true
  }

  export type GoalCountAggregateInputType = {
    id?: true
    title?: true
    amount?: true
    deadline?: true
    createdAt?: true
    description?: true
    userId?: true
    _all?: true
  }

  export type GoalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Goal to aggregate.
     */
    where?: GoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goals to fetch.
     */
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Goals
    **/
    _count?: true | GoalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GoalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GoalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GoalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GoalMaxAggregateInputType
  }

  export type GetGoalAggregateType<T extends GoalAggregateArgs> = {
        [P in keyof T & keyof AggregateGoal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGoal[P]>
      : GetScalarType<T[P], AggregateGoal[P]>
  }




  export type GoalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GoalWhereInput
    orderBy?: GoalOrderByWithAggregationInput | GoalOrderByWithAggregationInput[]
    by: GoalScalarFieldEnum[] | GoalScalarFieldEnum
    having?: GoalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GoalCountAggregateInputType | true
    _avg?: GoalAvgAggregateInputType
    _sum?: GoalSumAggregateInputType
    _min?: GoalMinAggregateInputType
    _max?: GoalMaxAggregateInputType
  }

  export type GoalGroupByOutputType = {
    id: number
    title: string
    amount: number
    deadline: Date
    createdAt: Date
    description: string | null
    userId: number
    _count: GoalCountAggregateOutputType | null
    _avg: GoalAvgAggregateOutputType | null
    _sum: GoalSumAggregateOutputType | null
    _min: GoalMinAggregateOutputType | null
    _max: GoalMaxAggregateOutputType | null
  }

  type GetGoalGroupByPayload<T extends GoalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GoalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GoalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GoalGroupByOutputType[P]>
            : GetScalarType<T[P], GoalGroupByOutputType[P]>
        }
      >
    >


  export type GoalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    amount?: boolean
    deadline?: boolean
    createdAt?: boolean
    description?: boolean
    userId?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["goal"]>

  export type GoalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    amount?: boolean
    deadline?: boolean
    createdAt?: boolean
    description?: boolean
    userId?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["goal"]>


  export type GoalSelectScalar = {
    id?: boolean
    title?: boolean
    amount?: boolean
    deadline?: boolean
    createdAt?: boolean
    description?: boolean
    userId?: boolean
  }

  export type GoalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "amount" | "deadline" | "createdAt" | "description" | "userId", ExtArgs["result"]["goal"]>
  export type GoalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GoalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GoalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Goal"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      amount: number
      deadline: Date
      createdAt: Date
      description: string | null
      userId: number
    }, ExtArgs["result"]["goal"]>
    composites: {}
  }

  type GoalGetPayload<S extends boolean | null | undefined | GoalDefaultArgs> = $Result.GetResult<Prisma.$GoalPayload, S>

  type GoalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GoalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GoalCountAggregateInputType | true
    }

  export interface GoalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Goal'], meta: { name: 'Goal' } }
    /**
     * Find zero or one Goal that matches the filter.
     * @param {GoalFindUniqueArgs} args - Arguments to find a Goal
     * @example
     * // Get one Goal
     * const goal = await prisma.goal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GoalFindUniqueArgs>(args: SelectSubset<T, GoalFindUniqueArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Goal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GoalFindUniqueOrThrowArgs} args - Arguments to find a Goal
     * @example
     * // Get one Goal
     * const goal = await prisma.goal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GoalFindUniqueOrThrowArgs>(args: SelectSubset<T, GoalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Goal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalFindFirstArgs} args - Arguments to find a Goal
     * @example
     * // Get one Goal
     * const goal = await prisma.goal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GoalFindFirstArgs>(args?: SelectSubset<T, GoalFindFirstArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Goal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalFindFirstOrThrowArgs} args - Arguments to find a Goal
     * @example
     * // Get one Goal
     * const goal = await prisma.goal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GoalFindFirstOrThrowArgs>(args?: SelectSubset<T, GoalFindFirstOrThrowArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Goals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Goals
     * const goals = await prisma.goal.findMany()
     * 
     * // Get first 10 Goals
     * const goals = await prisma.goal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const goalWithIdOnly = await prisma.goal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GoalFindManyArgs>(args?: SelectSubset<T, GoalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Goal.
     * @param {GoalCreateArgs} args - Arguments to create a Goal.
     * @example
     * // Create one Goal
     * const Goal = await prisma.goal.create({
     *   data: {
     *     // ... data to create a Goal
     *   }
     * })
     * 
     */
    create<T extends GoalCreateArgs>(args: SelectSubset<T, GoalCreateArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Goals.
     * @param {GoalCreateManyArgs} args - Arguments to create many Goals.
     * @example
     * // Create many Goals
     * const goal = await prisma.goal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GoalCreateManyArgs>(args?: SelectSubset<T, GoalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Goals and returns the data saved in the database.
     * @param {GoalCreateManyAndReturnArgs} args - Arguments to create many Goals.
     * @example
     * // Create many Goals
     * const goal = await prisma.goal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Goals and only return the `id`
     * const goalWithIdOnly = await prisma.goal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GoalCreateManyAndReturnArgs>(args?: SelectSubset<T, GoalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Goal.
     * @param {GoalDeleteArgs} args - Arguments to delete one Goal.
     * @example
     * // Delete one Goal
     * const Goal = await prisma.goal.delete({
     *   where: {
     *     // ... filter to delete one Goal
     *   }
     * })
     * 
     */
    delete<T extends GoalDeleteArgs>(args: SelectSubset<T, GoalDeleteArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Goal.
     * @param {GoalUpdateArgs} args - Arguments to update one Goal.
     * @example
     * // Update one Goal
     * const goal = await prisma.goal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GoalUpdateArgs>(args: SelectSubset<T, GoalUpdateArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Goals.
     * @param {GoalDeleteManyArgs} args - Arguments to filter Goals to delete.
     * @example
     * // Delete a few Goals
     * const { count } = await prisma.goal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GoalDeleteManyArgs>(args?: SelectSubset<T, GoalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Goals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Goals
     * const goal = await prisma.goal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GoalUpdateManyArgs>(args: SelectSubset<T, GoalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Goal.
     * @param {GoalUpsertArgs} args - Arguments to update or create a Goal.
     * @example
     * // Update or create a Goal
     * const goal = await prisma.goal.upsert({
     *   create: {
     *     // ... data to create a Goal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Goal we want to update
     *   }
     * })
     */
    upsert<T extends GoalUpsertArgs>(args: SelectSubset<T, GoalUpsertArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Goals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalCountArgs} args - Arguments to filter Goals to count.
     * @example
     * // Count the number of Goals
     * const count = await prisma.goal.count({
     *   where: {
     *     // ... the filter for the Goals we want to count
     *   }
     * })
    **/
    count<T extends GoalCountArgs>(
      args?: Subset<T, GoalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GoalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Goal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GoalAggregateArgs>(args: Subset<T, GoalAggregateArgs>): Prisma.PrismaPromise<GetGoalAggregateType<T>>

    /**
     * Group by Goal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GoalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GoalGroupByArgs['orderBy'] }
        : { orderBy?: GoalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GoalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGoalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Goal model
   */
  readonly fields: GoalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Goal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GoalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Goal model
   */ 
  interface GoalFieldRefs {
    readonly id: FieldRef<"Goal", 'Int'>
    readonly title: FieldRef<"Goal", 'String'>
    readonly amount: FieldRef<"Goal", 'Float'>
    readonly deadline: FieldRef<"Goal", 'DateTime'>
    readonly createdAt: FieldRef<"Goal", 'DateTime'>
    readonly description: FieldRef<"Goal", 'String'>
    readonly userId: FieldRef<"Goal", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Goal findUnique
   */
  export type GoalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter, which Goal to fetch.
     */
    where: GoalWhereUniqueInput
  }

  /**
   * Goal findUniqueOrThrow
   */
  export type GoalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter, which Goal to fetch.
     */
    where: GoalWhereUniqueInput
  }

  /**
   * Goal findFirst
   */
  export type GoalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter, which Goal to fetch.
     */
    where?: GoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goals to fetch.
     */
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Goals.
     */
    cursor?: GoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Goals.
     */
    distinct?: GoalScalarFieldEnum | GoalScalarFieldEnum[]
  }

  /**
   * Goal findFirstOrThrow
   */
  export type GoalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter, which Goal to fetch.
     */
    where?: GoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goals to fetch.
     */
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Goals.
     */
    cursor?: GoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Goals.
     */
    distinct?: GoalScalarFieldEnum | GoalScalarFieldEnum[]
  }

  /**
   * Goal findMany
   */
  export type GoalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter, which Goals to fetch.
     */
    where?: GoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goals to fetch.
     */
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Goals.
     */
    cursor?: GoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goals.
     */
    skip?: number
    distinct?: GoalScalarFieldEnum | GoalScalarFieldEnum[]
  }

  /**
   * Goal create
   */
  export type GoalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * The data needed to create a Goal.
     */
    data: XOR<GoalCreateInput, GoalUncheckedCreateInput>
  }

  /**
   * Goal createMany
   */
  export type GoalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Goals.
     */
    data: GoalCreateManyInput | GoalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Goal createManyAndReturn
   */
  export type GoalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * The data used to create many Goals.
     */
    data: GoalCreateManyInput | GoalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Goal update
   */
  export type GoalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * The data needed to update a Goal.
     */
    data: XOR<GoalUpdateInput, GoalUncheckedUpdateInput>
    /**
     * Choose, which Goal to update.
     */
    where: GoalWhereUniqueInput
  }

  /**
   * Goal updateMany
   */
  export type GoalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Goals.
     */
    data: XOR<GoalUpdateManyMutationInput, GoalUncheckedUpdateManyInput>
    /**
     * Filter which Goals to update
     */
    where?: GoalWhereInput
  }

  /**
   * Goal upsert
   */
  export type GoalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * The filter to search for the Goal to update in case it exists.
     */
    where: GoalWhereUniqueInput
    /**
     * In case the Goal found by the `where` argument doesn't exist, create a new Goal with this data.
     */
    create: XOR<GoalCreateInput, GoalUncheckedCreateInput>
    /**
     * In case the Goal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GoalUpdateInput, GoalUncheckedUpdateInput>
  }

  /**
   * Goal delete
   */
  export type GoalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter which Goal to delete.
     */
    where: GoalWhereUniqueInput
  }

  /**
   * Goal deleteMany
   */
  export type GoalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Goals to delete
     */
    where?: GoalWhereInput
  }

  /**
   * Goal without action
   */
  export type GoalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
  }


  /**
   * Model RedeemBy
   */

  export type AggregateRedeemBy = {
    _count: RedeemByCountAggregateOutputType | null
    _avg: RedeemByAvgAggregateOutputType | null
    _sum: RedeemBySumAggregateOutputType | null
    _min: RedeemByMinAggregateOutputType | null
    _max: RedeemByMaxAggregateOutputType | null
  }

  export type RedeemByAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    rewardId: number | null
  }

  export type RedeemBySumAggregateOutputType = {
    id: number | null
    userId: number | null
    rewardId: number | null
  }

  export type RedeemByMinAggregateOutputType = {
    id: number | null
    userId: number | null
    dateOrdered: Date | null
    rewardId: number | null
    cardCode: string | null
  }

  export type RedeemByMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    dateOrdered: Date | null
    rewardId: number | null
    cardCode: string | null
  }

  export type RedeemByCountAggregateOutputType = {
    id: number
    userId: number
    dateOrdered: number
    rewardId: number
    cardCode: number
    _all: number
  }


  export type RedeemByAvgAggregateInputType = {
    id?: true
    userId?: true
    rewardId?: true
  }

  export type RedeemBySumAggregateInputType = {
    id?: true
    userId?: true
    rewardId?: true
  }

  export type RedeemByMinAggregateInputType = {
    id?: true
    userId?: true
    dateOrdered?: true
    rewardId?: true
    cardCode?: true
  }

  export type RedeemByMaxAggregateInputType = {
    id?: true
    userId?: true
    dateOrdered?: true
    rewardId?: true
    cardCode?: true
  }

  export type RedeemByCountAggregateInputType = {
    id?: true
    userId?: true
    dateOrdered?: true
    rewardId?: true
    cardCode?: true
    _all?: true
  }

  export type RedeemByAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RedeemBy to aggregate.
     */
    where?: RedeemByWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RedeemBies to fetch.
     */
    orderBy?: RedeemByOrderByWithRelationInput | RedeemByOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RedeemByWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RedeemBies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RedeemBies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RedeemBies
    **/
    _count?: true | RedeemByCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RedeemByAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RedeemBySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RedeemByMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RedeemByMaxAggregateInputType
  }

  export type GetRedeemByAggregateType<T extends RedeemByAggregateArgs> = {
        [P in keyof T & keyof AggregateRedeemBy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRedeemBy[P]>
      : GetScalarType<T[P], AggregateRedeemBy[P]>
  }




  export type RedeemByGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RedeemByWhereInput
    orderBy?: RedeemByOrderByWithAggregationInput | RedeemByOrderByWithAggregationInput[]
    by: RedeemByScalarFieldEnum[] | RedeemByScalarFieldEnum
    having?: RedeemByScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RedeemByCountAggregateInputType | true
    _avg?: RedeemByAvgAggregateInputType
    _sum?: RedeemBySumAggregateInputType
    _min?: RedeemByMinAggregateInputType
    _max?: RedeemByMaxAggregateInputType
  }

  export type RedeemByGroupByOutputType = {
    id: number
    userId: number
    dateOrdered: Date
    rewardId: number
    cardCode: string
    _count: RedeemByCountAggregateOutputType | null
    _avg: RedeemByAvgAggregateOutputType | null
    _sum: RedeemBySumAggregateOutputType | null
    _min: RedeemByMinAggregateOutputType | null
    _max: RedeemByMaxAggregateOutputType | null
  }

  type GetRedeemByGroupByPayload<T extends RedeemByGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RedeemByGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RedeemByGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RedeemByGroupByOutputType[P]>
            : GetScalarType<T[P], RedeemByGroupByOutputType[P]>
        }
      >
    >


  export type RedeemBySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dateOrdered?: boolean
    rewardId?: boolean
    cardCode?: boolean
    reward?: boolean | RewardDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["redeemBy"]>

  export type RedeemBySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dateOrdered?: boolean
    rewardId?: boolean
    cardCode?: boolean
    reward?: boolean | RewardDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["redeemBy"]>


  export type RedeemBySelectScalar = {
    id?: boolean
    userId?: boolean
    dateOrdered?: boolean
    rewardId?: boolean
    cardCode?: boolean
  }

  export type RedeemByOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "dateOrdered" | "rewardId" | "cardCode", ExtArgs["result"]["redeemBy"]>
  export type RedeemByInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reward?: boolean | RewardDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RedeemByIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reward?: boolean | RewardDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RedeemByPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RedeemBy"
    objects: {
      reward: Prisma.$RewardPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      dateOrdered: Date
      rewardId: number
      cardCode: string
    }, ExtArgs["result"]["redeemBy"]>
    composites: {}
  }

  type RedeemByGetPayload<S extends boolean | null | undefined | RedeemByDefaultArgs> = $Result.GetResult<Prisma.$RedeemByPayload, S>

  type RedeemByCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RedeemByFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RedeemByCountAggregateInputType | true
    }

  export interface RedeemByDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RedeemBy'], meta: { name: 'RedeemBy' } }
    /**
     * Find zero or one RedeemBy that matches the filter.
     * @param {RedeemByFindUniqueArgs} args - Arguments to find a RedeemBy
     * @example
     * // Get one RedeemBy
     * const redeemBy = await prisma.redeemBy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RedeemByFindUniqueArgs>(args: SelectSubset<T, RedeemByFindUniqueArgs<ExtArgs>>): Prisma__RedeemByClient<$Result.GetResult<Prisma.$RedeemByPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one RedeemBy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RedeemByFindUniqueOrThrowArgs} args - Arguments to find a RedeemBy
     * @example
     * // Get one RedeemBy
     * const redeemBy = await prisma.redeemBy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RedeemByFindUniqueOrThrowArgs>(args: SelectSubset<T, RedeemByFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RedeemByClient<$Result.GetResult<Prisma.$RedeemByPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first RedeemBy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedeemByFindFirstArgs} args - Arguments to find a RedeemBy
     * @example
     * // Get one RedeemBy
     * const redeemBy = await prisma.redeemBy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RedeemByFindFirstArgs>(args?: SelectSubset<T, RedeemByFindFirstArgs<ExtArgs>>): Prisma__RedeemByClient<$Result.GetResult<Prisma.$RedeemByPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first RedeemBy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedeemByFindFirstOrThrowArgs} args - Arguments to find a RedeemBy
     * @example
     * // Get one RedeemBy
     * const redeemBy = await prisma.redeemBy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RedeemByFindFirstOrThrowArgs>(args?: SelectSubset<T, RedeemByFindFirstOrThrowArgs<ExtArgs>>): Prisma__RedeemByClient<$Result.GetResult<Prisma.$RedeemByPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more RedeemBies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedeemByFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RedeemBies
     * const redeemBies = await prisma.redeemBy.findMany()
     * 
     * // Get first 10 RedeemBies
     * const redeemBies = await prisma.redeemBy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const redeemByWithIdOnly = await prisma.redeemBy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RedeemByFindManyArgs>(args?: SelectSubset<T, RedeemByFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RedeemByPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a RedeemBy.
     * @param {RedeemByCreateArgs} args - Arguments to create a RedeemBy.
     * @example
     * // Create one RedeemBy
     * const RedeemBy = await prisma.redeemBy.create({
     *   data: {
     *     // ... data to create a RedeemBy
     *   }
     * })
     * 
     */
    create<T extends RedeemByCreateArgs>(args: SelectSubset<T, RedeemByCreateArgs<ExtArgs>>): Prisma__RedeemByClient<$Result.GetResult<Prisma.$RedeemByPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many RedeemBies.
     * @param {RedeemByCreateManyArgs} args - Arguments to create many RedeemBies.
     * @example
     * // Create many RedeemBies
     * const redeemBy = await prisma.redeemBy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RedeemByCreateManyArgs>(args?: SelectSubset<T, RedeemByCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RedeemBies and returns the data saved in the database.
     * @param {RedeemByCreateManyAndReturnArgs} args - Arguments to create many RedeemBies.
     * @example
     * // Create many RedeemBies
     * const redeemBy = await prisma.redeemBy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RedeemBies and only return the `id`
     * const redeemByWithIdOnly = await prisma.redeemBy.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RedeemByCreateManyAndReturnArgs>(args?: SelectSubset<T, RedeemByCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RedeemByPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a RedeemBy.
     * @param {RedeemByDeleteArgs} args - Arguments to delete one RedeemBy.
     * @example
     * // Delete one RedeemBy
     * const RedeemBy = await prisma.redeemBy.delete({
     *   where: {
     *     // ... filter to delete one RedeemBy
     *   }
     * })
     * 
     */
    delete<T extends RedeemByDeleteArgs>(args: SelectSubset<T, RedeemByDeleteArgs<ExtArgs>>): Prisma__RedeemByClient<$Result.GetResult<Prisma.$RedeemByPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one RedeemBy.
     * @param {RedeemByUpdateArgs} args - Arguments to update one RedeemBy.
     * @example
     * // Update one RedeemBy
     * const redeemBy = await prisma.redeemBy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RedeemByUpdateArgs>(args: SelectSubset<T, RedeemByUpdateArgs<ExtArgs>>): Prisma__RedeemByClient<$Result.GetResult<Prisma.$RedeemByPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more RedeemBies.
     * @param {RedeemByDeleteManyArgs} args - Arguments to filter RedeemBies to delete.
     * @example
     * // Delete a few RedeemBies
     * const { count } = await prisma.redeemBy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RedeemByDeleteManyArgs>(args?: SelectSubset<T, RedeemByDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RedeemBies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedeemByUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RedeemBies
     * const redeemBy = await prisma.redeemBy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RedeemByUpdateManyArgs>(args: SelectSubset<T, RedeemByUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RedeemBy.
     * @param {RedeemByUpsertArgs} args - Arguments to update or create a RedeemBy.
     * @example
     * // Update or create a RedeemBy
     * const redeemBy = await prisma.redeemBy.upsert({
     *   create: {
     *     // ... data to create a RedeemBy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RedeemBy we want to update
     *   }
     * })
     */
    upsert<T extends RedeemByUpsertArgs>(args: SelectSubset<T, RedeemByUpsertArgs<ExtArgs>>): Prisma__RedeemByClient<$Result.GetResult<Prisma.$RedeemByPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of RedeemBies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedeemByCountArgs} args - Arguments to filter RedeemBies to count.
     * @example
     * // Count the number of RedeemBies
     * const count = await prisma.redeemBy.count({
     *   where: {
     *     // ... the filter for the RedeemBies we want to count
     *   }
     * })
    **/
    count<T extends RedeemByCountArgs>(
      args?: Subset<T, RedeemByCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RedeemByCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RedeemBy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedeemByAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RedeemByAggregateArgs>(args: Subset<T, RedeemByAggregateArgs>): Prisma.PrismaPromise<GetRedeemByAggregateType<T>>

    /**
     * Group by RedeemBy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedeemByGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RedeemByGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RedeemByGroupByArgs['orderBy'] }
        : { orderBy?: RedeemByGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RedeemByGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRedeemByGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RedeemBy model
   */
  readonly fields: RedeemByFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RedeemBy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RedeemByClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reward<T extends RewardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RewardDefaultArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RedeemBy model
   */ 
  interface RedeemByFieldRefs {
    readonly id: FieldRef<"RedeemBy", 'Int'>
    readonly userId: FieldRef<"RedeemBy", 'Int'>
    readonly dateOrdered: FieldRef<"RedeemBy", 'DateTime'>
    readonly rewardId: FieldRef<"RedeemBy", 'Int'>
    readonly cardCode: FieldRef<"RedeemBy", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RedeemBy findUnique
   */
  export type RedeemByFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemBy
     */
    select?: RedeemBySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemBy
     */
    omit?: RedeemByOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemByInclude<ExtArgs> | null
    /**
     * Filter, which RedeemBy to fetch.
     */
    where: RedeemByWhereUniqueInput
  }

  /**
   * RedeemBy findUniqueOrThrow
   */
  export type RedeemByFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemBy
     */
    select?: RedeemBySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemBy
     */
    omit?: RedeemByOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemByInclude<ExtArgs> | null
    /**
     * Filter, which RedeemBy to fetch.
     */
    where: RedeemByWhereUniqueInput
  }

  /**
   * RedeemBy findFirst
   */
  export type RedeemByFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemBy
     */
    select?: RedeemBySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemBy
     */
    omit?: RedeemByOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemByInclude<ExtArgs> | null
    /**
     * Filter, which RedeemBy to fetch.
     */
    where?: RedeemByWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RedeemBies to fetch.
     */
    orderBy?: RedeemByOrderByWithRelationInput | RedeemByOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RedeemBies.
     */
    cursor?: RedeemByWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RedeemBies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RedeemBies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RedeemBies.
     */
    distinct?: RedeemByScalarFieldEnum | RedeemByScalarFieldEnum[]
  }

  /**
   * RedeemBy findFirstOrThrow
   */
  export type RedeemByFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemBy
     */
    select?: RedeemBySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemBy
     */
    omit?: RedeemByOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemByInclude<ExtArgs> | null
    /**
     * Filter, which RedeemBy to fetch.
     */
    where?: RedeemByWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RedeemBies to fetch.
     */
    orderBy?: RedeemByOrderByWithRelationInput | RedeemByOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RedeemBies.
     */
    cursor?: RedeemByWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RedeemBies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RedeemBies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RedeemBies.
     */
    distinct?: RedeemByScalarFieldEnum | RedeemByScalarFieldEnum[]
  }

  /**
   * RedeemBy findMany
   */
  export type RedeemByFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemBy
     */
    select?: RedeemBySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemBy
     */
    omit?: RedeemByOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemByInclude<ExtArgs> | null
    /**
     * Filter, which RedeemBies to fetch.
     */
    where?: RedeemByWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RedeemBies to fetch.
     */
    orderBy?: RedeemByOrderByWithRelationInput | RedeemByOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RedeemBies.
     */
    cursor?: RedeemByWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RedeemBies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RedeemBies.
     */
    skip?: number
    distinct?: RedeemByScalarFieldEnum | RedeemByScalarFieldEnum[]
  }

  /**
   * RedeemBy create
   */
  export type RedeemByCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemBy
     */
    select?: RedeemBySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemBy
     */
    omit?: RedeemByOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemByInclude<ExtArgs> | null
    /**
     * The data needed to create a RedeemBy.
     */
    data: XOR<RedeemByCreateInput, RedeemByUncheckedCreateInput>
  }

  /**
   * RedeemBy createMany
   */
  export type RedeemByCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RedeemBies.
     */
    data: RedeemByCreateManyInput | RedeemByCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RedeemBy createManyAndReturn
   */
  export type RedeemByCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemBy
     */
    select?: RedeemBySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemBy
     */
    omit?: RedeemByOmit<ExtArgs> | null
    /**
     * The data used to create many RedeemBies.
     */
    data: RedeemByCreateManyInput | RedeemByCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemByIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RedeemBy update
   */
  export type RedeemByUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemBy
     */
    select?: RedeemBySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemBy
     */
    omit?: RedeemByOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemByInclude<ExtArgs> | null
    /**
     * The data needed to update a RedeemBy.
     */
    data: XOR<RedeemByUpdateInput, RedeemByUncheckedUpdateInput>
    /**
     * Choose, which RedeemBy to update.
     */
    where: RedeemByWhereUniqueInput
  }

  /**
   * RedeemBy updateMany
   */
  export type RedeemByUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RedeemBies.
     */
    data: XOR<RedeemByUpdateManyMutationInput, RedeemByUncheckedUpdateManyInput>
    /**
     * Filter which RedeemBies to update
     */
    where?: RedeemByWhereInput
  }

  /**
   * RedeemBy upsert
   */
  export type RedeemByUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemBy
     */
    select?: RedeemBySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemBy
     */
    omit?: RedeemByOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemByInclude<ExtArgs> | null
    /**
     * The filter to search for the RedeemBy to update in case it exists.
     */
    where: RedeemByWhereUniqueInput
    /**
     * In case the RedeemBy found by the `where` argument doesn't exist, create a new RedeemBy with this data.
     */
    create: XOR<RedeemByCreateInput, RedeemByUncheckedCreateInput>
    /**
     * In case the RedeemBy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RedeemByUpdateInput, RedeemByUncheckedUpdateInput>
  }

  /**
   * RedeemBy delete
   */
  export type RedeemByDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemBy
     */
    select?: RedeemBySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemBy
     */
    omit?: RedeemByOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemByInclude<ExtArgs> | null
    /**
     * Filter which RedeemBy to delete.
     */
    where: RedeemByWhereUniqueInput
  }

  /**
   * RedeemBy deleteMany
   */
  export type RedeemByDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RedeemBies to delete
     */
    where?: RedeemByWhereInput
  }

  /**
   * RedeemBy without action
   */
  export type RedeemByDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemBy
     */
    select?: RedeemBySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemBy
     */
    omit?: RedeemByOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemByInclude<ExtArgs> | null
  }


  /**
   * Model QuizQuestion
   */

  export type AggregateQuizQuestion = {
    _count: QuizQuestionCountAggregateOutputType | null
    _avg: QuizQuestionAvgAggregateOutputType | null
    _sum: QuizQuestionSumAggregateOutputType | null
    _min: QuizQuestionMinAggregateOutputType | null
    _max: QuizQuestionMaxAggregateOutputType | null
  }

  export type QuizQuestionAvgAggregateOutputType = {
    id: number | null
    correct_answer: number | null
  }

  export type QuizQuestionSumAggregateOutputType = {
    id: number | null
    correct_answer: number | null
  }

  export type QuizQuestionMinAggregateOutputType = {
    id: number | null
    question: string | null
    correct_answer: number | null
  }

  export type QuizQuestionMaxAggregateOutputType = {
    id: number | null
    question: string | null
    correct_answer: number | null
  }

  export type QuizQuestionCountAggregateOutputType = {
    id: number
    question: number
    options: number
    correct_answer: number
    _all: number
  }


  export type QuizQuestionAvgAggregateInputType = {
    id?: true
    correct_answer?: true
  }

  export type QuizQuestionSumAggregateInputType = {
    id?: true
    correct_answer?: true
  }

  export type QuizQuestionMinAggregateInputType = {
    id?: true
    question?: true
    correct_answer?: true
  }

  export type QuizQuestionMaxAggregateInputType = {
    id?: true
    question?: true
    correct_answer?: true
  }

  export type QuizQuestionCountAggregateInputType = {
    id?: true
    question?: true
    options?: true
    correct_answer?: true
    _all?: true
  }

  export type QuizQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizQuestion to aggregate.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizQuestions
    **/
    _count?: true | QuizQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizQuestionMaxAggregateInputType
  }

  export type GetQuizQuestionAggregateType<T extends QuizQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizQuestion[P]>
      : GetScalarType<T[P], AggregateQuizQuestion[P]>
  }




  export type QuizQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizQuestionWhereInput
    orderBy?: QuizQuestionOrderByWithAggregationInput | QuizQuestionOrderByWithAggregationInput[]
    by: QuizQuestionScalarFieldEnum[] | QuizQuestionScalarFieldEnum
    having?: QuizQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizQuestionCountAggregateInputType | true
    _avg?: QuizQuestionAvgAggregateInputType
    _sum?: QuizQuestionSumAggregateInputType
    _min?: QuizQuestionMinAggregateInputType
    _max?: QuizQuestionMaxAggregateInputType
  }

  export type QuizQuestionGroupByOutputType = {
    id: number
    question: string
    options: string[]
    correct_answer: number
    _count: QuizQuestionCountAggregateOutputType | null
    _avg: QuizQuestionAvgAggregateOutputType | null
    _sum: QuizQuestionSumAggregateOutputType | null
    _min: QuizQuestionMinAggregateOutputType | null
    _max: QuizQuestionMaxAggregateOutputType | null
  }

  type GetQuizQuestionGroupByPayload<T extends QuizQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], QuizQuestionGroupByOutputType[P]>
        }
      >
    >


  export type QuizQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    options?: boolean
    correct_answer?: boolean
  }, ExtArgs["result"]["quizQuestion"]>

  export type QuizQuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    options?: boolean
    correct_answer?: boolean
  }, ExtArgs["result"]["quizQuestion"]>


  export type QuizQuestionSelectScalar = {
    id?: boolean
    question?: boolean
    options?: boolean
    correct_answer?: boolean
  }

  export type QuizQuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "question" | "options" | "correct_answer", ExtArgs["result"]["quizQuestion"]>

  export type $QuizQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizQuestion"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      question: string
      options: string[]
      correct_answer: number
    }, ExtArgs["result"]["quizQuestion"]>
    composites: {}
  }

  type QuizQuestionGetPayload<S extends boolean | null | undefined | QuizQuestionDefaultArgs> = $Result.GetResult<Prisma.$QuizQuestionPayload, S>

  type QuizQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizQuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizQuestionCountAggregateInputType | true
    }

  export interface QuizQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizQuestion'], meta: { name: 'QuizQuestion' } }
    /**
     * Find zero or one QuizQuestion that matches the filter.
     * @param {QuizQuestionFindUniqueArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizQuestionFindUniqueArgs>(args: SelectSubset<T, QuizQuestionFindUniqueArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one QuizQuestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizQuestionFindUniqueOrThrowArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first QuizQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionFindFirstArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizQuestionFindFirstArgs>(args?: SelectSubset<T, QuizQuestionFindFirstArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first QuizQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionFindFirstOrThrowArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more QuizQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizQuestions
     * const quizQuestions = await prisma.quizQuestion.findMany()
     * 
     * // Get first 10 QuizQuestions
     * const quizQuestions = await prisma.quizQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizQuestionWithIdOnly = await prisma.quizQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizQuestionFindManyArgs>(args?: SelectSubset<T, QuizQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a QuizQuestion.
     * @param {QuizQuestionCreateArgs} args - Arguments to create a QuizQuestion.
     * @example
     * // Create one QuizQuestion
     * const QuizQuestion = await prisma.quizQuestion.create({
     *   data: {
     *     // ... data to create a QuizQuestion
     *   }
     * })
     * 
     */
    create<T extends QuizQuestionCreateArgs>(args: SelectSubset<T, QuizQuestionCreateArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many QuizQuestions.
     * @param {QuizQuestionCreateManyArgs} args - Arguments to create many QuizQuestions.
     * @example
     * // Create many QuizQuestions
     * const quizQuestion = await prisma.quizQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizQuestionCreateManyArgs>(args?: SelectSubset<T, QuizQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizQuestions and returns the data saved in the database.
     * @param {QuizQuestionCreateManyAndReturnArgs} args - Arguments to create many QuizQuestions.
     * @example
     * // Create many QuizQuestions
     * const quizQuestion = await prisma.quizQuestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizQuestions and only return the `id`
     * const quizQuestionWithIdOnly = await prisma.quizQuestion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizQuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizQuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a QuizQuestion.
     * @param {QuizQuestionDeleteArgs} args - Arguments to delete one QuizQuestion.
     * @example
     * // Delete one QuizQuestion
     * const QuizQuestion = await prisma.quizQuestion.delete({
     *   where: {
     *     // ... filter to delete one QuizQuestion
     *   }
     * })
     * 
     */
    delete<T extends QuizQuestionDeleteArgs>(args: SelectSubset<T, QuizQuestionDeleteArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one QuizQuestion.
     * @param {QuizQuestionUpdateArgs} args - Arguments to update one QuizQuestion.
     * @example
     * // Update one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizQuestionUpdateArgs>(args: SelectSubset<T, QuizQuestionUpdateArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more QuizQuestions.
     * @param {QuizQuestionDeleteManyArgs} args - Arguments to filter QuizQuestions to delete.
     * @example
     * // Delete a few QuizQuestions
     * const { count } = await prisma.quizQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizQuestionDeleteManyArgs>(args?: SelectSubset<T, QuizQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizQuestions
     * const quizQuestion = await prisma.quizQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizQuestionUpdateManyArgs>(args: SelectSubset<T, QuizQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuizQuestion.
     * @param {QuizQuestionUpsertArgs} args - Arguments to update or create a QuizQuestion.
     * @example
     * // Update or create a QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.upsert({
     *   create: {
     *     // ... data to create a QuizQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizQuestion we want to update
     *   }
     * })
     */
    upsert<T extends QuizQuestionUpsertArgs>(args: SelectSubset<T, QuizQuestionUpsertArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of QuizQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionCountArgs} args - Arguments to filter QuizQuestions to count.
     * @example
     * // Count the number of QuizQuestions
     * const count = await prisma.quizQuestion.count({
     *   where: {
     *     // ... the filter for the QuizQuestions we want to count
     *   }
     * })
    **/
    count<T extends QuizQuestionCountArgs>(
      args?: Subset<T, QuizQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizQuestionAggregateArgs>(args: Subset<T, QuizQuestionAggregateArgs>): Prisma.PrismaPromise<GetQuizQuestionAggregateType<T>>

    /**
     * Group by QuizQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizQuestionGroupByArgs['orderBy'] }
        : { orderBy?: QuizQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizQuestion model
   */
  readonly fields: QuizQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizQuestion model
   */ 
  interface QuizQuestionFieldRefs {
    readonly id: FieldRef<"QuizQuestion", 'Int'>
    readonly question: FieldRef<"QuizQuestion", 'String'>
    readonly options: FieldRef<"QuizQuestion", 'String[]'>
    readonly correct_answer: FieldRef<"QuizQuestion", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * QuizQuestion findUnique
   */
  export type QuizQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where: QuizQuestionWhereUniqueInput
  }

  /**
   * QuizQuestion findUniqueOrThrow
   */
  export type QuizQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where: QuizQuestionWhereUniqueInput
  }

  /**
   * QuizQuestion findFirst
   */
  export type QuizQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizQuestions.
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizQuestions.
     */
    distinct?: QuizQuestionScalarFieldEnum | QuizQuestionScalarFieldEnum[]
  }

  /**
   * QuizQuestion findFirstOrThrow
   */
  export type QuizQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizQuestions.
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizQuestions.
     */
    distinct?: QuizQuestionScalarFieldEnum | QuizQuestionScalarFieldEnum[]
  }

  /**
   * QuizQuestion findMany
   */
  export type QuizQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Filter, which QuizQuestions to fetch.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizQuestions.
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    distinct?: QuizQuestionScalarFieldEnum | QuizQuestionScalarFieldEnum[]
  }

  /**
   * QuizQuestion create
   */
  export type QuizQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * The data needed to create a QuizQuestion.
     */
    data: XOR<QuizQuestionCreateInput, QuizQuestionUncheckedCreateInput>
  }

  /**
   * QuizQuestion createMany
   */
  export type QuizQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizQuestions.
     */
    data: QuizQuestionCreateManyInput | QuizQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizQuestion createManyAndReturn
   */
  export type QuizQuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * The data used to create many QuizQuestions.
     */
    data: QuizQuestionCreateManyInput | QuizQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizQuestion update
   */
  export type QuizQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * The data needed to update a QuizQuestion.
     */
    data: XOR<QuizQuestionUpdateInput, QuizQuestionUncheckedUpdateInput>
    /**
     * Choose, which QuizQuestion to update.
     */
    where: QuizQuestionWhereUniqueInput
  }

  /**
   * QuizQuestion updateMany
   */
  export type QuizQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizQuestions.
     */
    data: XOR<QuizQuestionUpdateManyMutationInput, QuizQuestionUncheckedUpdateManyInput>
    /**
     * Filter which QuizQuestions to update
     */
    where?: QuizQuestionWhereInput
  }

  /**
   * QuizQuestion upsert
   */
  export type QuizQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * The filter to search for the QuizQuestion to update in case it exists.
     */
    where: QuizQuestionWhereUniqueInput
    /**
     * In case the QuizQuestion found by the `where` argument doesn't exist, create a new QuizQuestion with this data.
     */
    create: XOR<QuizQuestionCreateInput, QuizQuestionUncheckedCreateInput>
    /**
     * In case the QuizQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizQuestionUpdateInput, QuizQuestionUncheckedUpdateInput>
  }

  /**
   * QuizQuestion delete
   */
  export type QuizQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Filter which QuizQuestion to delete.
     */
    where: QuizQuestionWhereUniqueInput
  }

  /**
   * QuizQuestion deleteMany
   */
  export type QuizQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizQuestions to delete
     */
    where?: QuizQuestionWhereInput
  }

  /**
   * QuizQuestion without action
   */
  export type QuizQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
  }


  /**
   * Model Reward
   */

  export type AggregateReward = {
    _count: RewardCountAggregateOutputType | null
    _avg: RewardAvgAggregateOutputType | null
    _sum: RewardSumAggregateOutputType | null
    _min: RewardMinAggregateOutputType | null
    _max: RewardMaxAggregateOutputType | null
  }

  export type RewardAvgAggregateOutputType = {
    id: number | null
    cost: number | null
    probability: Decimal | null
  }

  export type RewardSumAggregateOutputType = {
    id: number | null
    cost: number | null
    probability: Decimal | null
  }

  export type RewardMinAggregateOutputType = {
    id: number | null
    rewardName: string | null
    rewardDescription: string | null
    cost: number | null
    probability: Decimal | null
  }

  export type RewardMaxAggregateOutputType = {
    id: number | null
    rewardName: string | null
    rewardDescription: string | null
    cost: number | null
    probability: Decimal | null
  }

  export type RewardCountAggregateOutputType = {
    id: number
    rewardName: number
    rewardDescription: number
    cost: number
    probability: number
    _all: number
  }


  export type RewardAvgAggregateInputType = {
    id?: true
    cost?: true
    probability?: true
  }

  export type RewardSumAggregateInputType = {
    id?: true
    cost?: true
    probability?: true
  }

  export type RewardMinAggregateInputType = {
    id?: true
    rewardName?: true
    rewardDescription?: true
    cost?: true
    probability?: true
  }

  export type RewardMaxAggregateInputType = {
    id?: true
    rewardName?: true
    rewardDescription?: true
    cost?: true
    probability?: true
  }

  export type RewardCountAggregateInputType = {
    id?: true
    rewardName?: true
    rewardDescription?: true
    cost?: true
    probability?: true
    _all?: true
  }

  export type RewardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reward to aggregate.
     */
    where?: RewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rewards to fetch.
     */
    orderBy?: RewardOrderByWithRelationInput | RewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rewards
    **/
    _count?: true | RewardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RewardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RewardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RewardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RewardMaxAggregateInputType
  }

  export type GetRewardAggregateType<T extends RewardAggregateArgs> = {
        [P in keyof T & keyof AggregateReward]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReward[P]>
      : GetScalarType<T[P], AggregateReward[P]>
  }




  export type RewardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RewardWhereInput
    orderBy?: RewardOrderByWithAggregationInput | RewardOrderByWithAggregationInput[]
    by: RewardScalarFieldEnum[] | RewardScalarFieldEnum
    having?: RewardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RewardCountAggregateInputType | true
    _avg?: RewardAvgAggregateInputType
    _sum?: RewardSumAggregateInputType
    _min?: RewardMinAggregateInputType
    _max?: RewardMaxAggregateInputType
  }

  export type RewardGroupByOutputType = {
    id: number
    rewardName: string
    rewardDescription: string
    cost: number
    probability: Decimal
    _count: RewardCountAggregateOutputType | null
    _avg: RewardAvgAggregateOutputType | null
    _sum: RewardSumAggregateOutputType | null
    _min: RewardMinAggregateOutputType | null
    _max: RewardMaxAggregateOutputType | null
  }

  type GetRewardGroupByPayload<T extends RewardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RewardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RewardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RewardGroupByOutputType[P]>
            : GetScalarType<T[P], RewardGroupByOutputType[P]>
        }
      >
    >


  export type RewardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rewardName?: boolean
    rewardDescription?: boolean
    cost?: boolean
    probability?: boolean
    redeemedBy?: boolean | Reward$redeemedByArgs<ExtArgs>
    _count?: boolean | RewardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reward"]>

  export type RewardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rewardName?: boolean
    rewardDescription?: boolean
    cost?: boolean
    probability?: boolean
  }, ExtArgs["result"]["reward"]>


  export type RewardSelectScalar = {
    id?: boolean
    rewardName?: boolean
    rewardDescription?: boolean
    cost?: boolean
    probability?: boolean
  }

  export type RewardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rewardName" | "rewardDescription" | "cost" | "probability", ExtArgs["result"]["reward"]>
  export type RewardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    redeemedBy?: boolean | Reward$redeemedByArgs<ExtArgs>
    _count?: boolean | RewardCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RewardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RewardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reward"
    objects: {
      redeemedBy: Prisma.$RedeemByPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      rewardName: string
      rewardDescription: string
      cost: number
      probability: Prisma.Decimal
    }, ExtArgs["result"]["reward"]>
    composites: {}
  }

  type RewardGetPayload<S extends boolean | null | undefined | RewardDefaultArgs> = $Result.GetResult<Prisma.$RewardPayload, S>

  type RewardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RewardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RewardCountAggregateInputType | true
    }

  export interface RewardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reward'], meta: { name: 'Reward' } }
    /**
     * Find zero or one Reward that matches the filter.
     * @param {RewardFindUniqueArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RewardFindUniqueArgs>(args: SelectSubset<T, RewardFindUniqueArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Reward that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RewardFindUniqueOrThrowArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RewardFindUniqueOrThrowArgs>(args: SelectSubset<T, RewardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Reward that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardFindFirstArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RewardFindFirstArgs>(args?: SelectSubset<T, RewardFindFirstArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Reward that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardFindFirstOrThrowArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RewardFindFirstOrThrowArgs>(args?: SelectSubset<T, RewardFindFirstOrThrowArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Rewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rewards
     * const rewards = await prisma.reward.findMany()
     * 
     * // Get first 10 Rewards
     * const rewards = await prisma.reward.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rewardWithIdOnly = await prisma.reward.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RewardFindManyArgs>(args?: SelectSubset<T, RewardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Reward.
     * @param {RewardCreateArgs} args - Arguments to create a Reward.
     * @example
     * // Create one Reward
     * const Reward = await prisma.reward.create({
     *   data: {
     *     // ... data to create a Reward
     *   }
     * })
     * 
     */
    create<T extends RewardCreateArgs>(args: SelectSubset<T, RewardCreateArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Rewards.
     * @param {RewardCreateManyArgs} args - Arguments to create many Rewards.
     * @example
     * // Create many Rewards
     * const reward = await prisma.reward.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RewardCreateManyArgs>(args?: SelectSubset<T, RewardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rewards and returns the data saved in the database.
     * @param {RewardCreateManyAndReturnArgs} args - Arguments to create many Rewards.
     * @example
     * // Create many Rewards
     * const reward = await prisma.reward.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rewards and only return the `id`
     * const rewardWithIdOnly = await prisma.reward.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RewardCreateManyAndReturnArgs>(args?: SelectSubset<T, RewardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Reward.
     * @param {RewardDeleteArgs} args - Arguments to delete one Reward.
     * @example
     * // Delete one Reward
     * const Reward = await prisma.reward.delete({
     *   where: {
     *     // ... filter to delete one Reward
     *   }
     * })
     * 
     */
    delete<T extends RewardDeleteArgs>(args: SelectSubset<T, RewardDeleteArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Reward.
     * @param {RewardUpdateArgs} args - Arguments to update one Reward.
     * @example
     * // Update one Reward
     * const reward = await prisma.reward.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RewardUpdateArgs>(args: SelectSubset<T, RewardUpdateArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Rewards.
     * @param {RewardDeleteManyArgs} args - Arguments to filter Rewards to delete.
     * @example
     * // Delete a few Rewards
     * const { count } = await prisma.reward.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RewardDeleteManyArgs>(args?: SelectSubset<T, RewardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rewards
     * const reward = await prisma.reward.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RewardUpdateManyArgs>(args: SelectSubset<T, RewardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reward.
     * @param {RewardUpsertArgs} args - Arguments to update or create a Reward.
     * @example
     * // Update or create a Reward
     * const reward = await prisma.reward.upsert({
     *   create: {
     *     // ... data to create a Reward
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reward we want to update
     *   }
     * })
     */
    upsert<T extends RewardUpsertArgs>(args: SelectSubset<T, RewardUpsertArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardCountArgs} args - Arguments to filter Rewards to count.
     * @example
     * // Count the number of Rewards
     * const count = await prisma.reward.count({
     *   where: {
     *     // ... the filter for the Rewards we want to count
     *   }
     * })
    **/
    count<T extends RewardCountArgs>(
      args?: Subset<T, RewardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RewardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RewardAggregateArgs>(args: Subset<T, RewardAggregateArgs>): Prisma.PrismaPromise<GetRewardAggregateType<T>>

    /**
     * Group by Reward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RewardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RewardGroupByArgs['orderBy'] }
        : { orderBy?: RewardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RewardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRewardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reward model
   */
  readonly fields: RewardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reward.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RewardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    redeemedBy<T extends Reward$redeemedByArgs<ExtArgs> = {}>(args?: Subset<T, Reward$redeemedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RedeemByPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reward model
   */ 
  interface RewardFieldRefs {
    readonly id: FieldRef<"Reward", 'Int'>
    readonly rewardName: FieldRef<"Reward", 'String'>
    readonly rewardDescription: FieldRef<"Reward", 'String'>
    readonly cost: FieldRef<"Reward", 'Int'>
    readonly probability: FieldRef<"Reward", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * Reward findUnique
   */
  export type RewardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * Filter, which Reward to fetch.
     */
    where: RewardWhereUniqueInput
  }

  /**
   * Reward findUniqueOrThrow
   */
  export type RewardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * Filter, which Reward to fetch.
     */
    where: RewardWhereUniqueInput
  }

  /**
   * Reward findFirst
   */
  export type RewardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * Filter, which Reward to fetch.
     */
    where?: RewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rewards to fetch.
     */
    orderBy?: RewardOrderByWithRelationInput | RewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rewards.
     */
    cursor?: RewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rewards.
     */
    distinct?: RewardScalarFieldEnum | RewardScalarFieldEnum[]
  }

  /**
   * Reward findFirstOrThrow
   */
  export type RewardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * Filter, which Reward to fetch.
     */
    where?: RewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rewards to fetch.
     */
    orderBy?: RewardOrderByWithRelationInput | RewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rewards.
     */
    cursor?: RewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rewards.
     */
    distinct?: RewardScalarFieldEnum | RewardScalarFieldEnum[]
  }

  /**
   * Reward findMany
   */
  export type RewardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * Filter, which Rewards to fetch.
     */
    where?: RewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rewards to fetch.
     */
    orderBy?: RewardOrderByWithRelationInput | RewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rewards.
     */
    cursor?: RewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rewards.
     */
    skip?: number
    distinct?: RewardScalarFieldEnum | RewardScalarFieldEnum[]
  }

  /**
   * Reward create
   */
  export type RewardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * The data needed to create a Reward.
     */
    data: XOR<RewardCreateInput, RewardUncheckedCreateInput>
  }

  /**
   * Reward createMany
   */
  export type RewardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rewards.
     */
    data: RewardCreateManyInput | RewardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reward createManyAndReturn
   */
  export type RewardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * The data used to create many Rewards.
     */
    data: RewardCreateManyInput | RewardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reward update
   */
  export type RewardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * The data needed to update a Reward.
     */
    data: XOR<RewardUpdateInput, RewardUncheckedUpdateInput>
    /**
     * Choose, which Reward to update.
     */
    where: RewardWhereUniqueInput
  }

  /**
   * Reward updateMany
   */
  export type RewardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rewards.
     */
    data: XOR<RewardUpdateManyMutationInput, RewardUncheckedUpdateManyInput>
    /**
     * Filter which Rewards to update
     */
    where?: RewardWhereInput
  }

  /**
   * Reward upsert
   */
  export type RewardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * The filter to search for the Reward to update in case it exists.
     */
    where: RewardWhereUniqueInput
    /**
     * In case the Reward found by the `where` argument doesn't exist, create a new Reward with this data.
     */
    create: XOR<RewardCreateInput, RewardUncheckedCreateInput>
    /**
     * In case the Reward was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RewardUpdateInput, RewardUncheckedUpdateInput>
  }

  /**
   * Reward delete
   */
  export type RewardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * Filter which Reward to delete.
     */
    where: RewardWhereUniqueInput
  }

  /**
   * Reward deleteMany
   */
  export type RewardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rewards to delete
     */
    where?: RewardWhereInput
  }

  /**
   * Reward.redeemedBy
   */
  export type Reward$redeemedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemBy
     */
    select?: RedeemBySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemBy
     */
    omit?: RedeemByOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemByInclude<ExtArgs> | null
    where?: RedeemByWhereInput
    orderBy?: RedeemByOrderByWithRelationInput | RedeemByOrderByWithRelationInput[]
    cursor?: RedeemByWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RedeemByScalarFieldEnum | RedeemByScalarFieldEnum[]
  }

  /**
   * Reward without action
   */
  export type RewardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TaskScalarFieldEnum: {
    id: 'id',
    name: 'name',
    statusId: 'statusId'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const StatusScalarFieldEnum: {
    id: 'id',
    text: 'text'
  };

  export type StatusScalarFieldEnum = (typeof StatusScalarFieldEnum)[keyof typeof StatusScalarFieldEnum]


  export const PersonScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    avatar: 'avatar'
  };

  export type PersonScalarFieldEnum = (typeof PersonScalarFieldEnum)[keyof typeof PersonScalarFieldEnum]


  export const TaskAssignmentScalarFieldEnum: {
    taskId: 'taskId',
    personId: 'personId',
    assignedAt: 'assignedAt'
  };

  export type TaskAssignmentScalarFieldEnum = (typeof TaskAssignmentScalarFieldEnum)[keyof typeof TaskAssignmentScalarFieldEnum]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    symbol: 'symbol',
    name: 'name',
    founded: 'founded',
    employees: 'employees',
    address: 'address',
    city: 'city',
    country: 'country',
    zipCode: 'zipCode',
    phone: 'phone',
    website: 'website',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const StockScalarFieldEnum: {
    stock_id: 'stock_id',
    symbol: 'symbol',
    sector: 'sector',
    company_id: 'company_id',
    change: 'change'
  };

  export type StockScalarFieldEnum = (typeof StockScalarFieldEnum)[keyof typeof StockScalarFieldEnum]


  export const FavoriteStockScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    stockId: 'stockId'
  };

  export type FavoriteStockScalarFieldEnum = (typeof FavoriteStockScalarFieldEnum)[keyof typeof FavoriteStockScalarFieldEnum]


  export const HistPriceScalarFieldEnum: {
    price_id: 'price_id',
    stock_id: 'stock_id',
    date: 'date',
    open_price: 'open_price',
    high_price: 'high_price',
    low_price: 'low_price',
    close_price: 'close_price',
    volume: 'volume'
  };

  export type HistPriceScalarFieldEnum = (typeof HistPriceScalarFieldEnum)[keyof typeof HistPriceScalarFieldEnum]


  export const LimitOrderScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    stockId: 'stockId',
    quantity: 'quantity',
    limitPrice: 'limitPrice',
    orderType: 'orderType',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LimitOrderScalarFieldEnum = (typeof LimitOrderScalarFieldEnum)[keyof typeof LimitOrderScalarFieldEnum]


  export const TradeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    stockId: 'stockId',
    quantity: 'quantity',
    price: 'price',
    totalAmount: 'totalAmount',
    tradeType: 'tradeType',
    tradeDate: 'tradeDate'
  };

  export type TradeScalarFieldEnum = (typeof TradeScalarFieldEnum)[keyof typeof TradeScalarFieldEnum]


  export const NewsScalarFieldEnum: {
    news_id: 'news_id',
    image_url: 'image_url',
    title: 'title',
    caption: 'caption',
    content: 'content',
    category: 'category',
    tags: 'tags'
  };

  export type NewsScalarFieldEnum = (typeof NewsScalarFieldEnum)[keyof typeof NewsScalarFieldEnum]


  export const BlogPostScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    title: 'title',
    content: 'content',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type BlogPostScalarFieldEnum = (typeof BlogPostScalarFieldEnum)[keyof typeof BlogPostScalarFieldEnum]


  export const BlogCommentScalarFieldEnum: {
    id: 'id',
    post_id: 'post_id',
    user_id: 'user_id',
    comment: 'comment',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type BlogCommentScalarFieldEnum = (typeof BlogCommentScalarFieldEnum)[keyof typeof BlogCommentScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    wallet: 'wallet',
    createdAt: 'createdAt',
    referredById: 'referredById',
    status: 'status',
    userReferralLink: 'userReferralLink',
    username: 'username',
    updatedAt: 'updatedAt',
    name: 'name',
    phoneNumber: 'phoneNumber'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ReferralScalarFieldEnum: {
    id: 'id',
    referralLink: 'referralLink',
    referralSignups: 'referralSignups',
    successfulReferrals: 'successfulReferrals',
    rewardsExchanged: 'rewardsExchanged',
    creditsEarned: 'creditsEarned',
    userId: 'userId',
    wallet: 'wallet'
  };

  export type ReferralScalarFieldEnum = (typeof ReferralScalarFieldEnum)[keyof typeof ReferralScalarFieldEnum]


  export const ReferralUsageScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    referralId: 'referralId',
    createdAt: 'createdAt'
  };

  export type ReferralUsageScalarFieldEnum = (typeof ReferralUsageScalarFieldEnum)[keyof typeof ReferralUsageScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    stockSymbol: 'stockSymbol',
    content: 'content',
    createdAt: 'createdAt',
    viewCount: 'viewCount'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const FavoriteApiScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    symbol: 'symbol'
  };

  export type FavoriteApiScalarFieldEnum = (typeof FavoriteApiScalarFieldEnum)[keyof typeof FavoriteApiScalarFieldEnum]


  export const GoalScalarFieldEnum: {
    id: 'id',
    title: 'title',
    amount: 'amount',
    deadline: 'deadline',
    createdAt: 'createdAt',
    description: 'description',
    userId: 'userId'
  };

  export type GoalScalarFieldEnum = (typeof GoalScalarFieldEnum)[keyof typeof GoalScalarFieldEnum]


  export const RedeemByScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    dateOrdered: 'dateOrdered',
    rewardId: 'rewardId',
    cardCode: 'cardCode'
  };

  export type RedeemByScalarFieldEnum = (typeof RedeemByScalarFieldEnum)[keyof typeof RedeemByScalarFieldEnum]


  export const QuizQuestionScalarFieldEnum: {
    id: 'id',
    question: 'question',
    options: 'options',
    correct_answer: 'correct_answer'
  };

  export type QuizQuestionScalarFieldEnum = (typeof QuizQuestionScalarFieldEnum)[keyof typeof QuizQuestionScalarFieldEnum]


  export const RewardScalarFieldEnum: {
    id: 'id',
    rewardName: 'rewardName',
    rewardDescription: 'rewardDescription',
    cost: 'cost',
    probability: 'probability'
  };

  export type RewardScalarFieldEnum = (typeof RewardScalarFieldEnum)[keyof typeof RewardScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: IntFilter<"Task"> | number
    name?: StringFilter<"Task"> | string
    statusId?: IntFilter<"Task"> | number
    status?: XOR<StatusRelationFilter, StatusWhereInput>
    persons?: TaskAssignmentListRelationFilter
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    statusId?: SortOrder
    status?: StatusOrderByWithRelationInput
    persons?: TaskAssignmentOrderByRelationAggregateInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    name?: StringFilter<"Task"> | string
    statusId?: IntFilter<"Task"> | number
    status?: XOR<StatusRelationFilter, StatusWhereInput>
    persons?: TaskAssignmentListRelationFilter
  }, "id">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    statusId?: SortOrder
    _count?: TaskCountOrderByAggregateInput
    _avg?: TaskAvgOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
    _sum?: TaskSumOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Task"> | number
    name?: StringWithAggregatesFilter<"Task"> | string
    statusId?: IntWithAggregatesFilter<"Task"> | number
  }

  export type StatusWhereInput = {
    AND?: StatusWhereInput | StatusWhereInput[]
    OR?: StatusWhereInput[]
    NOT?: StatusWhereInput | StatusWhereInput[]
    id?: IntFilter<"Status"> | number
    text?: StringFilter<"Status"> | string
    tasks?: TaskListRelationFilter
  }

  export type StatusOrderByWithRelationInput = {
    id?: SortOrder
    text?: SortOrder
    tasks?: TaskOrderByRelationAggregateInput
  }

  export type StatusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    text?: string
    AND?: StatusWhereInput | StatusWhereInput[]
    OR?: StatusWhereInput[]
    NOT?: StatusWhereInput | StatusWhereInput[]
    tasks?: TaskListRelationFilter
  }, "id" | "text">

  export type StatusOrderByWithAggregationInput = {
    id?: SortOrder
    text?: SortOrder
    _count?: StatusCountOrderByAggregateInput
    _avg?: StatusAvgOrderByAggregateInput
    _max?: StatusMaxOrderByAggregateInput
    _min?: StatusMinOrderByAggregateInput
    _sum?: StatusSumOrderByAggregateInput
  }

  export type StatusScalarWhereWithAggregatesInput = {
    AND?: StatusScalarWhereWithAggregatesInput | StatusScalarWhereWithAggregatesInput[]
    OR?: StatusScalarWhereWithAggregatesInput[]
    NOT?: StatusScalarWhereWithAggregatesInput | StatusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Status"> | number
    text?: StringWithAggregatesFilter<"Status"> | string
  }

  export type PersonWhereInput = {
    AND?: PersonWhereInput | PersonWhereInput[]
    OR?: PersonWhereInput[]
    NOT?: PersonWhereInput | PersonWhereInput[]
    id?: IntFilter<"Person"> | number
    email?: StringFilter<"Person"> | string
    name?: StringFilter<"Person"> | string
    avatar?: StringNullableFilter<"Person"> | string | null
    tasks?: TaskAssignmentListRelationFilter
  }

  export type PersonOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrderInput | SortOrder
    tasks?: TaskAssignmentOrderByRelationAggregateInput
  }

  export type PersonWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: PersonWhereInput | PersonWhereInput[]
    OR?: PersonWhereInput[]
    NOT?: PersonWhereInput | PersonWhereInput[]
    name?: StringFilter<"Person"> | string
    avatar?: StringNullableFilter<"Person"> | string | null
    tasks?: TaskAssignmentListRelationFilter
  }, "id" | "email">

  export type PersonOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrderInput | SortOrder
    _count?: PersonCountOrderByAggregateInput
    _avg?: PersonAvgOrderByAggregateInput
    _max?: PersonMaxOrderByAggregateInput
    _min?: PersonMinOrderByAggregateInput
    _sum?: PersonSumOrderByAggregateInput
  }

  export type PersonScalarWhereWithAggregatesInput = {
    AND?: PersonScalarWhereWithAggregatesInput | PersonScalarWhereWithAggregatesInput[]
    OR?: PersonScalarWhereWithAggregatesInput[]
    NOT?: PersonScalarWhereWithAggregatesInput | PersonScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Person"> | number
    email?: StringWithAggregatesFilter<"Person"> | string
    name?: StringWithAggregatesFilter<"Person"> | string
    avatar?: StringNullableWithAggregatesFilter<"Person"> | string | null
  }

  export type TaskAssignmentWhereInput = {
    AND?: TaskAssignmentWhereInput | TaskAssignmentWhereInput[]
    OR?: TaskAssignmentWhereInput[]
    NOT?: TaskAssignmentWhereInput | TaskAssignmentWhereInput[]
    taskId?: IntFilter<"TaskAssignment"> | number
    personId?: IntFilter<"TaskAssignment"> | number
    assignedAt?: DateTimeFilter<"TaskAssignment"> | Date | string
    person?: XOR<PersonRelationFilter, PersonWhereInput>
    task?: XOR<TaskRelationFilter, TaskWhereInput>
  }

  export type TaskAssignmentOrderByWithRelationInput = {
    taskId?: SortOrder
    personId?: SortOrder
    assignedAt?: SortOrder
    person?: PersonOrderByWithRelationInput
    task?: TaskOrderByWithRelationInput
  }

  export type TaskAssignmentWhereUniqueInput = Prisma.AtLeast<{
    assignmentId?: TaskAssignmentAssignmentIdCompoundUniqueInput
    AND?: TaskAssignmentWhereInput | TaskAssignmentWhereInput[]
    OR?: TaskAssignmentWhereInput[]
    NOT?: TaskAssignmentWhereInput | TaskAssignmentWhereInput[]
    taskId?: IntFilter<"TaskAssignment"> | number
    personId?: IntFilter<"TaskAssignment"> | number
    assignedAt?: DateTimeFilter<"TaskAssignment"> | Date | string
    person?: XOR<PersonRelationFilter, PersonWhereInput>
    task?: XOR<TaskRelationFilter, TaskWhereInput>
  }, "assignmentId">

  export type TaskAssignmentOrderByWithAggregationInput = {
    taskId?: SortOrder
    personId?: SortOrder
    assignedAt?: SortOrder
    _count?: TaskAssignmentCountOrderByAggregateInput
    _avg?: TaskAssignmentAvgOrderByAggregateInput
    _max?: TaskAssignmentMaxOrderByAggregateInput
    _min?: TaskAssignmentMinOrderByAggregateInput
    _sum?: TaskAssignmentSumOrderByAggregateInput
  }

  export type TaskAssignmentScalarWhereWithAggregatesInput = {
    AND?: TaskAssignmentScalarWhereWithAggregatesInput | TaskAssignmentScalarWhereWithAggregatesInput[]
    OR?: TaskAssignmentScalarWhereWithAggregatesInput[]
    NOT?: TaskAssignmentScalarWhereWithAggregatesInput | TaskAssignmentScalarWhereWithAggregatesInput[]
    taskId?: IntWithAggregatesFilter<"TaskAssignment"> | number
    personId?: IntWithAggregatesFilter<"TaskAssignment"> | number
    assignedAt?: DateTimeWithAggregatesFilter<"TaskAssignment"> | Date | string
  }

  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: IntFilter<"Company"> | number
    symbol?: StringFilter<"Company"> | string
    name?: StringFilter<"Company"> | string
    founded?: IntFilter<"Company"> | number
    employees?: IntFilter<"Company"> | number
    address?: StringFilter<"Company"> | string
    city?: StringFilter<"Company"> | string
    country?: StringFilter<"Company"> | string
    zipCode?: StringFilter<"Company"> | string
    phone?: StringFilter<"Company"> | string
    website?: StringFilter<"Company"> | string
    description?: StringFilter<"Company"> | string
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Company"> | Date | string | null
    stocks?: StockListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    founded?: SortOrder
    employees?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    zipCode?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    stocks?: StockOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    symbol?: string
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    name?: StringFilter<"Company"> | string
    founded?: IntFilter<"Company"> | number
    employees?: IntFilter<"Company"> | number
    address?: StringFilter<"Company"> | string
    city?: StringFilter<"Company"> | string
    country?: StringFilter<"Company"> | string
    zipCode?: StringFilter<"Company"> | string
    phone?: StringFilter<"Company"> | string
    website?: StringFilter<"Company"> | string
    description?: StringFilter<"Company"> | string
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Company"> | Date | string | null
    stocks?: StockListRelationFilter
  }, "id" | "symbol">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    founded?: SortOrder
    employees?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    zipCode?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _avg?: CompanyAvgOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
    _sum?: CompanySumOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Company"> | number
    symbol?: StringWithAggregatesFilter<"Company"> | string
    name?: StringWithAggregatesFilter<"Company"> | string
    founded?: IntWithAggregatesFilter<"Company"> | number
    employees?: IntWithAggregatesFilter<"Company"> | number
    address?: StringWithAggregatesFilter<"Company"> | string
    city?: StringWithAggregatesFilter<"Company"> | string
    country?: StringWithAggregatesFilter<"Company"> | string
    zipCode?: StringWithAggregatesFilter<"Company"> | string
    phone?: StringWithAggregatesFilter<"Company"> | string
    website?: StringWithAggregatesFilter<"Company"> | string
    description?: StringWithAggregatesFilter<"Company"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Company"> | Date | string | null
  }

  export type StockWhereInput = {
    AND?: StockWhereInput | StockWhereInput[]
    OR?: StockWhereInput[]
    NOT?: StockWhereInput | StockWhereInput[]
    stock_id?: IntFilter<"Stock"> | number
    symbol?: StringFilter<"Stock"> | string
    sector?: StringNullableFilter<"Stock"> | string | null
    company_id?: IntNullableFilter<"Stock"> | number | null
    change?: IntNullableFilter<"Stock"> | number | null
    favoriteStock?: FavoriteStockListRelationFilter
    hist_prices?: HistPriceListRelationFilter
    limitOrder?: LimitOrderListRelationFilter
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
    trading?: TradeListRelationFilter
  }

  export type StockOrderByWithRelationInput = {
    stock_id?: SortOrder
    symbol?: SortOrder
    sector?: SortOrderInput | SortOrder
    company_id?: SortOrderInput | SortOrder
    change?: SortOrderInput | SortOrder
    favoriteStock?: FavoriteStockOrderByRelationAggregateInput
    hist_prices?: HistPriceOrderByRelationAggregateInput
    limitOrder?: LimitOrderOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
    trading?: TradeOrderByRelationAggregateInput
  }

  export type StockWhereUniqueInput = Prisma.AtLeast<{
    stock_id?: number
    symbol?: string
    AND?: StockWhereInput | StockWhereInput[]
    OR?: StockWhereInput[]
    NOT?: StockWhereInput | StockWhereInput[]
    sector?: StringNullableFilter<"Stock"> | string | null
    company_id?: IntNullableFilter<"Stock"> | number | null
    change?: IntNullableFilter<"Stock"> | number | null
    favoriteStock?: FavoriteStockListRelationFilter
    hist_prices?: HistPriceListRelationFilter
    limitOrder?: LimitOrderListRelationFilter
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
    trading?: TradeListRelationFilter
  }, "stock_id" | "symbol">

  export type StockOrderByWithAggregationInput = {
    stock_id?: SortOrder
    symbol?: SortOrder
    sector?: SortOrderInput | SortOrder
    company_id?: SortOrderInput | SortOrder
    change?: SortOrderInput | SortOrder
    _count?: StockCountOrderByAggregateInput
    _avg?: StockAvgOrderByAggregateInput
    _max?: StockMaxOrderByAggregateInput
    _min?: StockMinOrderByAggregateInput
    _sum?: StockSumOrderByAggregateInput
  }

  export type StockScalarWhereWithAggregatesInput = {
    AND?: StockScalarWhereWithAggregatesInput | StockScalarWhereWithAggregatesInput[]
    OR?: StockScalarWhereWithAggregatesInput[]
    NOT?: StockScalarWhereWithAggregatesInput | StockScalarWhereWithAggregatesInput[]
    stock_id?: IntWithAggregatesFilter<"Stock"> | number
    symbol?: StringWithAggregatesFilter<"Stock"> | string
    sector?: StringNullableWithAggregatesFilter<"Stock"> | string | null
    company_id?: IntNullableWithAggregatesFilter<"Stock"> | number | null
    change?: IntNullableWithAggregatesFilter<"Stock"> | number | null
  }

  export type FavoriteStockWhereInput = {
    AND?: FavoriteStockWhereInput | FavoriteStockWhereInput[]
    OR?: FavoriteStockWhereInput[]
    NOT?: FavoriteStockWhereInput | FavoriteStockWhereInput[]
    id?: IntFilter<"FavoriteStock"> | number
    userId?: IntFilter<"FavoriteStock"> | number
    stockId?: IntFilter<"FavoriteStock"> | number
    stock?: XOR<StockRelationFilter, StockWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type FavoriteStockOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    stockId?: SortOrder
    stock?: StockOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type FavoriteStockWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_stockId?: FavoriteStockUserIdStockIdCompoundUniqueInput
    AND?: FavoriteStockWhereInput | FavoriteStockWhereInput[]
    OR?: FavoriteStockWhereInput[]
    NOT?: FavoriteStockWhereInput | FavoriteStockWhereInput[]
    userId?: IntFilter<"FavoriteStock"> | number
    stockId?: IntFilter<"FavoriteStock"> | number
    stock?: XOR<StockRelationFilter, StockWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_stockId">

  export type FavoriteStockOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    stockId?: SortOrder
    _count?: FavoriteStockCountOrderByAggregateInput
    _avg?: FavoriteStockAvgOrderByAggregateInput
    _max?: FavoriteStockMaxOrderByAggregateInput
    _min?: FavoriteStockMinOrderByAggregateInput
    _sum?: FavoriteStockSumOrderByAggregateInput
  }

  export type FavoriteStockScalarWhereWithAggregatesInput = {
    AND?: FavoriteStockScalarWhereWithAggregatesInput | FavoriteStockScalarWhereWithAggregatesInput[]
    OR?: FavoriteStockScalarWhereWithAggregatesInput[]
    NOT?: FavoriteStockScalarWhereWithAggregatesInput | FavoriteStockScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FavoriteStock"> | number
    userId?: IntWithAggregatesFilter<"FavoriteStock"> | number
    stockId?: IntWithAggregatesFilter<"FavoriteStock"> | number
  }

  export type HistPriceWhereInput = {
    AND?: HistPriceWhereInput | HistPriceWhereInput[]
    OR?: HistPriceWhereInput[]
    NOT?: HistPriceWhereInput | HistPriceWhereInput[]
    price_id?: IntFilter<"HistPrice"> | number
    stock_id?: IntFilter<"HistPrice"> | number
    date?: DateTimeFilter<"HistPrice"> | Date | string
    open_price?: DecimalNullableFilter<"HistPrice"> | Decimal | DecimalJsLike | number | string | null
    high_price?: DecimalNullableFilter<"HistPrice"> | Decimal | DecimalJsLike | number | string | null
    low_price?: DecimalNullableFilter<"HistPrice"> | Decimal | DecimalJsLike | number | string | null
    close_price?: DecimalFilter<"HistPrice"> | Decimal | DecimalJsLike | number | string
    volume?: BigIntNullableFilter<"HistPrice"> | bigint | number | null
    stock?: XOR<StockRelationFilter, StockWhereInput>
  }

  export type HistPriceOrderByWithRelationInput = {
    price_id?: SortOrder
    stock_id?: SortOrder
    date?: SortOrder
    open_price?: SortOrderInput | SortOrder
    high_price?: SortOrderInput | SortOrder
    low_price?: SortOrderInput | SortOrder
    close_price?: SortOrder
    volume?: SortOrderInput | SortOrder
    stock?: StockOrderByWithRelationInput
  }

  export type HistPriceWhereUniqueInput = Prisma.AtLeast<{
    price_id?: number
    stock_id_date?: HistPriceStock_idDateCompoundUniqueInput
    AND?: HistPriceWhereInput | HistPriceWhereInput[]
    OR?: HistPriceWhereInput[]
    NOT?: HistPriceWhereInput | HistPriceWhereInput[]
    stock_id?: IntFilter<"HistPrice"> | number
    date?: DateTimeFilter<"HistPrice"> | Date | string
    open_price?: DecimalNullableFilter<"HistPrice"> | Decimal | DecimalJsLike | number | string | null
    high_price?: DecimalNullableFilter<"HistPrice"> | Decimal | DecimalJsLike | number | string | null
    low_price?: DecimalNullableFilter<"HistPrice"> | Decimal | DecimalJsLike | number | string | null
    close_price?: DecimalFilter<"HistPrice"> | Decimal | DecimalJsLike | number | string
    volume?: BigIntNullableFilter<"HistPrice"> | bigint | number | null
    stock?: XOR<StockRelationFilter, StockWhereInput>
  }, "price_id" | "stock_id_date">

  export type HistPriceOrderByWithAggregationInput = {
    price_id?: SortOrder
    stock_id?: SortOrder
    date?: SortOrder
    open_price?: SortOrderInput | SortOrder
    high_price?: SortOrderInput | SortOrder
    low_price?: SortOrderInput | SortOrder
    close_price?: SortOrder
    volume?: SortOrderInput | SortOrder
    _count?: HistPriceCountOrderByAggregateInput
    _avg?: HistPriceAvgOrderByAggregateInput
    _max?: HistPriceMaxOrderByAggregateInput
    _min?: HistPriceMinOrderByAggregateInput
    _sum?: HistPriceSumOrderByAggregateInput
  }

  export type HistPriceScalarWhereWithAggregatesInput = {
    AND?: HistPriceScalarWhereWithAggregatesInput | HistPriceScalarWhereWithAggregatesInput[]
    OR?: HistPriceScalarWhereWithAggregatesInput[]
    NOT?: HistPriceScalarWhereWithAggregatesInput | HistPriceScalarWhereWithAggregatesInput[]
    price_id?: IntWithAggregatesFilter<"HistPrice"> | number
    stock_id?: IntWithAggregatesFilter<"HistPrice"> | number
    date?: DateTimeWithAggregatesFilter<"HistPrice"> | Date | string
    open_price?: DecimalNullableWithAggregatesFilter<"HistPrice"> | Decimal | DecimalJsLike | number | string | null
    high_price?: DecimalNullableWithAggregatesFilter<"HistPrice"> | Decimal | DecimalJsLike | number | string | null
    low_price?: DecimalNullableWithAggregatesFilter<"HistPrice"> | Decimal | DecimalJsLike | number | string | null
    close_price?: DecimalWithAggregatesFilter<"HistPrice"> | Decimal | DecimalJsLike | number | string
    volume?: BigIntNullableWithAggregatesFilter<"HistPrice"> | bigint | number | null
  }

  export type LimitOrderWhereInput = {
    AND?: LimitOrderWhereInput | LimitOrderWhereInput[]
    OR?: LimitOrderWhereInput[]
    NOT?: LimitOrderWhereInput | LimitOrderWhereInput[]
    id?: IntFilter<"LimitOrder"> | number
    userId?: IntFilter<"LimitOrder"> | number
    stockId?: IntFilter<"LimitOrder"> | number
    quantity?: IntFilter<"LimitOrder"> | number
    limitPrice?: DecimalFilter<"LimitOrder"> | Decimal | DecimalJsLike | number | string
    orderType?: StringFilter<"LimitOrder"> | string
    status?: StringFilter<"LimitOrder"> | string
    createdAt?: DateTimeFilter<"LimitOrder"> | Date | string
    updatedAt?: DateTimeFilter<"LimitOrder"> | Date | string
    stock?: XOR<StockRelationFilter, StockWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type LimitOrderOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    stockId?: SortOrder
    quantity?: SortOrder
    limitPrice?: SortOrder
    orderType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stock?: StockOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type LimitOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LimitOrderWhereInput | LimitOrderWhereInput[]
    OR?: LimitOrderWhereInput[]
    NOT?: LimitOrderWhereInput | LimitOrderWhereInput[]
    userId?: IntFilter<"LimitOrder"> | number
    stockId?: IntFilter<"LimitOrder"> | number
    quantity?: IntFilter<"LimitOrder"> | number
    limitPrice?: DecimalFilter<"LimitOrder"> | Decimal | DecimalJsLike | number | string
    orderType?: StringFilter<"LimitOrder"> | string
    status?: StringFilter<"LimitOrder"> | string
    createdAt?: DateTimeFilter<"LimitOrder"> | Date | string
    updatedAt?: DateTimeFilter<"LimitOrder"> | Date | string
    stock?: XOR<StockRelationFilter, StockWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type LimitOrderOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    stockId?: SortOrder
    quantity?: SortOrder
    limitPrice?: SortOrder
    orderType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LimitOrderCountOrderByAggregateInput
    _avg?: LimitOrderAvgOrderByAggregateInput
    _max?: LimitOrderMaxOrderByAggregateInput
    _min?: LimitOrderMinOrderByAggregateInput
    _sum?: LimitOrderSumOrderByAggregateInput
  }

  export type LimitOrderScalarWhereWithAggregatesInput = {
    AND?: LimitOrderScalarWhereWithAggregatesInput | LimitOrderScalarWhereWithAggregatesInput[]
    OR?: LimitOrderScalarWhereWithAggregatesInput[]
    NOT?: LimitOrderScalarWhereWithAggregatesInput | LimitOrderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LimitOrder"> | number
    userId?: IntWithAggregatesFilter<"LimitOrder"> | number
    stockId?: IntWithAggregatesFilter<"LimitOrder"> | number
    quantity?: IntWithAggregatesFilter<"LimitOrder"> | number
    limitPrice?: DecimalWithAggregatesFilter<"LimitOrder"> | Decimal | DecimalJsLike | number | string
    orderType?: StringWithAggregatesFilter<"LimitOrder"> | string
    status?: StringWithAggregatesFilter<"LimitOrder"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LimitOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LimitOrder"> | Date | string
  }

  export type TradeWhereInput = {
    AND?: TradeWhereInput | TradeWhereInput[]
    OR?: TradeWhereInput[]
    NOT?: TradeWhereInput | TradeWhereInput[]
    id?: IntFilter<"Trade"> | number
    userId?: IntNullableFilter<"Trade"> | number | null
    stockId?: IntFilter<"Trade"> | number
    quantity?: IntFilter<"Trade"> | number
    price?: DecimalFilter<"Trade"> | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFilter<"Trade"> | Decimal | DecimalJsLike | number | string
    tradeType?: StringFilter<"Trade"> | string
    tradeDate?: DateTimeFilter<"Trade"> | Date | string
    stock?: XOR<StockRelationFilter, StockWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type TradeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    stockId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    totalAmount?: SortOrder
    tradeType?: SortOrder
    tradeDate?: SortOrder
    stock?: StockOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TradeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TradeWhereInput | TradeWhereInput[]
    OR?: TradeWhereInput[]
    NOT?: TradeWhereInput | TradeWhereInput[]
    userId?: IntNullableFilter<"Trade"> | number | null
    stockId?: IntFilter<"Trade"> | number
    quantity?: IntFilter<"Trade"> | number
    price?: DecimalFilter<"Trade"> | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFilter<"Trade"> | Decimal | DecimalJsLike | number | string
    tradeType?: StringFilter<"Trade"> | string
    tradeDate?: DateTimeFilter<"Trade"> | Date | string
    stock?: XOR<StockRelationFilter, StockWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type TradeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    stockId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    totalAmount?: SortOrder
    tradeType?: SortOrder
    tradeDate?: SortOrder
    _count?: TradeCountOrderByAggregateInput
    _avg?: TradeAvgOrderByAggregateInput
    _max?: TradeMaxOrderByAggregateInput
    _min?: TradeMinOrderByAggregateInput
    _sum?: TradeSumOrderByAggregateInput
  }

  export type TradeScalarWhereWithAggregatesInput = {
    AND?: TradeScalarWhereWithAggregatesInput | TradeScalarWhereWithAggregatesInput[]
    OR?: TradeScalarWhereWithAggregatesInput[]
    NOT?: TradeScalarWhereWithAggregatesInput | TradeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Trade"> | number
    userId?: IntNullableWithAggregatesFilter<"Trade"> | number | null
    stockId?: IntWithAggregatesFilter<"Trade"> | number
    quantity?: IntWithAggregatesFilter<"Trade"> | number
    price?: DecimalWithAggregatesFilter<"Trade"> | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalWithAggregatesFilter<"Trade"> | Decimal | DecimalJsLike | number | string
    tradeType?: StringWithAggregatesFilter<"Trade"> | string
    tradeDate?: DateTimeWithAggregatesFilter<"Trade"> | Date | string
  }

  export type NewsWhereInput = {
    AND?: NewsWhereInput | NewsWhereInput[]
    OR?: NewsWhereInput[]
    NOT?: NewsWhereInput | NewsWhereInput[]
    news_id?: IntFilter<"News"> | number
    image_url?: StringFilter<"News"> | string
    title?: StringFilter<"News"> | string
    caption?: StringFilter<"News"> | string
    content?: StringFilter<"News"> | string
    category?: StringFilter<"News"> | string
    tags?: StringNullableListFilter<"News">
  }

  export type NewsOrderByWithRelationInput = {
    news_id?: SortOrder
    image_url?: SortOrder
    title?: SortOrder
    caption?: SortOrder
    content?: SortOrder
    category?: SortOrder
    tags?: SortOrder
  }

  export type NewsWhereUniqueInput = Prisma.AtLeast<{
    news_id?: number
    AND?: NewsWhereInput | NewsWhereInput[]
    OR?: NewsWhereInput[]
    NOT?: NewsWhereInput | NewsWhereInput[]
    image_url?: StringFilter<"News"> | string
    title?: StringFilter<"News"> | string
    caption?: StringFilter<"News"> | string
    content?: StringFilter<"News"> | string
    category?: StringFilter<"News"> | string
    tags?: StringNullableListFilter<"News">
  }, "news_id">

  export type NewsOrderByWithAggregationInput = {
    news_id?: SortOrder
    image_url?: SortOrder
    title?: SortOrder
    caption?: SortOrder
    content?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    _count?: NewsCountOrderByAggregateInput
    _avg?: NewsAvgOrderByAggregateInput
    _max?: NewsMaxOrderByAggregateInput
    _min?: NewsMinOrderByAggregateInput
    _sum?: NewsSumOrderByAggregateInput
  }

  export type NewsScalarWhereWithAggregatesInput = {
    AND?: NewsScalarWhereWithAggregatesInput | NewsScalarWhereWithAggregatesInput[]
    OR?: NewsScalarWhereWithAggregatesInput[]
    NOT?: NewsScalarWhereWithAggregatesInput | NewsScalarWhereWithAggregatesInput[]
    news_id?: IntWithAggregatesFilter<"News"> | number
    image_url?: StringWithAggregatesFilter<"News"> | string
    title?: StringWithAggregatesFilter<"News"> | string
    caption?: StringWithAggregatesFilter<"News"> | string
    content?: StringWithAggregatesFilter<"News"> | string
    category?: StringWithAggregatesFilter<"News"> | string
    tags?: StringNullableListFilter<"News">
  }

  export type BlogPostWhereInput = {
    AND?: BlogPostWhereInput | BlogPostWhereInput[]
    OR?: BlogPostWhereInput[]
    NOT?: BlogPostWhereInput | BlogPostWhereInput[]
    id?: IntFilter<"BlogPost"> | number
    user_id?: IntFilter<"BlogPost"> | number
    title?: StringFilter<"BlogPost"> | string
    content?: StringFilter<"BlogPost"> | string
    created_at?: DateTimeFilter<"BlogPost"> | Date | string
    updated_at?: DateTimeFilter<"BlogPost"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    BlogComment?: BlogCommentListRelationFilter
  }

  export type BlogPostOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: UserOrderByWithRelationInput
    BlogComment?: BlogCommentOrderByRelationAggregateInput
  }

  export type BlogPostWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BlogPostWhereInput | BlogPostWhereInput[]
    OR?: BlogPostWhereInput[]
    NOT?: BlogPostWhereInput | BlogPostWhereInput[]
    user_id?: IntFilter<"BlogPost"> | number
    title?: StringFilter<"BlogPost"> | string
    content?: StringFilter<"BlogPost"> | string
    created_at?: DateTimeFilter<"BlogPost"> | Date | string
    updated_at?: DateTimeFilter<"BlogPost"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    BlogComment?: BlogCommentListRelationFilter
  }, "id">

  export type BlogPostOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: BlogPostCountOrderByAggregateInput
    _avg?: BlogPostAvgOrderByAggregateInput
    _max?: BlogPostMaxOrderByAggregateInput
    _min?: BlogPostMinOrderByAggregateInput
    _sum?: BlogPostSumOrderByAggregateInput
  }

  export type BlogPostScalarWhereWithAggregatesInput = {
    AND?: BlogPostScalarWhereWithAggregatesInput | BlogPostScalarWhereWithAggregatesInput[]
    OR?: BlogPostScalarWhereWithAggregatesInput[]
    NOT?: BlogPostScalarWhereWithAggregatesInput | BlogPostScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BlogPost"> | number
    user_id?: IntWithAggregatesFilter<"BlogPost"> | number
    title?: StringWithAggregatesFilter<"BlogPost"> | string
    content?: StringWithAggregatesFilter<"BlogPost"> | string
    created_at?: DateTimeWithAggregatesFilter<"BlogPost"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"BlogPost"> | Date | string
  }

  export type BlogCommentWhereInput = {
    AND?: BlogCommentWhereInput | BlogCommentWhereInput[]
    OR?: BlogCommentWhereInput[]
    NOT?: BlogCommentWhereInput | BlogCommentWhereInput[]
    id?: IntFilter<"BlogComment"> | number
    post_id?: IntFilter<"BlogComment"> | number
    user_id?: IntFilter<"BlogComment"> | number
    comment?: StringFilter<"BlogComment"> | string
    created_at?: DateTimeFilter<"BlogComment"> | Date | string
    updated_at?: DateTimeFilter<"BlogComment"> | Date | string
    post?: XOR<BlogPostRelationFilter, BlogPostWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type BlogCommentOrderByWithRelationInput = {
    id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    post?: BlogPostOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type BlogCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BlogCommentWhereInput | BlogCommentWhereInput[]
    OR?: BlogCommentWhereInput[]
    NOT?: BlogCommentWhereInput | BlogCommentWhereInput[]
    post_id?: IntFilter<"BlogComment"> | number
    user_id?: IntFilter<"BlogComment"> | number
    comment?: StringFilter<"BlogComment"> | string
    created_at?: DateTimeFilter<"BlogComment"> | Date | string
    updated_at?: DateTimeFilter<"BlogComment"> | Date | string
    post?: XOR<BlogPostRelationFilter, BlogPostWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type BlogCommentOrderByWithAggregationInput = {
    id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: BlogCommentCountOrderByAggregateInput
    _avg?: BlogCommentAvgOrderByAggregateInput
    _max?: BlogCommentMaxOrderByAggregateInput
    _min?: BlogCommentMinOrderByAggregateInput
    _sum?: BlogCommentSumOrderByAggregateInput
  }

  export type BlogCommentScalarWhereWithAggregatesInput = {
    AND?: BlogCommentScalarWhereWithAggregatesInput | BlogCommentScalarWhereWithAggregatesInput[]
    OR?: BlogCommentScalarWhereWithAggregatesInput[]
    NOT?: BlogCommentScalarWhereWithAggregatesInput | BlogCommentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BlogComment"> | number
    post_id?: IntWithAggregatesFilter<"BlogComment"> | number
    user_id?: IntWithAggregatesFilter<"BlogComment"> | number
    comment?: StringWithAggregatesFilter<"BlogComment"> | string
    created_at?: DateTimeWithAggregatesFilter<"BlogComment"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"BlogComment"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    wallet?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    referredById?: IntNullableFilter<"User"> | number | null
    status?: StringFilter<"User"> | string
    userReferralLink?: StringNullableFilter<"User"> | string | null
    username?: StringFilter<"User"> | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    name?: StringNullableFilter<"User"> | string | null
    phoneNumber?: IntNullableFilter<"User"> | number | null
    BlogComment?: BlogCommentListRelationFilter
    BlogPost?: BlogPostListRelationFilter
    Comment?: CommentListRelationFilter
    FavoriteApi?: FavoriteApiListRelationFilter
    favoriteStocks?: FavoriteStockListRelationFilter
    Goal?: GoalListRelationFilter
    limitOrders?: LimitOrderListRelationFilter
    RedeemBy?: RedeemByListRelationFilter
    referrals?: ReferralListRelationFilter
    referralUsages?: ReferralUsageListRelationFilter
    trading?: TradeListRelationFilter
    referredBy?: XOR<ReferralNullableRelationFilter, ReferralWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    wallet?: SortOrder
    createdAt?: SortOrder
    referredById?: SortOrderInput | SortOrder
    status?: SortOrder
    userReferralLink?: SortOrderInput | SortOrder
    username?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    BlogComment?: BlogCommentOrderByRelationAggregateInput
    BlogPost?: BlogPostOrderByRelationAggregateInput
    Comment?: CommentOrderByRelationAggregateInput
    FavoriteApi?: FavoriteApiOrderByRelationAggregateInput
    favoriteStocks?: FavoriteStockOrderByRelationAggregateInput
    Goal?: GoalOrderByRelationAggregateInput
    limitOrders?: LimitOrderOrderByRelationAggregateInput
    RedeemBy?: RedeemByOrderByRelationAggregateInput
    referrals?: ReferralOrderByRelationAggregateInput
    referralUsages?: ReferralUsageOrderByRelationAggregateInput
    trading?: TradeOrderByRelationAggregateInput
    referredBy?: ReferralOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    userReferralLink?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    wallet?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    referredById?: IntNullableFilter<"User"> | number | null
    status?: StringFilter<"User"> | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    name?: StringNullableFilter<"User"> | string | null
    phoneNumber?: IntNullableFilter<"User"> | number | null
    BlogComment?: BlogCommentListRelationFilter
    BlogPost?: BlogPostListRelationFilter
    Comment?: CommentListRelationFilter
    FavoriteApi?: FavoriteApiListRelationFilter
    favoriteStocks?: FavoriteStockListRelationFilter
    Goal?: GoalListRelationFilter
    limitOrders?: LimitOrderListRelationFilter
    RedeemBy?: RedeemByListRelationFilter
    referrals?: ReferralListRelationFilter
    referralUsages?: ReferralUsageListRelationFilter
    trading?: TradeListRelationFilter
    referredBy?: XOR<ReferralNullableRelationFilter, ReferralWhereInput> | null
  }, "id" | "email" | "userReferralLink" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    wallet?: SortOrder
    createdAt?: SortOrder
    referredById?: SortOrderInput | SortOrder
    status?: SortOrder
    userReferralLink?: SortOrderInput | SortOrder
    username?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    wallet?: IntWithAggregatesFilter<"User"> | number
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    referredById?: IntNullableWithAggregatesFilter<"User"> | number | null
    status?: StringWithAggregatesFilter<"User"> | string
    userReferralLink?: StringNullableWithAggregatesFilter<"User"> | string | null
    username?: StringWithAggregatesFilter<"User"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    phoneNumber?: IntNullableWithAggregatesFilter<"User"> | number | null
  }

  export type ReferralWhereInput = {
    AND?: ReferralWhereInput | ReferralWhereInput[]
    OR?: ReferralWhereInput[]
    NOT?: ReferralWhereInput | ReferralWhereInput[]
    id?: IntFilter<"Referral"> | number
    referralLink?: StringFilter<"Referral"> | string
    referralSignups?: IntFilter<"Referral"> | number
    successfulReferrals?: IntFilter<"Referral"> | number
    rewardsExchanged?: IntFilter<"Referral"> | number
    creditsEarned?: IntFilter<"Referral"> | number
    userId?: IntNullableFilter<"Referral"> | number | null
    wallet?: IntFilter<"Referral"> | number
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    referralUsages?: ReferralUsageListRelationFilter
    referredUsers?: UserListRelationFilter
  }

  export type ReferralOrderByWithRelationInput = {
    id?: SortOrder
    referralLink?: SortOrder
    referralSignups?: SortOrder
    successfulReferrals?: SortOrder
    rewardsExchanged?: SortOrder
    creditsEarned?: SortOrder
    userId?: SortOrderInput | SortOrder
    wallet?: SortOrder
    user?: UserOrderByWithRelationInput
    referralUsages?: ReferralUsageOrderByRelationAggregateInput
    referredUsers?: UserOrderByRelationAggregateInput
  }

  export type ReferralWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    referralLink?: string
    AND?: ReferralWhereInput | ReferralWhereInput[]
    OR?: ReferralWhereInput[]
    NOT?: ReferralWhereInput | ReferralWhereInput[]
    referralSignups?: IntFilter<"Referral"> | number
    successfulReferrals?: IntFilter<"Referral"> | number
    rewardsExchanged?: IntFilter<"Referral"> | number
    creditsEarned?: IntFilter<"Referral"> | number
    userId?: IntNullableFilter<"Referral"> | number | null
    wallet?: IntFilter<"Referral"> | number
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    referralUsages?: ReferralUsageListRelationFilter
    referredUsers?: UserListRelationFilter
  }, "id" | "referralLink">

  export type ReferralOrderByWithAggregationInput = {
    id?: SortOrder
    referralLink?: SortOrder
    referralSignups?: SortOrder
    successfulReferrals?: SortOrder
    rewardsExchanged?: SortOrder
    creditsEarned?: SortOrder
    userId?: SortOrderInput | SortOrder
    wallet?: SortOrder
    _count?: ReferralCountOrderByAggregateInput
    _avg?: ReferralAvgOrderByAggregateInput
    _max?: ReferralMaxOrderByAggregateInput
    _min?: ReferralMinOrderByAggregateInput
    _sum?: ReferralSumOrderByAggregateInput
  }

  export type ReferralScalarWhereWithAggregatesInput = {
    AND?: ReferralScalarWhereWithAggregatesInput | ReferralScalarWhereWithAggregatesInput[]
    OR?: ReferralScalarWhereWithAggregatesInput[]
    NOT?: ReferralScalarWhereWithAggregatesInput | ReferralScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Referral"> | number
    referralLink?: StringWithAggregatesFilter<"Referral"> | string
    referralSignups?: IntWithAggregatesFilter<"Referral"> | number
    successfulReferrals?: IntWithAggregatesFilter<"Referral"> | number
    rewardsExchanged?: IntWithAggregatesFilter<"Referral"> | number
    creditsEarned?: IntWithAggregatesFilter<"Referral"> | number
    userId?: IntNullableWithAggregatesFilter<"Referral"> | number | null
    wallet?: IntWithAggregatesFilter<"Referral"> | number
  }

  export type ReferralUsageWhereInput = {
    AND?: ReferralUsageWhereInput | ReferralUsageWhereInput[]
    OR?: ReferralUsageWhereInput[]
    NOT?: ReferralUsageWhereInput | ReferralUsageWhereInput[]
    id?: IntFilter<"ReferralUsage"> | number
    userId?: IntNullableFilter<"ReferralUsage"> | number | null
    referralId?: IntNullableFilter<"ReferralUsage"> | number | null
    createdAt?: DateTimeFilter<"ReferralUsage"> | Date | string
    referral?: XOR<ReferralNullableRelationFilter, ReferralWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type ReferralUsageOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    referralId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    referral?: ReferralOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ReferralUsageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_referralId?: ReferralUsageUserIdReferralIdCompoundUniqueInput
    AND?: ReferralUsageWhereInput | ReferralUsageWhereInput[]
    OR?: ReferralUsageWhereInput[]
    NOT?: ReferralUsageWhereInput | ReferralUsageWhereInput[]
    userId?: IntNullableFilter<"ReferralUsage"> | number | null
    referralId?: IntNullableFilter<"ReferralUsage"> | number | null
    createdAt?: DateTimeFilter<"ReferralUsage"> | Date | string
    referral?: XOR<ReferralNullableRelationFilter, ReferralWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id" | "userId_referralId">

  export type ReferralUsageOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    referralId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ReferralUsageCountOrderByAggregateInput
    _avg?: ReferralUsageAvgOrderByAggregateInput
    _max?: ReferralUsageMaxOrderByAggregateInput
    _min?: ReferralUsageMinOrderByAggregateInput
    _sum?: ReferralUsageSumOrderByAggregateInput
  }

  export type ReferralUsageScalarWhereWithAggregatesInput = {
    AND?: ReferralUsageScalarWhereWithAggregatesInput | ReferralUsageScalarWhereWithAggregatesInput[]
    OR?: ReferralUsageScalarWhereWithAggregatesInput[]
    NOT?: ReferralUsageScalarWhereWithAggregatesInput | ReferralUsageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ReferralUsage"> | number
    userId?: IntNullableWithAggregatesFilter<"ReferralUsage"> | number | null
    referralId?: IntNullableWithAggregatesFilter<"ReferralUsage"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ReferralUsage"> | Date | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: IntFilter<"Comment"> | number
    userId?: IntFilter<"Comment"> | number
    stockSymbol?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    viewCount?: IntFilter<"Comment"> | number
    User?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    stockSymbol?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    viewCount?: SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    userId?: IntFilter<"Comment"> | number
    stockSymbol?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    viewCount?: IntFilter<"Comment"> | number
    User?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    stockSymbol?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    viewCount?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _avg?: CommentAvgOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
    _sum?: CommentSumOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Comment"> | number
    userId?: IntWithAggregatesFilter<"Comment"> | number
    stockSymbol?: StringWithAggregatesFilter<"Comment"> | string
    content?: StringWithAggregatesFilter<"Comment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    viewCount?: IntWithAggregatesFilter<"Comment"> | number
  }

  export type FavoriteApiWhereInput = {
    AND?: FavoriteApiWhereInput | FavoriteApiWhereInput[]
    OR?: FavoriteApiWhereInput[]
    NOT?: FavoriteApiWhereInput | FavoriteApiWhereInput[]
    id?: IntFilter<"FavoriteApi"> | number
    userId?: IntFilter<"FavoriteApi"> | number
    symbol?: StringFilter<"FavoriteApi"> | string
    User?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type FavoriteApiOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    symbol?: SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type FavoriteApiWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FavoriteApiWhereInput | FavoriteApiWhereInput[]
    OR?: FavoriteApiWhereInput[]
    NOT?: FavoriteApiWhereInput | FavoriteApiWhereInput[]
    userId?: IntFilter<"FavoriteApi"> | number
    symbol?: StringFilter<"FavoriteApi"> | string
    User?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type FavoriteApiOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    symbol?: SortOrder
    _count?: FavoriteApiCountOrderByAggregateInput
    _avg?: FavoriteApiAvgOrderByAggregateInput
    _max?: FavoriteApiMaxOrderByAggregateInput
    _min?: FavoriteApiMinOrderByAggregateInput
    _sum?: FavoriteApiSumOrderByAggregateInput
  }

  export type FavoriteApiScalarWhereWithAggregatesInput = {
    AND?: FavoriteApiScalarWhereWithAggregatesInput | FavoriteApiScalarWhereWithAggregatesInput[]
    OR?: FavoriteApiScalarWhereWithAggregatesInput[]
    NOT?: FavoriteApiScalarWhereWithAggregatesInput | FavoriteApiScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FavoriteApi"> | number
    userId?: IntWithAggregatesFilter<"FavoriteApi"> | number
    symbol?: StringWithAggregatesFilter<"FavoriteApi"> | string
  }

  export type GoalWhereInput = {
    AND?: GoalWhereInput | GoalWhereInput[]
    OR?: GoalWhereInput[]
    NOT?: GoalWhereInput | GoalWhereInput[]
    id?: IntFilter<"Goal"> | number
    title?: StringFilter<"Goal"> | string
    amount?: FloatFilter<"Goal"> | number
    deadline?: DateTimeFilter<"Goal"> | Date | string
    createdAt?: DateTimeFilter<"Goal"> | Date | string
    description?: StringNullableFilter<"Goal"> | string | null
    userId?: IntFilter<"Goal"> | number
    User?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type GoalOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    deadline?: SortOrder
    createdAt?: SortOrder
    description?: SortOrderInput | SortOrder
    userId?: SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type GoalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GoalWhereInput | GoalWhereInput[]
    OR?: GoalWhereInput[]
    NOT?: GoalWhereInput | GoalWhereInput[]
    title?: StringFilter<"Goal"> | string
    amount?: FloatFilter<"Goal"> | number
    deadline?: DateTimeFilter<"Goal"> | Date | string
    createdAt?: DateTimeFilter<"Goal"> | Date | string
    description?: StringNullableFilter<"Goal"> | string | null
    userId?: IntFilter<"Goal"> | number
    User?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type GoalOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    deadline?: SortOrder
    createdAt?: SortOrder
    description?: SortOrderInput | SortOrder
    userId?: SortOrder
    _count?: GoalCountOrderByAggregateInput
    _avg?: GoalAvgOrderByAggregateInput
    _max?: GoalMaxOrderByAggregateInput
    _min?: GoalMinOrderByAggregateInput
    _sum?: GoalSumOrderByAggregateInput
  }

  export type GoalScalarWhereWithAggregatesInput = {
    AND?: GoalScalarWhereWithAggregatesInput | GoalScalarWhereWithAggregatesInput[]
    OR?: GoalScalarWhereWithAggregatesInput[]
    NOT?: GoalScalarWhereWithAggregatesInput | GoalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Goal"> | number
    title?: StringWithAggregatesFilter<"Goal"> | string
    amount?: FloatWithAggregatesFilter<"Goal"> | number
    deadline?: DateTimeWithAggregatesFilter<"Goal"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Goal"> | Date | string
    description?: StringNullableWithAggregatesFilter<"Goal"> | string | null
    userId?: IntWithAggregatesFilter<"Goal"> | number
  }

  export type RedeemByWhereInput = {
    AND?: RedeemByWhereInput | RedeemByWhereInput[]
    OR?: RedeemByWhereInput[]
    NOT?: RedeemByWhereInput | RedeemByWhereInput[]
    id?: IntFilter<"RedeemBy"> | number
    userId?: IntFilter<"RedeemBy"> | number
    dateOrdered?: DateTimeFilter<"RedeemBy"> | Date | string
    rewardId?: IntFilter<"RedeemBy"> | number
    cardCode?: StringFilter<"RedeemBy"> | string
    reward?: XOR<RewardRelationFilter, RewardWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type RedeemByOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    dateOrdered?: SortOrder
    rewardId?: SortOrder
    cardCode?: SortOrder
    reward?: RewardOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type RedeemByWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RedeemByWhereInput | RedeemByWhereInput[]
    OR?: RedeemByWhereInput[]
    NOT?: RedeemByWhereInput | RedeemByWhereInput[]
    userId?: IntFilter<"RedeemBy"> | number
    dateOrdered?: DateTimeFilter<"RedeemBy"> | Date | string
    rewardId?: IntFilter<"RedeemBy"> | number
    cardCode?: StringFilter<"RedeemBy"> | string
    reward?: XOR<RewardRelationFilter, RewardWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type RedeemByOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    dateOrdered?: SortOrder
    rewardId?: SortOrder
    cardCode?: SortOrder
    _count?: RedeemByCountOrderByAggregateInput
    _avg?: RedeemByAvgOrderByAggregateInput
    _max?: RedeemByMaxOrderByAggregateInput
    _min?: RedeemByMinOrderByAggregateInput
    _sum?: RedeemBySumOrderByAggregateInput
  }

  export type RedeemByScalarWhereWithAggregatesInput = {
    AND?: RedeemByScalarWhereWithAggregatesInput | RedeemByScalarWhereWithAggregatesInput[]
    OR?: RedeemByScalarWhereWithAggregatesInput[]
    NOT?: RedeemByScalarWhereWithAggregatesInput | RedeemByScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RedeemBy"> | number
    userId?: IntWithAggregatesFilter<"RedeemBy"> | number
    dateOrdered?: DateTimeWithAggregatesFilter<"RedeemBy"> | Date | string
    rewardId?: IntWithAggregatesFilter<"RedeemBy"> | number
    cardCode?: StringWithAggregatesFilter<"RedeemBy"> | string
  }

  export type QuizQuestionWhereInput = {
    AND?: QuizQuestionWhereInput | QuizQuestionWhereInput[]
    OR?: QuizQuestionWhereInput[]
    NOT?: QuizQuestionWhereInput | QuizQuestionWhereInput[]
    id?: IntFilter<"QuizQuestion"> | number
    question?: StringFilter<"QuizQuestion"> | string
    options?: StringNullableListFilter<"QuizQuestion">
    correct_answer?: IntFilter<"QuizQuestion"> | number
  }

  export type QuizQuestionOrderByWithRelationInput = {
    id?: SortOrder
    question?: SortOrder
    options?: SortOrder
    correct_answer?: SortOrder
  }

  export type QuizQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QuizQuestionWhereInput | QuizQuestionWhereInput[]
    OR?: QuizQuestionWhereInput[]
    NOT?: QuizQuestionWhereInput | QuizQuestionWhereInput[]
    question?: StringFilter<"QuizQuestion"> | string
    options?: StringNullableListFilter<"QuizQuestion">
    correct_answer?: IntFilter<"QuizQuestion"> | number
  }, "id">

  export type QuizQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    question?: SortOrder
    options?: SortOrder
    correct_answer?: SortOrder
    _count?: QuizQuestionCountOrderByAggregateInput
    _avg?: QuizQuestionAvgOrderByAggregateInput
    _max?: QuizQuestionMaxOrderByAggregateInput
    _min?: QuizQuestionMinOrderByAggregateInput
    _sum?: QuizQuestionSumOrderByAggregateInput
  }

  export type QuizQuestionScalarWhereWithAggregatesInput = {
    AND?: QuizQuestionScalarWhereWithAggregatesInput | QuizQuestionScalarWhereWithAggregatesInput[]
    OR?: QuizQuestionScalarWhereWithAggregatesInput[]
    NOT?: QuizQuestionScalarWhereWithAggregatesInput | QuizQuestionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QuizQuestion"> | number
    question?: StringWithAggregatesFilter<"QuizQuestion"> | string
    options?: StringNullableListFilter<"QuizQuestion">
    correct_answer?: IntWithAggregatesFilter<"QuizQuestion"> | number
  }

  export type RewardWhereInput = {
    AND?: RewardWhereInput | RewardWhereInput[]
    OR?: RewardWhereInput[]
    NOT?: RewardWhereInput | RewardWhereInput[]
    id?: IntFilter<"Reward"> | number
    rewardName?: StringFilter<"Reward"> | string
    rewardDescription?: StringFilter<"Reward"> | string
    cost?: IntFilter<"Reward"> | number
    probability?: DecimalFilter<"Reward"> | Decimal | DecimalJsLike | number | string
    redeemedBy?: RedeemByListRelationFilter
  }

  export type RewardOrderByWithRelationInput = {
    id?: SortOrder
    rewardName?: SortOrder
    rewardDescription?: SortOrder
    cost?: SortOrder
    probability?: SortOrder
    redeemedBy?: RedeemByOrderByRelationAggregateInput
  }

  export type RewardWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RewardWhereInput | RewardWhereInput[]
    OR?: RewardWhereInput[]
    NOT?: RewardWhereInput | RewardWhereInput[]
    rewardName?: StringFilter<"Reward"> | string
    rewardDescription?: StringFilter<"Reward"> | string
    cost?: IntFilter<"Reward"> | number
    probability?: DecimalFilter<"Reward"> | Decimal | DecimalJsLike | number | string
    redeemedBy?: RedeemByListRelationFilter
  }, "id">

  export type RewardOrderByWithAggregationInput = {
    id?: SortOrder
    rewardName?: SortOrder
    rewardDescription?: SortOrder
    cost?: SortOrder
    probability?: SortOrder
    _count?: RewardCountOrderByAggregateInput
    _avg?: RewardAvgOrderByAggregateInput
    _max?: RewardMaxOrderByAggregateInput
    _min?: RewardMinOrderByAggregateInput
    _sum?: RewardSumOrderByAggregateInput
  }

  export type RewardScalarWhereWithAggregatesInput = {
    AND?: RewardScalarWhereWithAggregatesInput | RewardScalarWhereWithAggregatesInput[]
    OR?: RewardScalarWhereWithAggregatesInput[]
    NOT?: RewardScalarWhereWithAggregatesInput | RewardScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Reward"> | number
    rewardName?: StringWithAggregatesFilter<"Reward"> | string
    rewardDescription?: StringWithAggregatesFilter<"Reward"> | string
    cost?: IntWithAggregatesFilter<"Reward"> | number
    probability?: DecimalWithAggregatesFilter<"Reward"> | Decimal | DecimalJsLike | number | string
  }

  export type TaskCreateInput = {
    name: string
    status: StatusCreateNestedOneWithoutTasksInput
    persons?: TaskAssignmentCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateInput = {
    id?: number
    name: string
    statusId: number
    persons?: TaskAssignmentUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    status?: StatusUpdateOneRequiredWithoutTasksNestedInput
    persons?: TaskAssignmentUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    statusId?: IntFieldUpdateOperationsInput | number
    persons?: TaskAssignmentUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskCreateManyInput = {
    id?: number
    name: string
    statusId: number
  }

  export type TaskUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    statusId?: IntFieldUpdateOperationsInput | number
  }

  export type StatusCreateInput = {
    text: string
    tasks?: TaskCreateNestedManyWithoutStatusInput
  }

  export type StatusUncheckedCreateInput = {
    id?: number
    text: string
    tasks?: TaskUncheckedCreateNestedManyWithoutStatusInput
  }

  export type StatusUpdateInput = {
    text?: StringFieldUpdateOperationsInput | string
    tasks?: TaskUpdateManyWithoutStatusNestedInput
  }

  export type StatusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    tasks?: TaskUncheckedUpdateManyWithoutStatusNestedInput
  }

  export type StatusCreateManyInput = {
    id?: number
    text: string
  }

  export type StatusUpdateManyMutationInput = {
    text?: StringFieldUpdateOperationsInput | string
  }

  export type StatusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
  }

  export type PersonCreateInput = {
    email: string
    name: string
    avatar?: string | null
    tasks?: TaskAssignmentCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateInput = {
    id?: number
    email: string
    name: string
    avatar?: string | null
    tasks?: TaskAssignmentUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tasks?: TaskAssignmentUpdateManyWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tasks?: TaskAssignmentUncheckedUpdateManyWithoutPersonNestedInput
  }

  export type PersonCreateManyInput = {
    id?: number
    email: string
    name: string
    avatar?: string | null
  }

  export type PersonUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskAssignmentCreateInput = {
    assignedAt?: Date | string
    person: PersonCreateNestedOneWithoutTasksInput
    task: TaskCreateNestedOneWithoutPersonsInput
  }

  export type TaskAssignmentUncheckedCreateInput = {
    taskId: number
    personId: number
    assignedAt?: Date | string
  }

  export type TaskAssignmentUpdateInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    person?: PersonUpdateOneRequiredWithoutTasksNestedInput
    task?: TaskUpdateOneRequiredWithoutPersonsNestedInput
  }

  export type TaskAssignmentUncheckedUpdateInput = {
    taskId?: IntFieldUpdateOperationsInput | number
    personId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAssignmentCreateManyInput = {
    taskId: number
    personId: number
    assignedAt?: Date | string
  }

  export type TaskAssignmentUpdateManyMutationInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAssignmentUncheckedUpdateManyInput = {
    taskId?: IntFieldUpdateOperationsInput | number
    personId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCreateInput = {
    symbol: string
    name: string
    founded: number
    employees: number
    address: string
    city: string
    country: string
    zipCode: string
    phone: string
    website: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    stocks?: StockCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: number
    symbol: string
    name: string
    founded: number
    employees: number
    address: string
    city: string
    country: string
    zipCode: string
    phone: string
    website: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    stocks?: StockUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    founded?: IntFieldUpdateOperationsInput | number
    employees?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stocks?: StockUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    founded?: IntFieldUpdateOperationsInput | number
    employees?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stocks?: StockUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: number
    symbol: string
    name: string
    founded: number
    employees: number
    address: string
    city: string
    country: string
    zipCode: string
    phone: string
    website: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type CompanyUpdateManyMutationInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    founded?: IntFieldUpdateOperationsInput | number
    employees?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    founded?: IntFieldUpdateOperationsInput | number
    employees?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockCreateInput = {
    symbol: string
    sector?: string | null
    change?: number | null
    favoriteStock?: FavoriteStockCreateNestedManyWithoutStockInput
    hist_prices?: HistPriceCreateNestedManyWithoutStockInput
    limitOrder?: LimitOrderCreateNestedManyWithoutStockInput
    company?: CompanyCreateNestedOneWithoutStocksInput
    trading?: TradeCreateNestedManyWithoutStockInput
  }

  export type StockUncheckedCreateInput = {
    stock_id?: number
    symbol: string
    sector?: string | null
    company_id?: number | null
    change?: number | null
    favoriteStock?: FavoriteStockUncheckedCreateNestedManyWithoutStockInput
    hist_prices?: HistPriceUncheckedCreateNestedManyWithoutStockInput
    limitOrder?: LimitOrderUncheckedCreateNestedManyWithoutStockInput
    trading?: TradeUncheckedCreateNestedManyWithoutStockInput
  }

  export type StockUpdateInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    change?: NullableIntFieldUpdateOperationsInput | number | null
    favoriteStock?: FavoriteStockUpdateManyWithoutStockNestedInput
    hist_prices?: HistPriceUpdateManyWithoutStockNestedInput
    limitOrder?: LimitOrderUpdateManyWithoutStockNestedInput
    company?: CompanyUpdateOneWithoutStocksNestedInput
    trading?: TradeUpdateManyWithoutStockNestedInput
  }

  export type StockUncheckedUpdateInput = {
    stock_id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    change?: NullableIntFieldUpdateOperationsInput | number | null
    favoriteStock?: FavoriteStockUncheckedUpdateManyWithoutStockNestedInput
    hist_prices?: HistPriceUncheckedUpdateManyWithoutStockNestedInput
    limitOrder?: LimitOrderUncheckedUpdateManyWithoutStockNestedInput
    trading?: TradeUncheckedUpdateManyWithoutStockNestedInput
  }

  export type StockCreateManyInput = {
    stock_id?: number
    symbol: string
    sector?: string | null
    company_id?: number | null
    change?: number | null
  }

  export type StockUpdateManyMutationInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    change?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StockUncheckedUpdateManyInput = {
    stock_id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    change?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FavoriteStockCreateInput = {
    stock: StockCreateNestedOneWithoutFavoriteStockInput
    user: UserCreateNestedOneWithoutFavoriteStocksInput
  }

  export type FavoriteStockUncheckedCreateInput = {
    id?: number
    userId: number
    stockId: number
  }

  export type FavoriteStockUpdateInput = {
    stock?: StockUpdateOneRequiredWithoutFavoriteStockNestedInput
    user?: UserUpdateOneRequiredWithoutFavoriteStocksNestedInput
  }

  export type FavoriteStockUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    stockId?: IntFieldUpdateOperationsInput | number
  }

  export type FavoriteStockCreateManyInput = {
    id?: number
    userId: number
    stockId: number
  }

  export type FavoriteStockUpdateManyMutationInput = {

  }

  export type FavoriteStockUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    stockId?: IntFieldUpdateOperationsInput | number
  }

  export type HistPriceCreateInput = {
    date: Date | string
    open_price?: Decimal | DecimalJsLike | number | string | null
    high_price?: Decimal | DecimalJsLike | number | string | null
    low_price?: Decimal | DecimalJsLike | number | string | null
    close_price: Decimal | DecimalJsLike | number | string
    volume?: bigint | number | null
    stock: StockCreateNestedOneWithoutHist_pricesInput
  }

  export type HistPriceUncheckedCreateInput = {
    price_id?: number
    stock_id: number
    date: Date | string
    open_price?: Decimal | DecimalJsLike | number | string | null
    high_price?: Decimal | DecimalJsLike | number | string | null
    low_price?: Decimal | DecimalJsLike | number | string | null
    close_price: Decimal | DecimalJsLike | number | string
    volume?: bigint | number | null
  }

  export type HistPriceUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    open_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    high_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    low_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    volume?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    stock?: StockUpdateOneRequiredWithoutHist_pricesNestedInput
  }

  export type HistPriceUncheckedUpdateInput = {
    price_id?: IntFieldUpdateOperationsInput | number
    stock_id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    open_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    high_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    low_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    volume?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type HistPriceCreateManyInput = {
    price_id?: number
    stock_id: number
    date: Date | string
    open_price?: Decimal | DecimalJsLike | number | string | null
    high_price?: Decimal | DecimalJsLike | number | string | null
    low_price?: Decimal | DecimalJsLike | number | string | null
    close_price: Decimal | DecimalJsLike | number | string
    volume?: bigint | number | null
  }

  export type HistPriceUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    open_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    high_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    low_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    volume?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type HistPriceUncheckedUpdateManyInput = {
    price_id?: IntFieldUpdateOperationsInput | number
    stock_id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    open_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    high_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    low_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    volume?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type LimitOrderCreateInput = {
    quantity: number
    limitPrice: Decimal | DecimalJsLike | number | string
    orderType: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    stock: StockCreateNestedOneWithoutLimitOrderInput
    user: UserCreateNestedOneWithoutLimitOrdersInput
  }

  export type LimitOrderUncheckedCreateInput = {
    id?: number
    userId: number
    stockId: number
    quantity: number
    limitPrice: Decimal | DecimalJsLike | number | string
    orderType: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LimitOrderUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    limitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stock?: StockUpdateOneRequiredWithoutLimitOrderNestedInput
    user?: UserUpdateOneRequiredWithoutLimitOrdersNestedInput
  }

  export type LimitOrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    stockId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    limitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LimitOrderCreateManyInput = {
    id?: number
    userId: number
    stockId: number
    quantity: number
    limitPrice: Decimal | DecimalJsLike | number | string
    orderType: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LimitOrderUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    limitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LimitOrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    stockId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    limitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeCreateInput = {
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    tradeType: string
    tradeDate?: Date | string
    stock: StockCreateNestedOneWithoutTradingInput
    user?: UserCreateNestedOneWithoutTradingInput
  }

  export type TradeUncheckedCreateInput = {
    id?: number
    userId?: number | null
    stockId: number
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    tradeType: string
    tradeDate?: Date | string
  }

  export type TradeUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tradeType?: StringFieldUpdateOperationsInput | string
    tradeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    stock?: StockUpdateOneRequiredWithoutTradingNestedInput
    user?: UserUpdateOneWithoutTradingNestedInput
  }

  export type TradeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    stockId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tradeType?: StringFieldUpdateOperationsInput | string
    tradeDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeCreateManyInput = {
    id?: number
    userId?: number | null
    stockId: number
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    tradeType: string
    tradeDate?: Date | string
  }

  export type TradeUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tradeType?: StringFieldUpdateOperationsInput | string
    tradeDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    stockId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tradeType?: StringFieldUpdateOperationsInput | string
    tradeDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsCreateInput = {
    image_url: string
    title: string
    caption: string
    content: string
    category: string
    tags?: NewsCreatetagsInput | string[]
  }

  export type NewsUncheckedCreateInput = {
    news_id?: number
    image_url: string
    title: string
    caption: string
    content: string
    category: string
    tags?: NewsCreatetagsInput | string[]
  }

  export type NewsUpdateInput = {
    image_url?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    caption?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    tags?: NewsUpdatetagsInput | string[]
  }

  export type NewsUncheckedUpdateInput = {
    news_id?: IntFieldUpdateOperationsInput | number
    image_url?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    caption?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    tags?: NewsUpdatetagsInput | string[]
  }

  export type NewsCreateManyInput = {
    news_id?: number
    image_url: string
    title: string
    caption: string
    content: string
    category: string
    tags?: NewsCreatetagsInput | string[]
  }

  export type NewsUpdateManyMutationInput = {
    image_url?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    caption?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    tags?: NewsUpdatetagsInput | string[]
  }

  export type NewsUncheckedUpdateManyInput = {
    news_id?: IntFieldUpdateOperationsInput | number
    image_url?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    caption?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    tags?: NewsUpdatetagsInput | string[]
  }

  export type BlogPostCreateInput = {
    title: string
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutBlogPostInput
    BlogComment?: BlogCommentCreateNestedManyWithoutPostInput
  }

  export type BlogPostUncheckedCreateInput = {
    id?: number
    user_id: number
    title: string
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    BlogComment?: BlogCommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type BlogPostUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBlogPostNestedInput
    BlogComment?: BlogCommentUpdateManyWithoutPostNestedInput
  }

  export type BlogPostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    BlogComment?: BlogCommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type BlogPostCreateManyInput = {
    id?: number
    user_id: number
    title: string
    content: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BlogPostUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogCommentCreateInput = {
    comment: string
    created_at?: Date | string
    updated_at?: Date | string
    post: BlogPostCreateNestedOneWithoutBlogCommentInput
    user: UserCreateNestedOneWithoutBlogCommentInput
  }

  export type BlogCommentUncheckedCreateInput = {
    id?: number
    post_id: number
    user_id: number
    comment: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BlogCommentUpdateInput = {
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: BlogPostUpdateOneRequiredWithoutBlogCommentNestedInput
    user?: UserUpdateOneRequiredWithoutBlogCommentNestedInput
  }

  export type BlogCommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    post_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogCommentCreateManyInput = {
    id?: number
    post_id: number
    user_id: number
    comment: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BlogCommentUpdateManyMutationInput = {
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogCommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    post_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    email: string
    password: string
    wallet?: number
    createdAt?: Date | string
    status?: string
    userReferralLink?: string | null
    username: string
    updatedAt?: Date | string
    name?: string | null
    phoneNumber?: number | null
    BlogComment?: BlogCommentCreateNestedManyWithoutUserInput
    BlogPost?: BlogPostCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    FavoriteApi?: FavoriteApiCreateNestedManyWithoutUserInput
    favoriteStocks?: FavoriteStockCreateNestedManyWithoutUserInput
    Goal?: GoalCreateNestedManyWithoutUserInput
    limitOrders?: LimitOrderCreateNestedManyWithoutUserInput
    RedeemBy?: RedeemByCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutUserInput
    referralUsages?: ReferralUsageCreateNestedManyWithoutUserInput
    trading?: TradeCreateNestedManyWithoutUserInput
    referredBy?: ReferralCreateNestedOneWithoutReferredUsersInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    wallet?: number
    createdAt?: Date | string
    referredById?: number | null
    status?: string
    userReferralLink?: string | null
    username: string
    updatedAt?: Date | string
    name?: string | null
    phoneNumber?: number | null
    BlogComment?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    BlogPost?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    FavoriteApi?: FavoriteApiUncheckedCreateNestedManyWithoutUserInput
    favoriteStocks?: FavoriteStockUncheckedCreateNestedManyWithoutUserInput
    Goal?: GoalUncheckedCreateNestedManyWithoutUserInput
    limitOrders?: LimitOrderUncheckedCreateNestedManyWithoutUserInput
    RedeemBy?: RedeemByUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutUserInput
    referralUsages?: ReferralUsageUncheckedCreateNestedManyWithoutUserInput
    trading?: TradeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wallet?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    userReferralLink?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    BlogComment?: BlogCommentUpdateManyWithoutUserNestedInput
    BlogPost?: BlogPostUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    FavoriteApi?: FavoriteApiUpdateManyWithoutUserNestedInput
    favoriteStocks?: FavoriteStockUpdateManyWithoutUserNestedInput
    Goal?: GoalUpdateManyWithoutUserNestedInput
    limitOrders?: LimitOrderUpdateManyWithoutUserNestedInput
    RedeemBy?: RedeemByUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutUserNestedInput
    referralUsages?: ReferralUsageUpdateManyWithoutUserNestedInput
    trading?: TradeUpdateManyWithoutUserNestedInput
    referredBy?: ReferralUpdateOneWithoutReferredUsersNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wallet?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    userReferralLink?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    BlogComment?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    BlogPost?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    FavoriteApi?: FavoriteApiUncheckedUpdateManyWithoutUserNestedInput
    favoriteStocks?: FavoriteStockUncheckedUpdateManyWithoutUserNestedInput
    Goal?: GoalUncheckedUpdateManyWithoutUserNestedInput
    limitOrders?: LimitOrderUncheckedUpdateManyWithoutUserNestedInput
    RedeemBy?: RedeemByUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutUserNestedInput
    referralUsages?: ReferralUsageUncheckedUpdateManyWithoutUserNestedInput
    trading?: TradeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    password: string
    wallet?: number
    createdAt?: Date | string
    referredById?: number | null
    status?: string
    userReferralLink?: string | null
    username: string
    updatedAt?: Date | string
    name?: string | null
    phoneNumber?: number | null
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wallet?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    userReferralLink?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wallet?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    userReferralLink?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReferralCreateInput = {
    referralLink: string
    referralSignups?: number
    successfulReferrals?: number
    rewardsExchanged?: number
    creditsEarned?: number
    wallet?: number
    user?: UserCreateNestedOneWithoutReferralsInput
    referralUsages?: ReferralUsageCreateNestedManyWithoutReferralInput
    referredUsers?: UserCreateNestedManyWithoutReferredByInput
  }

  export type ReferralUncheckedCreateInput = {
    id?: number
    referralLink: string
    referralSignups?: number
    successfulReferrals?: number
    rewardsExchanged?: number
    creditsEarned?: number
    userId?: number | null
    wallet?: number
    referralUsages?: ReferralUsageUncheckedCreateNestedManyWithoutReferralInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferredByInput
  }

  export type ReferralUpdateInput = {
    referralLink?: StringFieldUpdateOperationsInput | string
    referralSignups?: IntFieldUpdateOperationsInput | number
    successfulReferrals?: IntFieldUpdateOperationsInput | number
    rewardsExchanged?: IntFieldUpdateOperationsInput | number
    creditsEarned?: IntFieldUpdateOperationsInput | number
    wallet?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneWithoutReferralsNestedInput
    referralUsages?: ReferralUsageUpdateManyWithoutReferralNestedInput
    referredUsers?: UserUpdateManyWithoutReferredByNestedInput
  }

  export type ReferralUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    referralLink?: StringFieldUpdateOperationsInput | string
    referralSignups?: IntFieldUpdateOperationsInput | number
    successfulReferrals?: IntFieldUpdateOperationsInput | number
    rewardsExchanged?: IntFieldUpdateOperationsInput | number
    creditsEarned?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    wallet?: IntFieldUpdateOperationsInput | number
    referralUsages?: ReferralUsageUncheckedUpdateManyWithoutReferralNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferredByNestedInput
  }

  export type ReferralCreateManyInput = {
    id?: number
    referralLink: string
    referralSignups?: number
    successfulReferrals?: number
    rewardsExchanged?: number
    creditsEarned?: number
    userId?: number | null
    wallet?: number
  }

  export type ReferralUpdateManyMutationInput = {
    referralLink?: StringFieldUpdateOperationsInput | string
    referralSignups?: IntFieldUpdateOperationsInput | number
    successfulReferrals?: IntFieldUpdateOperationsInput | number
    rewardsExchanged?: IntFieldUpdateOperationsInput | number
    creditsEarned?: IntFieldUpdateOperationsInput | number
    wallet?: IntFieldUpdateOperationsInput | number
  }

  export type ReferralUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    referralLink?: StringFieldUpdateOperationsInput | string
    referralSignups?: IntFieldUpdateOperationsInput | number
    successfulReferrals?: IntFieldUpdateOperationsInput | number
    rewardsExchanged?: IntFieldUpdateOperationsInput | number
    creditsEarned?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    wallet?: IntFieldUpdateOperationsInput | number
  }

  export type ReferralUsageCreateInput = {
    createdAt?: Date | string
    referral?: ReferralCreateNestedOneWithoutReferralUsagesInput
    user?: UserCreateNestedOneWithoutReferralUsagesInput
  }

  export type ReferralUsageUncheckedCreateInput = {
    id?: number
    userId?: number | null
    referralId?: number | null
    createdAt?: Date | string
  }

  export type ReferralUsageUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referral?: ReferralUpdateOneWithoutReferralUsagesNestedInput
    user?: UserUpdateOneWithoutReferralUsagesNestedInput
  }

  export type ReferralUsageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    referralId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUsageCreateManyInput = {
    id?: number
    userId?: number | null
    referralId?: number | null
    createdAt?: Date | string
  }

  export type ReferralUsageUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUsageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    referralId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    stockSymbol: string
    content: string
    createdAt?: Date | string
    viewCount?: number
    User: UserCreateNestedOneWithoutCommentInput
  }

  export type CommentUncheckedCreateInput = {
    id?: number
    userId: number
    stockSymbol: string
    content: string
    createdAt?: Date | string
    viewCount?: number
  }

  export type CommentUpdateInput = {
    stockSymbol?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewCount?: IntFieldUpdateOperationsInput | number
    User?: UserUpdateOneRequiredWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    stockSymbol?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewCount?: IntFieldUpdateOperationsInput | number
  }

  export type CommentCreateManyInput = {
    id?: number
    userId: number
    stockSymbol: string
    content: string
    createdAt?: Date | string
    viewCount?: number
  }

  export type CommentUpdateManyMutationInput = {
    stockSymbol?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewCount?: IntFieldUpdateOperationsInput | number
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    stockSymbol?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewCount?: IntFieldUpdateOperationsInput | number
  }

  export type FavoriteApiCreateInput = {
    symbol: string
    User: UserCreateNestedOneWithoutFavoriteApiInput
  }

  export type FavoriteApiUncheckedCreateInput = {
    id?: number
    userId: number
    symbol: string
  }

  export type FavoriteApiUpdateInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneRequiredWithoutFavoriteApiNestedInput
  }

  export type FavoriteApiUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
  }

  export type FavoriteApiCreateManyInput = {
    id?: number
    userId: number
    symbol: string
  }

  export type FavoriteApiUpdateManyMutationInput = {
    symbol?: StringFieldUpdateOperationsInput | string
  }

  export type FavoriteApiUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
  }

  export type GoalCreateInput = {
    title: string
    amount: number
    deadline: Date | string
    createdAt?: Date | string
    description?: string | null
    User: UserCreateNestedOneWithoutGoalInput
  }

  export type GoalUncheckedCreateInput = {
    id?: number
    title: string
    amount: number
    deadline: Date | string
    createdAt?: Date | string
    description?: string | null
    userId: number
  }

  export type GoalUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    User?: UserUpdateOneRequiredWithoutGoalNestedInput
  }

  export type GoalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type GoalCreateManyInput = {
    id?: number
    title: string
    amount: number
    deadline: Date | string
    createdAt?: Date | string
    description?: string | null
    userId: number
  }

  export type GoalUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GoalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type RedeemByCreateInput = {
    dateOrdered?: Date | string
    cardCode: string
    reward: RewardCreateNestedOneWithoutRedeemedByInput
    user: UserCreateNestedOneWithoutRedeemByInput
  }

  export type RedeemByUncheckedCreateInput = {
    id?: number
    userId: number
    dateOrdered?: Date | string
    rewardId: number
    cardCode: string
  }

  export type RedeemByUpdateInput = {
    dateOrdered?: DateTimeFieldUpdateOperationsInput | Date | string
    cardCode?: StringFieldUpdateOperationsInput | string
    reward?: RewardUpdateOneRequiredWithoutRedeemedByNestedInput
    user?: UserUpdateOneRequiredWithoutRedeemByNestedInput
  }

  export type RedeemByUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    dateOrdered?: DateTimeFieldUpdateOperationsInput | Date | string
    rewardId?: IntFieldUpdateOperationsInput | number
    cardCode?: StringFieldUpdateOperationsInput | string
  }

  export type RedeemByCreateManyInput = {
    id?: number
    userId: number
    dateOrdered?: Date | string
    rewardId: number
    cardCode: string
  }

  export type RedeemByUpdateManyMutationInput = {
    dateOrdered?: DateTimeFieldUpdateOperationsInput | Date | string
    cardCode?: StringFieldUpdateOperationsInput | string
  }

  export type RedeemByUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    dateOrdered?: DateTimeFieldUpdateOperationsInput | Date | string
    rewardId?: IntFieldUpdateOperationsInput | number
    cardCode?: StringFieldUpdateOperationsInput | string
  }

  export type QuizQuestionCreateInput = {
    question: string
    options?: QuizQuestionCreateoptionsInput | string[]
    correct_answer: number
  }

  export type QuizQuestionUncheckedCreateInput = {
    id?: number
    question: string
    options?: QuizQuestionCreateoptionsInput | string[]
    correct_answer: number
  }

  export type QuizQuestionUpdateInput = {
    question?: StringFieldUpdateOperationsInput | string
    options?: QuizQuestionUpdateoptionsInput | string[]
    correct_answer?: IntFieldUpdateOperationsInput | number
  }

  export type QuizQuestionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    options?: QuizQuestionUpdateoptionsInput | string[]
    correct_answer?: IntFieldUpdateOperationsInput | number
  }

  export type QuizQuestionCreateManyInput = {
    id?: number
    question: string
    options?: QuizQuestionCreateoptionsInput | string[]
    correct_answer: number
  }

  export type QuizQuestionUpdateManyMutationInput = {
    question?: StringFieldUpdateOperationsInput | string
    options?: QuizQuestionUpdateoptionsInput | string[]
    correct_answer?: IntFieldUpdateOperationsInput | number
  }

  export type QuizQuestionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    options?: QuizQuestionUpdateoptionsInput | string[]
    correct_answer?: IntFieldUpdateOperationsInput | number
  }

  export type RewardCreateInput = {
    rewardName: string
    rewardDescription: string
    cost: number
    probability: Decimal | DecimalJsLike | number | string
    redeemedBy?: RedeemByCreateNestedManyWithoutRewardInput
  }

  export type RewardUncheckedCreateInput = {
    id?: number
    rewardName: string
    rewardDescription: string
    cost: number
    probability: Decimal | DecimalJsLike | number | string
    redeemedBy?: RedeemByUncheckedCreateNestedManyWithoutRewardInput
  }

  export type RewardUpdateInput = {
    rewardName?: StringFieldUpdateOperationsInput | string
    rewardDescription?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    probability?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    redeemedBy?: RedeemByUpdateManyWithoutRewardNestedInput
  }

  export type RewardUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rewardName?: StringFieldUpdateOperationsInput | string
    rewardDescription?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    probability?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    redeemedBy?: RedeemByUncheckedUpdateManyWithoutRewardNestedInput
  }

  export type RewardCreateManyInput = {
    id?: number
    rewardName: string
    rewardDescription: string
    cost: number
    probability: Decimal | DecimalJsLike | number | string
  }

  export type RewardUpdateManyMutationInput = {
    rewardName?: StringFieldUpdateOperationsInput | string
    rewardDescription?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    probability?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type RewardUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    rewardName?: StringFieldUpdateOperationsInput | string
    rewardDescription?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    probability?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StatusRelationFilter = {
    is?: StatusWhereInput
    isNot?: StatusWhereInput
  }

  export type TaskAssignmentListRelationFilter = {
    every?: TaskAssignmentWhereInput
    some?: TaskAssignmentWhereInput
    none?: TaskAssignmentWhereInput
  }

  export type TaskAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    statusId?: SortOrder
  }

  export type TaskAvgOrderByAggregateInput = {
    id?: SortOrder
    statusId?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    statusId?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    statusId?: SortOrder
  }

  export type TaskSumOrderByAggregateInput = {
    id?: SortOrder
    statusId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StatusCountOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
  }

  export type StatusAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StatusMaxOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
  }

  export type StatusMinOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
  }

  export type StatusSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PersonCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
  }

  export type PersonAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PersonMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
  }

  export type PersonMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
  }

  export type PersonSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type PersonRelationFilter = {
    is?: PersonWhereInput
    isNot?: PersonWhereInput
  }

  export type TaskRelationFilter = {
    is?: TaskWhereInput
    isNot?: TaskWhereInput
  }

  export type TaskAssignmentAssignmentIdCompoundUniqueInput = {
    taskId: number
    personId: number
  }

  export type TaskAssignmentCountOrderByAggregateInput = {
    taskId?: SortOrder
    personId?: SortOrder
    assignedAt?: SortOrder
  }

  export type TaskAssignmentAvgOrderByAggregateInput = {
    taskId?: SortOrder
    personId?: SortOrder
  }

  export type TaskAssignmentMaxOrderByAggregateInput = {
    taskId?: SortOrder
    personId?: SortOrder
    assignedAt?: SortOrder
  }

  export type TaskAssignmentMinOrderByAggregateInput = {
    taskId?: SortOrder
    personId?: SortOrder
    assignedAt?: SortOrder
  }

  export type TaskAssignmentSumOrderByAggregateInput = {
    taskId?: SortOrder
    personId?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StockListRelationFilter = {
    every?: StockWhereInput
    some?: StockWhereInput
    none?: StockWhereInput
  }

  export type StockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    founded?: SortOrder
    employees?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    zipCode?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyAvgOrderByAggregateInput = {
    id?: SortOrder
    founded?: SortOrder
    employees?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    founded?: SortOrder
    employees?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    zipCode?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    founded?: SortOrder
    employees?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    zipCode?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanySumOrderByAggregateInput = {
    id?: SortOrder
    founded?: SortOrder
    employees?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FavoriteStockListRelationFilter = {
    every?: FavoriteStockWhereInput
    some?: FavoriteStockWhereInput
    none?: FavoriteStockWhereInput
  }

  export type HistPriceListRelationFilter = {
    every?: HistPriceWhereInput
    some?: HistPriceWhereInput
    none?: HistPriceWhereInput
  }

  export type LimitOrderListRelationFilter = {
    every?: LimitOrderWhereInput
    some?: LimitOrderWhereInput
    none?: LimitOrderWhereInput
  }

  export type CompanyNullableRelationFilter = {
    is?: CompanyWhereInput | null
    isNot?: CompanyWhereInput | null
  }

  export type TradeListRelationFilter = {
    every?: TradeWhereInput
    some?: TradeWhereInput
    none?: TradeWhereInput
  }

  export type FavoriteStockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HistPriceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LimitOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TradeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockCountOrderByAggregateInput = {
    stock_id?: SortOrder
    symbol?: SortOrder
    sector?: SortOrder
    company_id?: SortOrder
    change?: SortOrder
  }

  export type StockAvgOrderByAggregateInput = {
    stock_id?: SortOrder
    company_id?: SortOrder
    change?: SortOrder
  }

  export type StockMaxOrderByAggregateInput = {
    stock_id?: SortOrder
    symbol?: SortOrder
    sector?: SortOrder
    company_id?: SortOrder
    change?: SortOrder
  }

  export type StockMinOrderByAggregateInput = {
    stock_id?: SortOrder
    symbol?: SortOrder
    sector?: SortOrder
    company_id?: SortOrder
    change?: SortOrder
  }

  export type StockSumOrderByAggregateInput = {
    stock_id?: SortOrder
    company_id?: SortOrder
    change?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StockRelationFilter = {
    is?: StockWhereInput
    isNot?: StockWhereInput
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type FavoriteStockUserIdStockIdCompoundUniqueInput = {
    userId: number
    stockId: number
  }

  export type FavoriteStockCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stockId?: SortOrder
  }

  export type FavoriteStockAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stockId?: SortOrder
  }

  export type FavoriteStockMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stockId?: SortOrder
  }

  export type FavoriteStockMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stockId?: SortOrder
  }

  export type FavoriteStockSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stockId?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type HistPriceStock_idDateCompoundUniqueInput = {
    stock_id: number
    date: Date | string
  }

  export type HistPriceCountOrderByAggregateInput = {
    price_id?: SortOrder
    stock_id?: SortOrder
    date?: SortOrder
    open_price?: SortOrder
    high_price?: SortOrder
    low_price?: SortOrder
    close_price?: SortOrder
    volume?: SortOrder
  }

  export type HistPriceAvgOrderByAggregateInput = {
    price_id?: SortOrder
    stock_id?: SortOrder
    open_price?: SortOrder
    high_price?: SortOrder
    low_price?: SortOrder
    close_price?: SortOrder
    volume?: SortOrder
  }

  export type HistPriceMaxOrderByAggregateInput = {
    price_id?: SortOrder
    stock_id?: SortOrder
    date?: SortOrder
    open_price?: SortOrder
    high_price?: SortOrder
    low_price?: SortOrder
    close_price?: SortOrder
    volume?: SortOrder
  }

  export type HistPriceMinOrderByAggregateInput = {
    price_id?: SortOrder
    stock_id?: SortOrder
    date?: SortOrder
    open_price?: SortOrder
    high_price?: SortOrder
    low_price?: SortOrder
    close_price?: SortOrder
    volume?: SortOrder
  }

  export type HistPriceSumOrderByAggregateInput = {
    price_id?: SortOrder
    stock_id?: SortOrder
    open_price?: SortOrder
    high_price?: SortOrder
    low_price?: SortOrder
    close_price?: SortOrder
    volume?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type LimitOrderCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stockId?: SortOrder
    quantity?: SortOrder
    limitPrice?: SortOrder
    orderType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LimitOrderAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stockId?: SortOrder
    quantity?: SortOrder
    limitPrice?: SortOrder
  }

  export type LimitOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stockId?: SortOrder
    quantity?: SortOrder
    limitPrice?: SortOrder
    orderType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LimitOrderMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stockId?: SortOrder
    quantity?: SortOrder
    limitPrice?: SortOrder
    orderType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LimitOrderSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stockId?: SortOrder
    quantity?: SortOrder
    limitPrice?: SortOrder
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type TradeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stockId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    totalAmount?: SortOrder
    tradeType?: SortOrder
    tradeDate?: SortOrder
  }

  export type TradeAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stockId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    totalAmount?: SortOrder
  }

  export type TradeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stockId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    totalAmount?: SortOrder
    tradeType?: SortOrder
    tradeDate?: SortOrder
  }

  export type TradeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stockId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    totalAmount?: SortOrder
    tradeType?: SortOrder
    tradeDate?: SortOrder
  }

  export type TradeSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stockId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    totalAmount?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type NewsCountOrderByAggregateInput = {
    news_id?: SortOrder
    image_url?: SortOrder
    title?: SortOrder
    caption?: SortOrder
    content?: SortOrder
    category?: SortOrder
    tags?: SortOrder
  }

  export type NewsAvgOrderByAggregateInput = {
    news_id?: SortOrder
  }

  export type NewsMaxOrderByAggregateInput = {
    news_id?: SortOrder
    image_url?: SortOrder
    title?: SortOrder
    caption?: SortOrder
    content?: SortOrder
    category?: SortOrder
  }

  export type NewsMinOrderByAggregateInput = {
    news_id?: SortOrder
    image_url?: SortOrder
    title?: SortOrder
    caption?: SortOrder
    content?: SortOrder
    category?: SortOrder
  }

  export type NewsSumOrderByAggregateInput = {
    news_id?: SortOrder
  }

  export type BlogCommentListRelationFilter = {
    every?: BlogCommentWhereInput
    some?: BlogCommentWhereInput
    none?: BlogCommentWhereInput
  }

  export type BlogCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlogPostCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BlogPostAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type BlogPostMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BlogPostMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BlogPostSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type BlogPostRelationFilter = {
    is?: BlogPostWhereInput
    isNot?: BlogPostWhereInput
  }

  export type BlogCommentCountOrderByAggregateInput = {
    id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BlogCommentAvgOrderByAggregateInput = {
    id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
  }

  export type BlogCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BlogCommentMinOrderByAggregateInput = {
    id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BlogCommentSumOrderByAggregateInput = {
    id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
  }

  export type BlogPostListRelationFilter = {
    every?: BlogPostWhereInput
    some?: BlogPostWhereInput
    none?: BlogPostWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type FavoriteApiListRelationFilter = {
    every?: FavoriteApiWhereInput
    some?: FavoriteApiWhereInput
    none?: FavoriteApiWhereInput
  }

  export type GoalListRelationFilter = {
    every?: GoalWhereInput
    some?: GoalWhereInput
    none?: GoalWhereInput
  }

  export type RedeemByListRelationFilter = {
    every?: RedeemByWhereInput
    some?: RedeemByWhereInput
    none?: RedeemByWhereInput
  }

  export type ReferralListRelationFilter = {
    every?: ReferralWhereInput
    some?: ReferralWhereInput
    none?: ReferralWhereInput
  }

  export type ReferralUsageListRelationFilter = {
    every?: ReferralUsageWhereInput
    some?: ReferralUsageWhereInput
    none?: ReferralUsageWhereInput
  }

  export type ReferralNullableRelationFilter = {
    is?: ReferralWhereInput | null
    isNot?: ReferralWhereInput | null
  }

  export type BlogPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FavoriteApiOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GoalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RedeemByOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReferralOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReferralUsageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    wallet?: SortOrder
    createdAt?: SortOrder
    referredById?: SortOrder
    status?: SortOrder
    userReferralLink?: SortOrder
    username?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    wallet?: SortOrder
    referredById?: SortOrder
    phoneNumber?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    wallet?: SortOrder
    createdAt?: SortOrder
    referredById?: SortOrder
    status?: SortOrder
    userReferralLink?: SortOrder
    username?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    wallet?: SortOrder
    createdAt?: SortOrder
    referredById?: SortOrder
    status?: SortOrder
    userReferralLink?: SortOrder
    username?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    wallet?: SortOrder
    referredById?: SortOrder
    phoneNumber?: SortOrder
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReferralCountOrderByAggregateInput = {
    id?: SortOrder
    referralLink?: SortOrder
    referralSignups?: SortOrder
    successfulReferrals?: SortOrder
    rewardsExchanged?: SortOrder
    creditsEarned?: SortOrder
    userId?: SortOrder
    wallet?: SortOrder
  }

  export type ReferralAvgOrderByAggregateInput = {
    id?: SortOrder
    referralSignups?: SortOrder
    successfulReferrals?: SortOrder
    rewardsExchanged?: SortOrder
    creditsEarned?: SortOrder
    userId?: SortOrder
    wallet?: SortOrder
  }

  export type ReferralMaxOrderByAggregateInput = {
    id?: SortOrder
    referralLink?: SortOrder
    referralSignups?: SortOrder
    successfulReferrals?: SortOrder
    rewardsExchanged?: SortOrder
    creditsEarned?: SortOrder
    userId?: SortOrder
    wallet?: SortOrder
  }

  export type ReferralMinOrderByAggregateInput = {
    id?: SortOrder
    referralLink?: SortOrder
    referralSignups?: SortOrder
    successfulReferrals?: SortOrder
    rewardsExchanged?: SortOrder
    creditsEarned?: SortOrder
    userId?: SortOrder
    wallet?: SortOrder
  }

  export type ReferralSumOrderByAggregateInput = {
    id?: SortOrder
    referralSignups?: SortOrder
    successfulReferrals?: SortOrder
    rewardsExchanged?: SortOrder
    creditsEarned?: SortOrder
    userId?: SortOrder
    wallet?: SortOrder
  }

  export type ReferralUsageUserIdReferralIdCompoundUniqueInput = {
    userId: number
    referralId: number
  }

  export type ReferralUsageCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    referralId?: SortOrder
    createdAt?: SortOrder
  }

  export type ReferralUsageAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    referralId?: SortOrder
  }

  export type ReferralUsageMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    referralId?: SortOrder
    createdAt?: SortOrder
  }

  export type ReferralUsageMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    referralId?: SortOrder
    createdAt?: SortOrder
  }

  export type ReferralUsageSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    referralId?: SortOrder
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stockSymbol?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    viewCount?: SortOrder
  }

  export type CommentAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    viewCount?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stockSymbol?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    viewCount?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stockSymbol?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    viewCount?: SortOrder
  }

  export type CommentSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    viewCount?: SortOrder
  }

  export type FavoriteApiCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    symbol?: SortOrder
  }

  export type FavoriteApiAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type FavoriteApiMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    symbol?: SortOrder
  }

  export type FavoriteApiMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    symbol?: SortOrder
  }

  export type FavoriteApiSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type GoalCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    deadline?: SortOrder
    createdAt?: SortOrder
    description?: SortOrder
    userId?: SortOrder
  }

  export type GoalAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    userId?: SortOrder
  }

  export type GoalMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    deadline?: SortOrder
    createdAt?: SortOrder
    description?: SortOrder
    userId?: SortOrder
  }

  export type GoalMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    deadline?: SortOrder
    createdAt?: SortOrder
    description?: SortOrder
    userId?: SortOrder
  }

  export type GoalSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    userId?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type RewardRelationFilter = {
    is?: RewardWhereInput
    isNot?: RewardWhereInput
  }

  export type RedeemByCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dateOrdered?: SortOrder
    rewardId?: SortOrder
    cardCode?: SortOrder
  }

  export type RedeemByAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    rewardId?: SortOrder
  }

  export type RedeemByMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dateOrdered?: SortOrder
    rewardId?: SortOrder
    cardCode?: SortOrder
  }

  export type RedeemByMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dateOrdered?: SortOrder
    rewardId?: SortOrder
    cardCode?: SortOrder
  }

  export type RedeemBySumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    rewardId?: SortOrder
  }

  export type QuizQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    options?: SortOrder
    correct_answer?: SortOrder
  }

  export type QuizQuestionAvgOrderByAggregateInput = {
    id?: SortOrder
    correct_answer?: SortOrder
  }

  export type QuizQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    correct_answer?: SortOrder
  }

  export type QuizQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    correct_answer?: SortOrder
  }

  export type QuizQuestionSumOrderByAggregateInput = {
    id?: SortOrder
    correct_answer?: SortOrder
  }

  export type RewardCountOrderByAggregateInput = {
    id?: SortOrder
    rewardName?: SortOrder
    rewardDescription?: SortOrder
    cost?: SortOrder
    probability?: SortOrder
  }

  export type RewardAvgOrderByAggregateInput = {
    id?: SortOrder
    cost?: SortOrder
    probability?: SortOrder
  }

  export type RewardMaxOrderByAggregateInput = {
    id?: SortOrder
    rewardName?: SortOrder
    rewardDescription?: SortOrder
    cost?: SortOrder
    probability?: SortOrder
  }

  export type RewardMinOrderByAggregateInput = {
    id?: SortOrder
    rewardName?: SortOrder
    rewardDescription?: SortOrder
    cost?: SortOrder
    probability?: SortOrder
  }

  export type RewardSumOrderByAggregateInput = {
    id?: SortOrder
    cost?: SortOrder
    probability?: SortOrder
  }

  export type StatusCreateNestedOneWithoutTasksInput = {
    create?: XOR<StatusCreateWithoutTasksInput, StatusUncheckedCreateWithoutTasksInput>
    connectOrCreate?: StatusCreateOrConnectWithoutTasksInput
    connect?: StatusWhereUniqueInput
  }

  export type TaskAssignmentCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskAssignmentCreateWithoutTaskInput, TaskAssignmentUncheckedCreateWithoutTaskInput> | TaskAssignmentCreateWithoutTaskInput[] | TaskAssignmentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAssignmentCreateOrConnectWithoutTaskInput | TaskAssignmentCreateOrConnectWithoutTaskInput[]
    createMany?: TaskAssignmentCreateManyTaskInputEnvelope
    connect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
  }

  export type TaskAssignmentUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskAssignmentCreateWithoutTaskInput, TaskAssignmentUncheckedCreateWithoutTaskInput> | TaskAssignmentCreateWithoutTaskInput[] | TaskAssignmentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAssignmentCreateOrConnectWithoutTaskInput | TaskAssignmentCreateOrConnectWithoutTaskInput[]
    createMany?: TaskAssignmentCreateManyTaskInputEnvelope
    connect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type StatusUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<StatusCreateWithoutTasksInput, StatusUncheckedCreateWithoutTasksInput>
    connectOrCreate?: StatusCreateOrConnectWithoutTasksInput
    upsert?: StatusUpsertWithoutTasksInput
    connect?: StatusWhereUniqueInput
    update?: XOR<XOR<StatusUpdateToOneWithWhereWithoutTasksInput, StatusUpdateWithoutTasksInput>, StatusUncheckedUpdateWithoutTasksInput>
  }

  export type TaskAssignmentUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskAssignmentCreateWithoutTaskInput, TaskAssignmentUncheckedCreateWithoutTaskInput> | TaskAssignmentCreateWithoutTaskInput[] | TaskAssignmentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAssignmentCreateOrConnectWithoutTaskInput | TaskAssignmentCreateOrConnectWithoutTaskInput[]
    upsert?: TaskAssignmentUpsertWithWhereUniqueWithoutTaskInput | TaskAssignmentUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskAssignmentCreateManyTaskInputEnvelope
    set?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    disconnect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    delete?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    connect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    update?: TaskAssignmentUpdateWithWhereUniqueWithoutTaskInput | TaskAssignmentUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskAssignmentUpdateManyWithWhereWithoutTaskInput | TaskAssignmentUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskAssignmentScalarWhereInput | TaskAssignmentScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TaskAssignmentUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskAssignmentCreateWithoutTaskInput, TaskAssignmentUncheckedCreateWithoutTaskInput> | TaskAssignmentCreateWithoutTaskInput[] | TaskAssignmentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAssignmentCreateOrConnectWithoutTaskInput | TaskAssignmentCreateOrConnectWithoutTaskInput[]
    upsert?: TaskAssignmentUpsertWithWhereUniqueWithoutTaskInput | TaskAssignmentUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskAssignmentCreateManyTaskInputEnvelope
    set?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    disconnect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    delete?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    connect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    update?: TaskAssignmentUpdateWithWhereUniqueWithoutTaskInput | TaskAssignmentUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskAssignmentUpdateManyWithWhereWithoutTaskInput | TaskAssignmentUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskAssignmentScalarWhereInput | TaskAssignmentScalarWhereInput[]
  }

  export type TaskCreateNestedManyWithoutStatusInput = {
    create?: XOR<TaskCreateWithoutStatusInput, TaskUncheckedCreateWithoutStatusInput> | TaskCreateWithoutStatusInput[] | TaskUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutStatusInput | TaskCreateOrConnectWithoutStatusInput[]
    createMany?: TaskCreateManyStatusInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutStatusInput = {
    create?: XOR<TaskCreateWithoutStatusInput, TaskUncheckedCreateWithoutStatusInput> | TaskCreateWithoutStatusInput[] | TaskUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutStatusInput | TaskCreateOrConnectWithoutStatusInput[]
    createMany?: TaskCreateManyStatusInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskUpdateManyWithoutStatusNestedInput = {
    create?: XOR<TaskCreateWithoutStatusInput, TaskUncheckedCreateWithoutStatusInput> | TaskCreateWithoutStatusInput[] | TaskUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutStatusInput | TaskCreateOrConnectWithoutStatusInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutStatusInput | TaskUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: TaskCreateManyStatusInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutStatusInput | TaskUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutStatusInput | TaskUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutStatusNestedInput = {
    create?: XOR<TaskCreateWithoutStatusInput, TaskUncheckedCreateWithoutStatusInput> | TaskCreateWithoutStatusInput[] | TaskUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutStatusInput | TaskCreateOrConnectWithoutStatusInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutStatusInput | TaskUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: TaskCreateManyStatusInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutStatusInput | TaskUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutStatusInput | TaskUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskAssignmentCreateNestedManyWithoutPersonInput = {
    create?: XOR<TaskAssignmentCreateWithoutPersonInput, TaskAssignmentUncheckedCreateWithoutPersonInput> | TaskAssignmentCreateWithoutPersonInput[] | TaskAssignmentUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: TaskAssignmentCreateOrConnectWithoutPersonInput | TaskAssignmentCreateOrConnectWithoutPersonInput[]
    createMany?: TaskAssignmentCreateManyPersonInputEnvelope
    connect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
  }

  export type TaskAssignmentUncheckedCreateNestedManyWithoutPersonInput = {
    create?: XOR<TaskAssignmentCreateWithoutPersonInput, TaskAssignmentUncheckedCreateWithoutPersonInput> | TaskAssignmentCreateWithoutPersonInput[] | TaskAssignmentUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: TaskAssignmentCreateOrConnectWithoutPersonInput | TaskAssignmentCreateOrConnectWithoutPersonInput[]
    createMany?: TaskAssignmentCreateManyPersonInputEnvelope
    connect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type TaskAssignmentUpdateManyWithoutPersonNestedInput = {
    create?: XOR<TaskAssignmentCreateWithoutPersonInput, TaskAssignmentUncheckedCreateWithoutPersonInput> | TaskAssignmentCreateWithoutPersonInput[] | TaskAssignmentUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: TaskAssignmentCreateOrConnectWithoutPersonInput | TaskAssignmentCreateOrConnectWithoutPersonInput[]
    upsert?: TaskAssignmentUpsertWithWhereUniqueWithoutPersonInput | TaskAssignmentUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: TaskAssignmentCreateManyPersonInputEnvelope
    set?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    disconnect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    delete?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    connect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    update?: TaskAssignmentUpdateWithWhereUniqueWithoutPersonInput | TaskAssignmentUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: TaskAssignmentUpdateManyWithWhereWithoutPersonInput | TaskAssignmentUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: TaskAssignmentScalarWhereInput | TaskAssignmentScalarWhereInput[]
  }

  export type TaskAssignmentUncheckedUpdateManyWithoutPersonNestedInput = {
    create?: XOR<TaskAssignmentCreateWithoutPersonInput, TaskAssignmentUncheckedCreateWithoutPersonInput> | TaskAssignmentCreateWithoutPersonInput[] | TaskAssignmentUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: TaskAssignmentCreateOrConnectWithoutPersonInput | TaskAssignmentCreateOrConnectWithoutPersonInput[]
    upsert?: TaskAssignmentUpsertWithWhereUniqueWithoutPersonInput | TaskAssignmentUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: TaskAssignmentCreateManyPersonInputEnvelope
    set?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    disconnect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    delete?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    connect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    update?: TaskAssignmentUpdateWithWhereUniqueWithoutPersonInput | TaskAssignmentUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: TaskAssignmentUpdateManyWithWhereWithoutPersonInput | TaskAssignmentUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: TaskAssignmentScalarWhereInput | TaskAssignmentScalarWhereInput[]
  }

  export type PersonCreateNestedOneWithoutTasksInput = {
    create?: XOR<PersonCreateWithoutTasksInput, PersonUncheckedCreateWithoutTasksInput>
    connectOrCreate?: PersonCreateOrConnectWithoutTasksInput
    connect?: PersonWhereUniqueInput
  }

  export type TaskCreateNestedOneWithoutPersonsInput = {
    create?: XOR<TaskCreateWithoutPersonsInput, TaskUncheckedCreateWithoutPersonsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutPersonsInput
    connect?: TaskWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type PersonUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<PersonCreateWithoutTasksInput, PersonUncheckedCreateWithoutTasksInput>
    connectOrCreate?: PersonCreateOrConnectWithoutTasksInput
    upsert?: PersonUpsertWithoutTasksInput
    connect?: PersonWhereUniqueInput
    update?: XOR<XOR<PersonUpdateToOneWithWhereWithoutTasksInput, PersonUpdateWithoutTasksInput>, PersonUncheckedUpdateWithoutTasksInput>
  }

  export type TaskUpdateOneRequiredWithoutPersonsNestedInput = {
    create?: XOR<TaskCreateWithoutPersonsInput, TaskUncheckedCreateWithoutPersonsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutPersonsInput
    upsert?: TaskUpsertWithoutPersonsInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutPersonsInput, TaskUpdateWithoutPersonsInput>, TaskUncheckedUpdateWithoutPersonsInput>
  }

  export type StockCreateNestedManyWithoutCompanyInput = {
    create?: XOR<StockCreateWithoutCompanyInput, StockUncheckedCreateWithoutCompanyInput> | StockCreateWithoutCompanyInput[] | StockUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: StockCreateOrConnectWithoutCompanyInput | StockCreateOrConnectWithoutCompanyInput[]
    createMany?: StockCreateManyCompanyInputEnvelope
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
  }

  export type StockUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<StockCreateWithoutCompanyInput, StockUncheckedCreateWithoutCompanyInput> | StockCreateWithoutCompanyInput[] | StockUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: StockCreateOrConnectWithoutCompanyInput | StockCreateOrConnectWithoutCompanyInput[]
    createMany?: StockCreateManyCompanyInputEnvelope
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type StockUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<StockCreateWithoutCompanyInput, StockUncheckedCreateWithoutCompanyInput> | StockCreateWithoutCompanyInput[] | StockUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: StockCreateOrConnectWithoutCompanyInput | StockCreateOrConnectWithoutCompanyInput[]
    upsert?: StockUpsertWithWhereUniqueWithoutCompanyInput | StockUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: StockCreateManyCompanyInputEnvelope
    set?: StockWhereUniqueInput | StockWhereUniqueInput[]
    disconnect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    delete?: StockWhereUniqueInput | StockWhereUniqueInput[]
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    update?: StockUpdateWithWhereUniqueWithoutCompanyInput | StockUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: StockUpdateManyWithWhereWithoutCompanyInput | StockUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: StockScalarWhereInput | StockScalarWhereInput[]
  }

  export type StockUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<StockCreateWithoutCompanyInput, StockUncheckedCreateWithoutCompanyInput> | StockCreateWithoutCompanyInput[] | StockUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: StockCreateOrConnectWithoutCompanyInput | StockCreateOrConnectWithoutCompanyInput[]
    upsert?: StockUpsertWithWhereUniqueWithoutCompanyInput | StockUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: StockCreateManyCompanyInputEnvelope
    set?: StockWhereUniqueInput | StockWhereUniqueInput[]
    disconnect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    delete?: StockWhereUniqueInput | StockWhereUniqueInput[]
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    update?: StockUpdateWithWhereUniqueWithoutCompanyInput | StockUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: StockUpdateManyWithWhereWithoutCompanyInput | StockUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: StockScalarWhereInput | StockScalarWhereInput[]
  }

  export type FavoriteStockCreateNestedManyWithoutStockInput = {
    create?: XOR<FavoriteStockCreateWithoutStockInput, FavoriteStockUncheckedCreateWithoutStockInput> | FavoriteStockCreateWithoutStockInput[] | FavoriteStockUncheckedCreateWithoutStockInput[]
    connectOrCreate?: FavoriteStockCreateOrConnectWithoutStockInput | FavoriteStockCreateOrConnectWithoutStockInput[]
    createMany?: FavoriteStockCreateManyStockInputEnvelope
    connect?: FavoriteStockWhereUniqueInput | FavoriteStockWhereUniqueInput[]
  }

  export type HistPriceCreateNestedManyWithoutStockInput = {
    create?: XOR<HistPriceCreateWithoutStockInput, HistPriceUncheckedCreateWithoutStockInput> | HistPriceCreateWithoutStockInput[] | HistPriceUncheckedCreateWithoutStockInput[]
    connectOrCreate?: HistPriceCreateOrConnectWithoutStockInput | HistPriceCreateOrConnectWithoutStockInput[]
    createMany?: HistPriceCreateManyStockInputEnvelope
    connect?: HistPriceWhereUniqueInput | HistPriceWhereUniqueInput[]
  }

  export type LimitOrderCreateNestedManyWithoutStockInput = {
    create?: XOR<LimitOrderCreateWithoutStockInput, LimitOrderUncheckedCreateWithoutStockInput> | LimitOrderCreateWithoutStockInput[] | LimitOrderUncheckedCreateWithoutStockInput[]
    connectOrCreate?: LimitOrderCreateOrConnectWithoutStockInput | LimitOrderCreateOrConnectWithoutStockInput[]
    createMany?: LimitOrderCreateManyStockInputEnvelope
    connect?: LimitOrderWhereUniqueInput | LimitOrderWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutStocksInput = {
    create?: XOR<CompanyCreateWithoutStocksInput, CompanyUncheckedCreateWithoutStocksInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutStocksInput
    connect?: CompanyWhereUniqueInput
  }

  export type TradeCreateNestedManyWithoutStockInput = {
    create?: XOR<TradeCreateWithoutStockInput, TradeUncheckedCreateWithoutStockInput> | TradeCreateWithoutStockInput[] | TradeUncheckedCreateWithoutStockInput[]
    connectOrCreate?: TradeCreateOrConnectWithoutStockInput | TradeCreateOrConnectWithoutStockInput[]
    createMany?: TradeCreateManyStockInputEnvelope
    connect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
  }

  export type FavoriteStockUncheckedCreateNestedManyWithoutStockInput = {
    create?: XOR<FavoriteStockCreateWithoutStockInput, FavoriteStockUncheckedCreateWithoutStockInput> | FavoriteStockCreateWithoutStockInput[] | FavoriteStockUncheckedCreateWithoutStockInput[]
    connectOrCreate?: FavoriteStockCreateOrConnectWithoutStockInput | FavoriteStockCreateOrConnectWithoutStockInput[]
    createMany?: FavoriteStockCreateManyStockInputEnvelope
    connect?: FavoriteStockWhereUniqueInput | FavoriteStockWhereUniqueInput[]
  }

  export type HistPriceUncheckedCreateNestedManyWithoutStockInput = {
    create?: XOR<HistPriceCreateWithoutStockInput, HistPriceUncheckedCreateWithoutStockInput> | HistPriceCreateWithoutStockInput[] | HistPriceUncheckedCreateWithoutStockInput[]
    connectOrCreate?: HistPriceCreateOrConnectWithoutStockInput | HistPriceCreateOrConnectWithoutStockInput[]
    createMany?: HistPriceCreateManyStockInputEnvelope
    connect?: HistPriceWhereUniqueInput | HistPriceWhereUniqueInput[]
  }

  export type LimitOrderUncheckedCreateNestedManyWithoutStockInput = {
    create?: XOR<LimitOrderCreateWithoutStockInput, LimitOrderUncheckedCreateWithoutStockInput> | LimitOrderCreateWithoutStockInput[] | LimitOrderUncheckedCreateWithoutStockInput[]
    connectOrCreate?: LimitOrderCreateOrConnectWithoutStockInput | LimitOrderCreateOrConnectWithoutStockInput[]
    createMany?: LimitOrderCreateManyStockInputEnvelope
    connect?: LimitOrderWhereUniqueInput | LimitOrderWhereUniqueInput[]
  }

  export type TradeUncheckedCreateNestedManyWithoutStockInput = {
    create?: XOR<TradeCreateWithoutStockInput, TradeUncheckedCreateWithoutStockInput> | TradeCreateWithoutStockInput[] | TradeUncheckedCreateWithoutStockInput[]
    connectOrCreate?: TradeCreateOrConnectWithoutStockInput | TradeCreateOrConnectWithoutStockInput[]
    createMany?: TradeCreateManyStockInputEnvelope
    connect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FavoriteStockUpdateManyWithoutStockNestedInput = {
    create?: XOR<FavoriteStockCreateWithoutStockInput, FavoriteStockUncheckedCreateWithoutStockInput> | FavoriteStockCreateWithoutStockInput[] | FavoriteStockUncheckedCreateWithoutStockInput[]
    connectOrCreate?: FavoriteStockCreateOrConnectWithoutStockInput | FavoriteStockCreateOrConnectWithoutStockInput[]
    upsert?: FavoriteStockUpsertWithWhereUniqueWithoutStockInput | FavoriteStockUpsertWithWhereUniqueWithoutStockInput[]
    createMany?: FavoriteStockCreateManyStockInputEnvelope
    set?: FavoriteStockWhereUniqueInput | FavoriteStockWhereUniqueInput[]
    disconnect?: FavoriteStockWhereUniqueInput | FavoriteStockWhereUniqueInput[]
    delete?: FavoriteStockWhereUniqueInput | FavoriteStockWhereUniqueInput[]
    connect?: FavoriteStockWhereUniqueInput | FavoriteStockWhereUniqueInput[]
    update?: FavoriteStockUpdateWithWhereUniqueWithoutStockInput | FavoriteStockUpdateWithWhereUniqueWithoutStockInput[]
    updateMany?: FavoriteStockUpdateManyWithWhereWithoutStockInput | FavoriteStockUpdateManyWithWhereWithoutStockInput[]
    deleteMany?: FavoriteStockScalarWhereInput | FavoriteStockScalarWhereInput[]
  }

  export type HistPriceUpdateManyWithoutStockNestedInput = {
    create?: XOR<HistPriceCreateWithoutStockInput, HistPriceUncheckedCreateWithoutStockInput> | HistPriceCreateWithoutStockInput[] | HistPriceUncheckedCreateWithoutStockInput[]
    connectOrCreate?: HistPriceCreateOrConnectWithoutStockInput | HistPriceCreateOrConnectWithoutStockInput[]
    upsert?: HistPriceUpsertWithWhereUniqueWithoutStockInput | HistPriceUpsertWithWhereUniqueWithoutStockInput[]
    createMany?: HistPriceCreateManyStockInputEnvelope
    set?: HistPriceWhereUniqueInput | HistPriceWhereUniqueInput[]
    disconnect?: HistPriceWhereUniqueInput | HistPriceWhereUniqueInput[]
    delete?: HistPriceWhereUniqueInput | HistPriceWhereUniqueInput[]
    connect?: HistPriceWhereUniqueInput | HistPriceWhereUniqueInput[]
    update?: HistPriceUpdateWithWhereUniqueWithoutStockInput | HistPriceUpdateWithWhereUniqueWithoutStockInput[]
    updateMany?: HistPriceUpdateManyWithWhereWithoutStockInput | HistPriceUpdateManyWithWhereWithoutStockInput[]
    deleteMany?: HistPriceScalarWhereInput | HistPriceScalarWhereInput[]
  }

  export type LimitOrderUpdateManyWithoutStockNestedInput = {
    create?: XOR<LimitOrderCreateWithoutStockInput, LimitOrderUncheckedCreateWithoutStockInput> | LimitOrderCreateWithoutStockInput[] | LimitOrderUncheckedCreateWithoutStockInput[]
    connectOrCreate?: LimitOrderCreateOrConnectWithoutStockInput | LimitOrderCreateOrConnectWithoutStockInput[]
    upsert?: LimitOrderUpsertWithWhereUniqueWithoutStockInput | LimitOrderUpsertWithWhereUniqueWithoutStockInput[]
    createMany?: LimitOrderCreateManyStockInputEnvelope
    set?: LimitOrderWhereUniqueInput | LimitOrderWhereUniqueInput[]
    disconnect?: LimitOrderWhereUniqueInput | LimitOrderWhereUniqueInput[]
    delete?: LimitOrderWhereUniqueInput | LimitOrderWhereUniqueInput[]
    connect?: LimitOrderWhereUniqueInput | LimitOrderWhereUniqueInput[]
    update?: LimitOrderUpdateWithWhereUniqueWithoutStockInput | LimitOrderUpdateWithWhereUniqueWithoutStockInput[]
    updateMany?: LimitOrderUpdateManyWithWhereWithoutStockInput | LimitOrderUpdateManyWithWhereWithoutStockInput[]
    deleteMany?: LimitOrderScalarWhereInput | LimitOrderScalarWhereInput[]
  }

  export type CompanyUpdateOneWithoutStocksNestedInput = {
    create?: XOR<CompanyCreateWithoutStocksInput, CompanyUncheckedCreateWithoutStocksInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutStocksInput
    upsert?: CompanyUpsertWithoutStocksInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutStocksInput, CompanyUpdateWithoutStocksInput>, CompanyUncheckedUpdateWithoutStocksInput>
  }

  export type TradeUpdateManyWithoutStockNestedInput = {
    create?: XOR<TradeCreateWithoutStockInput, TradeUncheckedCreateWithoutStockInput> | TradeCreateWithoutStockInput[] | TradeUncheckedCreateWithoutStockInput[]
    connectOrCreate?: TradeCreateOrConnectWithoutStockInput | TradeCreateOrConnectWithoutStockInput[]
    upsert?: TradeUpsertWithWhereUniqueWithoutStockInput | TradeUpsertWithWhereUniqueWithoutStockInput[]
    createMany?: TradeCreateManyStockInputEnvelope
    set?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    disconnect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    delete?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    connect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    update?: TradeUpdateWithWhereUniqueWithoutStockInput | TradeUpdateWithWhereUniqueWithoutStockInput[]
    updateMany?: TradeUpdateManyWithWhereWithoutStockInput | TradeUpdateManyWithWhereWithoutStockInput[]
    deleteMany?: TradeScalarWhereInput | TradeScalarWhereInput[]
  }

  export type FavoriteStockUncheckedUpdateManyWithoutStockNestedInput = {
    create?: XOR<FavoriteStockCreateWithoutStockInput, FavoriteStockUncheckedCreateWithoutStockInput> | FavoriteStockCreateWithoutStockInput[] | FavoriteStockUncheckedCreateWithoutStockInput[]
    connectOrCreate?: FavoriteStockCreateOrConnectWithoutStockInput | FavoriteStockCreateOrConnectWithoutStockInput[]
    upsert?: FavoriteStockUpsertWithWhereUniqueWithoutStockInput | FavoriteStockUpsertWithWhereUniqueWithoutStockInput[]
    createMany?: FavoriteStockCreateManyStockInputEnvelope
    set?: FavoriteStockWhereUniqueInput | FavoriteStockWhereUniqueInput[]
    disconnect?: FavoriteStockWhereUniqueInput | FavoriteStockWhereUniqueInput[]
    delete?: FavoriteStockWhereUniqueInput | FavoriteStockWhereUniqueInput[]
    connect?: FavoriteStockWhereUniqueInput | FavoriteStockWhereUniqueInput[]
    update?: FavoriteStockUpdateWithWhereUniqueWithoutStockInput | FavoriteStockUpdateWithWhereUniqueWithoutStockInput[]
    updateMany?: FavoriteStockUpdateManyWithWhereWithoutStockInput | FavoriteStockUpdateManyWithWhereWithoutStockInput[]
    deleteMany?: FavoriteStockScalarWhereInput | FavoriteStockScalarWhereInput[]
  }

  export type HistPriceUncheckedUpdateManyWithoutStockNestedInput = {
    create?: XOR<HistPriceCreateWithoutStockInput, HistPriceUncheckedCreateWithoutStockInput> | HistPriceCreateWithoutStockInput[] | HistPriceUncheckedCreateWithoutStockInput[]
    connectOrCreate?: HistPriceCreateOrConnectWithoutStockInput | HistPriceCreateOrConnectWithoutStockInput[]
    upsert?: HistPriceUpsertWithWhereUniqueWithoutStockInput | HistPriceUpsertWithWhereUniqueWithoutStockInput[]
    createMany?: HistPriceCreateManyStockInputEnvelope
    set?: HistPriceWhereUniqueInput | HistPriceWhereUniqueInput[]
    disconnect?: HistPriceWhereUniqueInput | HistPriceWhereUniqueInput[]
    delete?: HistPriceWhereUniqueInput | HistPriceWhereUniqueInput[]
    connect?: HistPriceWhereUniqueInput | HistPriceWhereUniqueInput[]
    update?: HistPriceUpdateWithWhereUniqueWithoutStockInput | HistPriceUpdateWithWhereUniqueWithoutStockInput[]
    updateMany?: HistPriceUpdateManyWithWhereWithoutStockInput | HistPriceUpdateManyWithWhereWithoutStockInput[]
    deleteMany?: HistPriceScalarWhereInput | HistPriceScalarWhereInput[]
  }

  export type LimitOrderUncheckedUpdateManyWithoutStockNestedInput = {
    create?: XOR<LimitOrderCreateWithoutStockInput, LimitOrderUncheckedCreateWithoutStockInput> | LimitOrderCreateWithoutStockInput[] | LimitOrderUncheckedCreateWithoutStockInput[]
    connectOrCreate?: LimitOrderCreateOrConnectWithoutStockInput | LimitOrderCreateOrConnectWithoutStockInput[]
    upsert?: LimitOrderUpsertWithWhereUniqueWithoutStockInput | LimitOrderUpsertWithWhereUniqueWithoutStockInput[]
    createMany?: LimitOrderCreateManyStockInputEnvelope
    set?: LimitOrderWhereUniqueInput | LimitOrderWhereUniqueInput[]
    disconnect?: LimitOrderWhereUniqueInput | LimitOrderWhereUniqueInput[]
    delete?: LimitOrderWhereUniqueInput | LimitOrderWhereUniqueInput[]
    connect?: LimitOrderWhereUniqueInput | LimitOrderWhereUniqueInput[]
    update?: LimitOrderUpdateWithWhereUniqueWithoutStockInput | LimitOrderUpdateWithWhereUniqueWithoutStockInput[]
    updateMany?: LimitOrderUpdateManyWithWhereWithoutStockInput | LimitOrderUpdateManyWithWhereWithoutStockInput[]
    deleteMany?: LimitOrderScalarWhereInput | LimitOrderScalarWhereInput[]
  }

  export type TradeUncheckedUpdateManyWithoutStockNestedInput = {
    create?: XOR<TradeCreateWithoutStockInput, TradeUncheckedCreateWithoutStockInput> | TradeCreateWithoutStockInput[] | TradeUncheckedCreateWithoutStockInput[]
    connectOrCreate?: TradeCreateOrConnectWithoutStockInput | TradeCreateOrConnectWithoutStockInput[]
    upsert?: TradeUpsertWithWhereUniqueWithoutStockInput | TradeUpsertWithWhereUniqueWithoutStockInput[]
    createMany?: TradeCreateManyStockInputEnvelope
    set?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    disconnect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    delete?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    connect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    update?: TradeUpdateWithWhereUniqueWithoutStockInput | TradeUpdateWithWhereUniqueWithoutStockInput[]
    updateMany?: TradeUpdateManyWithWhereWithoutStockInput | TradeUpdateManyWithWhereWithoutStockInput[]
    deleteMany?: TradeScalarWhereInput | TradeScalarWhereInput[]
  }

  export type StockCreateNestedOneWithoutFavoriteStockInput = {
    create?: XOR<StockCreateWithoutFavoriteStockInput, StockUncheckedCreateWithoutFavoriteStockInput>
    connectOrCreate?: StockCreateOrConnectWithoutFavoriteStockInput
    connect?: StockWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFavoriteStocksInput = {
    create?: XOR<UserCreateWithoutFavoriteStocksInput, UserUncheckedCreateWithoutFavoriteStocksInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavoriteStocksInput
    connect?: UserWhereUniqueInput
  }

  export type StockUpdateOneRequiredWithoutFavoriteStockNestedInput = {
    create?: XOR<StockCreateWithoutFavoriteStockInput, StockUncheckedCreateWithoutFavoriteStockInput>
    connectOrCreate?: StockCreateOrConnectWithoutFavoriteStockInput
    upsert?: StockUpsertWithoutFavoriteStockInput
    connect?: StockWhereUniqueInput
    update?: XOR<XOR<StockUpdateToOneWithWhereWithoutFavoriteStockInput, StockUpdateWithoutFavoriteStockInput>, StockUncheckedUpdateWithoutFavoriteStockInput>
  }

  export type UserUpdateOneRequiredWithoutFavoriteStocksNestedInput = {
    create?: XOR<UserCreateWithoutFavoriteStocksInput, UserUncheckedCreateWithoutFavoriteStocksInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavoriteStocksInput
    upsert?: UserUpsertWithoutFavoriteStocksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFavoriteStocksInput, UserUpdateWithoutFavoriteStocksInput>, UserUncheckedUpdateWithoutFavoriteStocksInput>
  }

  export type StockCreateNestedOneWithoutHist_pricesInput = {
    create?: XOR<StockCreateWithoutHist_pricesInput, StockUncheckedCreateWithoutHist_pricesInput>
    connectOrCreate?: StockCreateOrConnectWithoutHist_pricesInput
    connect?: StockWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type StockUpdateOneRequiredWithoutHist_pricesNestedInput = {
    create?: XOR<StockCreateWithoutHist_pricesInput, StockUncheckedCreateWithoutHist_pricesInput>
    connectOrCreate?: StockCreateOrConnectWithoutHist_pricesInput
    upsert?: StockUpsertWithoutHist_pricesInput
    connect?: StockWhereUniqueInput
    update?: XOR<XOR<StockUpdateToOneWithWhereWithoutHist_pricesInput, StockUpdateWithoutHist_pricesInput>, StockUncheckedUpdateWithoutHist_pricesInput>
  }

  export type StockCreateNestedOneWithoutLimitOrderInput = {
    create?: XOR<StockCreateWithoutLimitOrderInput, StockUncheckedCreateWithoutLimitOrderInput>
    connectOrCreate?: StockCreateOrConnectWithoutLimitOrderInput
    connect?: StockWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLimitOrdersInput = {
    create?: XOR<UserCreateWithoutLimitOrdersInput, UserUncheckedCreateWithoutLimitOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutLimitOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type StockUpdateOneRequiredWithoutLimitOrderNestedInput = {
    create?: XOR<StockCreateWithoutLimitOrderInput, StockUncheckedCreateWithoutLimitOrderInput>
    connectOrCreate?: StockCreateOrConnectWithoutLimitOrderInput
    upsert?: StockUpsertWithoutLimitOrderInput
    connect?: StockWhereUniqueInput
    update?: XOR<XOR<StockUpdateToOneWithWhereWithoutLimitOrderInput, StockUpdateWithoutLimitOrderInput>, StockUncheckedUpdateWithoutLimitOrderInput>
  }

  export type UserUpdateOneRequiredWithoutLimitOrdersNestedInput = {
    create?: XOR<UserCreateWithoutLimitOrdersInput, UserUncheckedCreateWithoutLimitOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutLimitOrdersInput
    upsert?: UserUpsertWithoutLimitOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLimitOrdersInput, UserUpdateWithoutLimitOrdersInput>, UserUncheckedUpdateWithoutLimitOrdersInput>
  }

  export type StockCreateNestedOneWithoutTradingInput = {
    create?: XOR<StockCreateWithoutTradingInput, StockUncheckedCreateWithoutTradingInput>
    connectOrCreate?: StockCreateOrConnectWithoutTradingInput
    connect?: StockWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTradingInput = {
    create?: XOR<UserCreateWithoutTradingInput, UserUncheckedCreateWithoutTradingInput>
    connectOrCreate?: UserCreateOrConnectWithoutTradingInput
    connect?: UserWhereUniqueInput
  }

  export type StockUpdateOneRequiredWithoutTradingNestedInput = {
    create?: XOR<StockCreateWithoutTradingInput, StockUncheckedCreateWithoutTradingInput>
    connectOrCreate?: StockCreateOrConnectWithoutTradingInput
    upsert?: StockUpsertWithoutTradingInput
    connect?: StockWhereUniqueInput
    update?: XOR<XOR<StockUpdateToOneWithWhereWithoutTradingInput, StockUpdateWithoutTradingInput>, StockUncheckedUpdateWithoutTradingInput>
  }

  export type UserUpdateOneWithoutTradingNestedInput = {
    create?: XOR<UserCreateWithoutTradingInput, UserUncheckedCreateWithoutTradingInput>
    connectOrCreate?: UserCreateOrConnectWithoutTradingInput
    upsert?: UserUpsertWithoutTradingInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTradingInput, UserUpdateWithoutTradingInput>, UserUncheckedUpdateWithoutTradingInput>
  }

  export type NewsCreatetagsInput = {
    set: string[]
  }

  export type NewsUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserCreateNestedOneWithoutBlogPostInput = {
    create?: XOR<UserCreateWithoutBlogPostInput, UserUncheckedCreateWithoutBlogPostInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogPostInput
    connect?: UserWhereUniqueInput
  }

  export type BlogCommentCreateNestedManyWithoutPostInput = {
    create?: XOR<BlogCommentCreateWithoutPostInput, BlogCommentUncheckedCreateWithoutPostInput> | BlogCommentCreateWithoutPostInput[] | BlogCommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: BlogCommentCreateOrConnectWithoutPostInput | BlogCommentCreateOrConnectWithoutPostInput[]
    createMany?: BlogCommentCreateManyPostInputEnvelope
    connect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
  }

  export type BlogCommentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<BlogCommentCreateWithoutPostInput, BlogCommentUncheckedCreateWithoutPostInput> | BlogCommentCreateWithoutPostInput[] | BlogCommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: BlogCommentCreateOrConnectWithoutPostInput | BlogCommentCreateOrConnectWithoutPostInput[]
    createMany?: BlogCommentCreateManyPostInputEnvelope
    connect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutBlogPostNestedInput = {
    create?: XOR<UserCreateWithoutBlogPostInput, UserUncheckedCreateWithoutBlogPostInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogPostInput
    upsert?: UserUpsertWithoutBlogPostInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBlogPostInput, UserUpdateWithoutBlogPostInput>, UserUncheckedUpdateWithoutBlogPostInput>
  }

  export type BlogCommentUpdateManyWithoutPostNestedInput = {
    create?: XOR<BlogCommentCreateWithoutPostInput, BlogCommentUncheckedCreateWithoutPostInput> | BlogCommentCreateWithoutPostInput[] | BlogCommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: BlogCommentCreateOrConnectWithoutPostInput | BlogCommentCreateOrConnectWithoutPostInput[]
    upsert?: BlogCommentUpsertWithWhereUniqueWithoutPostInput | BlogCommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: BlogCommentCreateManyPostInputEnvelope
    set?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    disconnect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    delete?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    connect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    update?: BlogCommentUpdateWithWhereUniqueWithoutPostInput | BlogCommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: BlogCommentUpdateManyWithWhereWithoutPostInput | BlogCommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: BlogCommentScalarWhereInput | BlogCommentScalarWhereInput[]
  }

  export type BlogCommentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<BlogCommentCreateWithoutPostInput, BlogCommentUncheckedCreateWithoutPostInput> | BlogCommentCreateWithoutPostInput[] | BlogCommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: BlogCommentCreateOrConnectWithoutPostInput | BlogCommentCreateOrConnectWithoutPostInput[]
    upsert?: BlogCommentUpsertWithWhereUniqueWithoutPostInput | BlogCommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: BlogCommentCreateManyPostInputEnvelope
    set?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    disconnect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    delete?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    connect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    update?: BlogCommentUpdateWithWhereUniqueWithoutPostInput | BlogCommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: BlogCommentUpdateManyWithWhereWithoutPostInput | BlogCommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: BlogCommentScalarWhereInput | BlogCommentScalarWhereInput[]
  }

  export type BlogPostCreateNestedOneWithoutBlogCommentInput = {
    create?: XOR<BlogPostCreateWithoutBlogCommentInput, BlogPostUncheckedCreateWithoutBlogCommentInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutBlogCommentInput
    connect?: BlogPostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBlogCommentInput = {
    create?: XOR<UserCreateWithoutBlogCommentInput, UserUncheckedCreateWithoutBlogCommentInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogCommentInput
    connect?: UserWhereUniqueInput
  }

  export type BlogPostUpdateOneRequiredWithoutBlogCommentNestedInput = {
    create?: XOR<BlogPostCreateWithoutBlogCommentInput, BlogPostUncheckedCreateWithoutBlogCommentInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutBlogCommentInput
    upsert?: BlogPostUpsertWithoutBlogCommentInput
    connect?: BlogPostWhereUniqueInput
    update?: XOR<XOR<BlogPostUpdateToOneWithWhereWithoutBlogCommentInput, BlogPostUpdateWithoutBlogCommentInput>, BlogPostUncheckedUpdateWithoutBlogCommentInput>
  }

  export type UserUpdateOneRequiredWithoutBlogCommentNestedInput = {
    create?: XOR<UserCreateWithoutBlogCommentInput, UserUncheckedCreateWithoutBlogCommentInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogCommentInput
    upsert?: UserUpsertWithoutBlogCommentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBlogCommentInput, UserUpdateWithoutBlogCommentInput>, UserUncheckedUpdateWithoutBlogCommentInput>
  }

  export type BlogCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<BlogCommentCreateWithoutUserInput, BlogCommentUncheckedCreateWithoutUserInput> | BlogCommentCreateWithoutUserInput[] | BlogCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogCommentCreateOrConnectWithoutUserInput | BlogCommentCreateOrConnectWithoutUserInput[]
    createMany?: BlogCommentCreateManyUserInputEnvelope
    connect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
  }

  export type BlogPostCreateNestedManyWithoutUserInput = {
    create?: XOR<BlogPostCreateWithoutUserInput, BlogPostUncheckedCreateWithoutUserInput> | BlogPostCreateWithoutUserInput[] | BlogPostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutUserInput | BlogPostCreateOrConnectWithoutUserInput[]
    createMany?: BlogPostCreateManyUserInputEnvelope
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type FavoriteApiCreateNestedManyWithoutUserInput = {
    create?: XOR<FavoriteApiCreateWithoutUserInput, FavoriteApiUncheckedCreateWithoutUserInput> | FavoriteApiCreateWithoutUserInput[] | FavoriteApiUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteApiCreateOrConnectWithoutUserInput | FavoriteApiCreateOrConnectWithoutUserInput[]
    createMany?: FavoriteApiCreateManyUserInputEnvelope
    connect?: FavoriteApiWhereUniqueInput | FavoriteApiWhereUniqueInput[]
  }

  export type FavoriteStockCreateNestedManyWithoutUserInput = {
    create?: XOR<FavoriteStockCreateWithoutUserInput, FavoriteStockUncheckedCreateWithoutUserInput> | FavoriteStockCreateWithoutUserInput[] | FavoriteStockUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteStockCreateOrConnectWithoutUserInput | FavoriteStockCreateOrConnectWithoutUserInput[]
    createMany?: FavoriteStockCreateManyUserInputEnvelope
    connect?: FavoriteStockWhereUniqueInput | FavoriteStockWhereUniqueInput[]
  }

  export type GoalCreateNestedManyWithoutUserInput = {
    create?: XOR<GoalCreateWithoutUserInput, GoalUncheckedCreateWithoutUserInput> | GoalCreateWithoutUserInput[] | GoalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GoalCreateOrConnectWithoutUserInput | GoalCreateOrConnectWithoutUserInput[]
    createMany?: GoalCreateManyUserInputEnvelope
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
  }

  export type LimitOrderCreateNestedManyWithoutUserInput = {
    create?: XOR<LimitOrderCreateWithoutUserInput, LimitOrderUncheckedCreateWithoutUserInput> | LimitOrderCreateWithoutUserInput[] | LimitOrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LimitOrderCreateOrConnectWithoutUserInput | LimitOrderCreateOrConnectWithoutUserInput[]
    createMany?: LimitOrderCreateManyUserInputEnvelope
    connect?: LimitOrderWhereUniqueInput | LimitOrderWhereUniqueInput[]
  }

  export type RedeemByCreateNestedManyWithoutUserInput = {
    create?: XOR<RedeemByCreateWithoutUserInput, RedeemByUncheckedCreateWithoutUserInput> | RedeemByCreateWithoutUserInput[] | RedeemByUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RedeemByCreateOrConnectWithoutUserInput | RedeemByCreateOrConnectWithoutUserInput[]
    createMany?: RedeemByCreateManyUserInputEnvelope
    connect?: RedeemByWhereUniqueInput | RedeemByWhereUniqueInput[]
  }

  export type ReferralCreateNestedManyWithoutUserInput = {
    create?: XOR<ReferralCreateWithoutUserInput, ReferralUncheckedCreateWithoutUserInput> | ReferralCreateWithoutUserInput[] | ReferralUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutUserInput | ReferralCreateOrConnectWithoutUserInput[]
    createMany?: ReferralCreateManyUserInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type ReferralUsageCreateNestedManyWithoutUserInput = {
    create?: XOR<ReferralUsageCreateWithoutUserInput, ReferralUsageUncheckedCreateWithoutUserInput> | ReferralUsageCreateWithoutUserInput[] | ReferralUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReferralUsageCreateOrConnectWithoutUserInput | ReferralUsageCreateOrConnectWithoutUserInput[]
    createMany?: ReferralUsageCreateManyUserInputEnvelope
    connect?: ReferralUsageWhereUniqueInput | ReferralUsageWhereUniqueInput[]
  }

  export type TradeCreateNestedManyWithoutUserInput = {
    create?: XOR<TradeCreateWithoutUserInput, TradeUncheckedCreateWithoutUserInput> | TradeCreateWithoutUserInput[] | TradeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TradeCreateOrConnectWithoutUserInput | TradeCreateOrConnectWithoutUserInput[]
    createMany?: TradeCreateManyUserInputEnvelope
    connect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
  }

  export type ReferralCreateNestedOneWithoutReferredUsersInput = {
    create?: XOR<ReferralCreateWithoutReferredUsersInput, ReferralUncheckedCreateWithoutReferredUsersInput>
    connectOrCreate?: ReferralCreateOrConnectWithoutReferredUsersInput
    connect?: ReferralWhereUniqueInput
  }

  export type BlogCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BlogCommentCreateWithoutUserInput, BlogCommentUncheckedCreateWithoutUserInput> | BlogCommentCreateWithoutUserInput[] | BlogCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogCommentCreateOrConnectWithoutUserInput | BlogCommentCreateOrConnectWithoutUserInput[]
    createMany?: BlogCommentCreateManyUserInputEnvelope
    connect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
  }

  export type BlogPostUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BlogPostCreateWithoutUserInput, BlogPostUncheckedCreateWithoutUserInput> | BlogPostCreateWithoutUserInput[] | BlogPostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutUserInput | BlogPostCreateOrConnectWithoutUserInput[]
    createMany?: BlogPostCreateManyUserInputEnvelope
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type FavoriteApiUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FavoriteApiCreateWithoutUserInput, FavoriteApiUncheckedCreateWithoutUserInput> | FavoriteApiCreateWithoutUserInput[] | FavoriteApiUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteApiCreateOrConnectWithoutUserInput | FavoriteApiCreateOrConnectWithoutUserInput[]
    createMany?: FavoriteApiCreateManyUserInputEnvelope
    connect?: FavoriteApiWhereUniqueInput | FavoriteApiWhereUniqueInput[]
  }

  export type FavoriteStockUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FavoriteStockCreateWithoutUserInput, FavoriteStockUncheckedCreateWithoutUserInput> | FavoriteStockCreateWithoutUserInput[] | FavoriteStockUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteStockCreateOrConnectWithoutUserInput | FavoriteStockCreateOrConnectWithoutUserInput[]
    createMany?: FavoriteStockCreateManyUserInputEnvelope
    connect?: FavoriteStockWhereUniqueInput | FavoriteStockWhereUniqueInput[]
  }

  export type GoalUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GoalCreateWithoutUserInput, GoalUncheckedCreateWithoutUserInput> | GoalCreateWithoutUserInput[] | GoalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GoalCreateOrConnectWithoutUserInput | GoalCreateOrConnectWithoutUserInput[]
    createMany?: GoalCreateManyUserInputEnvelope
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
  }

  export type LimitOrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LimitOrderCreateWithoutUserInput, LimitOrderUncheckedCreateWithoutUserInput> | LimitOrderCreateWithoutUserInput[] | LimitOrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LimitOrderCreateOrConnectWithoutUserInput | LimitOrderCreateOrConnectWithoutUserInput[]
    createMany?: LimitOrderCreateManyUserInputEnvelope
    connect?: LimitOrderWhereUniqueInput | LimitOrderWhereUniqueInput[]
  }

  export type RedeemByUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RedeemByCreateWithoutUserInput, RedeemByUncheckedCreateWithoutUserInput> | RedeemByCreateWithoutUserInput[] | RedeemByUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RedeemByCreateOrConnectWithoutUserInput | RedeemByCreateOrConnectWithoutUserInput[]
    createMany?: RedeemByCreateManyUserInputEnvelope
    connect?: RedeemByWhereUniqueInput | RedeemByWhereUniqueInput[]
  }

  export type ReferralUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReferralCreateWithoutUserInput, ReferralUncheckedCreateWithoutUserInput> | ReferralCreateWithoutUserInput[] | ReferralUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutUserInput | ReferralCreateOrConnectWithoutUserInput[]
    createMany?: ReferralCreateManyUserInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type ReferralUsageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReferralUsageCreateWithoutUserInput, ReferralUsageUncheckedCreateWithoutUserInput> | ReferralUsageCreateWithoutUserInput[] | ReferralUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReferralUsageCreateOrConnectWithoutUserInput | ReferralUsageCreateOrConnectWithoutUserInput[]
    createMany?: ReferralUsageCreateManyUserInputEnvelope
    connect?: ReferralUsageWhereUniqueInput | ReferralUsageWhereUniqueInput[]
  }

  export type TradeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TradeCreateWithoutUserInput, TradeUncheckedCreateWithoutUserInput> | TradeCreateWithoutUserInput[] | TradeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TradeCreateOrConnectWithoutUserInput | TradeCreateOrConnectWithoutUserInput[]
    createMany?: TradeCreateManyUserInputEnvelope
    connect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
  }

  export type BlogCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<BlogCommentCreateWithoutUserInput, BlogCommentUncheckedCreateWithoutUserInput> | BlogCommentCreateWithoutUserInput[] | BlogCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogCommentCreateOrConnectWithoutUserInput | BlogCommentCreateOrConnectWithoutUserInput[]
    upsert?: BlogCommentUpsertWithWhereUniqueWithoutUserInput | BlogCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BlogCommentCreateManyUserInputEnvelope
    set?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    disconnect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    delete?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    connect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    update?: BlogCommentUpdateWithWhereUniqueWithoutUserInput | BlogCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BlogCommentUpdateManyWithWhereWithoutUserInput | BlogCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BlogCommentScalarWhereInput | BlogCommentScalarWhereInput[]
  }

  export type BlogPostUpdateManyWithoutUserNestedInput = {
    create?: XOR<BlogPostCreateWithoutUserInput, BlogPostUncheckedCreateWithoutUserInput> | BlogPostCreateWithoutUserInput[] | BlogPostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutUserInput | BlogPostCreateOrConnectWithoutUserInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutUserInput | BlogPostUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BlogPostCreateManyUserInputEnvelope
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutUserInput | BlogPostUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutUserInput | BlogPostUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type FavoriteApiUpdateManyWithoutUserNestedInput = {
    create?: XOR<FavoriteApiCreateWithoutUserInput, FavoriteApiUncheckedCreateWithoutUserInput> | FavoriteApiCreateWithoutUserInput[] | FavoriteApiUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteApiCreateOrConnectWithoutUserInput | FavoriteApiCreateOrConnectWithoutUserInput[]
    upsert?: FavoriteApiUpsertWithWhereUniqueWithoutUserInput | FavoriteApiUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FavoriteApiCreateManyUserInputEnvelope
    set?: FavoriteApiWhereUniqueInput | FavoriteApiWhereUniqueInput[]
    disconnect?: FavoriteApiWhereUniqueInput | FavoriteApiWhereUniqueInput[]
    delete?: FavoriteApiWhereUniqueInput | FavoriteApiWhereUniqueInput[]
    connect?: FavoriteApiWhereUniqueInput | FavoriteApiWhereUniqueInput[]
    update?: FavoriteApiUpdateWithWhereUniqueWithoutUserInput | FavoriteApiUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FavoriteApiUpdateManyWithWhereWithoutUserInput | FavoriteApiUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FavoriteApiScalarWhereInput | FavoriteApiScalarWhereInput[]
  }

  export type FavoriteStockUpdateManyWithoutUserNestedInput = {
    create?: XOR<FavoriteStockCreateWithoutUserInput, FavoriteStockUncheckedCreateWithoutUserInput> | FavoriteStockCreateWithoutUserInput[] | FavoriteStockUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteStockCreateOrConnectWithoutUserInput | FavoriteStockCreateOrConnectWithoutUserInput[]
    upsert?: FavoriteStockUpsertWithWhereUniqueWithoutUserInput | FavoriteStockUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FavoriteStockCreateManyUserInputEnvelope
    set?: FavoriteStockWhereUniqueInput | FavoriteStockWhereUniqueInput[]
    disconnect?: FavoriteStockWhereUniqueInput | FavoriteStockWhereUniqueInput[]
    delete?: FavoriteStockWhereUniqueInput | FavoriteStockWhereUniqueInput[]
    connect?: FavoriteStockWhereUniqueInput | FavoriteStockWhereUniqueInput[]
    update?: FavoriteStockUpdateWithWhereUniqueWithoutUserInput | FavoriteStockUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FavoriteStockUpdateManyWithWhereWithoutUserInput | FavoriteStockUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FavoriteStockScalarWhereInput | FavoriteStockScalarWhereInput[]
  }

  export type GoalUpdateManyWithoutUserNestedInput = {
    create?: XOR<GoalCreateWithoutUserInput, GoalUncheckedCreateWithoutUserInput> | GoalCreateWithoutUserInput[] | GoalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GoalCreateOrConnectWithoutUserInput | GoalCreateOrConnectWithoutUserInput[]
    upsert?: GoalUpsertWithWhereUniqueWithoutUserInput | GoalUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GoalCreateManyUserInputEnvelope
    set?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    disconnect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    delete?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    update?: GoalUpdateWithWhereUniqueWithoutUserInput | GoalUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GoalUpdateManyWithWhereWithoutUserInput | GoalUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GoalScalarWhereInput | GoalScalarWhereInput[]
  }

  export type LimitOrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<LimitOrderCreateWithoutUserInput, LimitOrderUncheckedCreateWithoutUserInput> | LimitOrderCreateWithoutUserInput[] | LimitOrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LimitOrderCreateOrConnectWithoutUserInput | LimitOrderCreateOrConnectWithoutUserInput[]
    upsert?: LimitOrderUpsertWithWhereUniqueWithoutUserInput | LimitOrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LimitOrderCreateManyUserInputEnvelope
    set?: LimitOrderWhereUniqueInput | LimitOrderWhereUniqueInput[]
    disconnect?: LimitOrderWhereUniqueInput | LimitOrderWhereUniqueInput[]
    delete?: LimitOrderWhereUniqueInput | LimitOrderWhereUniqueInput[]
    connect?: LimitOrderWhereUniqueInput | LimitOrderWhereUniqueInput[]
    update?: LimitOrderUpdateWithWhereUniqueWithoutUserInput | LimitOrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LimitOrderUpdateManyWithWhereWithoutUserInput | LimitOrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LimitOrderScalarWhereInput | LimitOrderScalarWhereInput[]
  }

  export type RedeemByUpdateManyWithoutUserNestedInput = {
    create?: XOR<RedeemByCreateWithoutUserInput, RedeemByUncheckedCreateWithoutUserInput> | RedeemByCreateWithoutUserInput[] | RedeemByUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RedeemByCreateOrConnectWithoutUserInput | RedeemByCreateOrConnectWithoutUserInput[]
    upsert?: RedeemByUpsertWithWhereUniqueWithoutUserInput | RedeemByUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RedeemByCreateManyUserInputEnvelope
    set?: RedeemByWhereUniqueInput | RedeemByWhereUniqueInput[]
    disconnect?: RedeemByWhereUniqueInput | RedeemByWhereUniqueInput[]
    delete?: RedeemByWhereUniqueInput | RedeemByWhereUniqueInput[]
    connect?: RedeemByWhereUniqueInput | RedeemByWhereUniqueInput[]
    update?: RedeemByUpdateWithWhereUniqueWithoutUserInput | RedeemByUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RedeemByUpdateManyWithWhereWithoutUserInput | RedeemByUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RedeemByScalarWhereInput | RedeemByScalarWhereInput[]
  }

  export type ReferralUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReferralCreateWithoutUserInput, ReferralUncheckedCreateWithoutUserInput> | ReferralCreateWithoutUserInput[] | ReferralUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutUserInput | ReferralCreateOrConnectWithoutUserInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutUserInput | ReferralUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReferralCreateManyUserInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutUserInput | ReferralUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutUserInput | ReferralUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type ReferralUsageUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReferralUsageCreateWithoutUserInput, ReferralUsageUncheckedCreateWithoutUserInput> | ReferralUsageCreateWithoutUserInput[] | ReferralUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReferralUsageCreateOrConnectWithoutUserInput | ReferralUsageCreateOrConnectWithoutUserInput[]
    upsert?: ReferralUsageUpsertWithWhereUniqueWithoutUserInput | ReferralUsageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReferralUsageCreateManyUserInputEnvelope
    set?: ReferralUsageWhereUniqueInput | ReferralUsageWhereUniqueInput[]
    disconnect?: ReferralUsageWhereUniqueInput | ReferralUsageWhereUniqueInput[]
    delete?: ReferralUsageWhereUniqueInput | ReferralUsageWhereUniqueInput[]
    connect?: ReferralUsageWhereUniqueInput | ReferralUsageWhereUniqueInput[]
    update?: ReferralUsageUpdateWithWhereUniqueWithoutUserInput | ReferralUsageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReferralUsageUpdateManyWithWhereWithoutUserInput | ReferralUsageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReferralUsageScalarWhereInput | ReferralUsageScalarWhereInput[]
  }

  export type TradeUpdateManyWithoutUserNestedInput = {
    create?: XOR<TradeCreateWithoutUserInput, TradeUncheckedCreateWithoutUserInput> | TradeCreateWithoutUserInput[] | TradeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TradeCreateOrConnectWithoutUserInput | TradeCreateOrConnectWithoutUserInput[]
    upsert?: TradeUpsertWithWhereUniqueWithoutUserInput | TradeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TradeCreateManyUserInputEnvelope
    set?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    disconnect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    delete?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    connect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    update?: TradeUpdateWithWhereUniqueWithoutUserInput | TradeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TradeUpdateManyWithWhereWithoutUserInput | TradeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TradeScalarWhereInput | TradeScalarWhereInput[]
  }

  export type ReferralUpdateOneWithoutReferredUsersNestedInput = {
    create?: XOR<ReferralCreateWithoutReferredUsersInput, ReferralUncheckedCreateWithoutReferredUsersInput>
    connectOrCreate?: ReferralCreateOrConnectWithoutReferredUsersInput
    upsert?: ReferralUpsertWithoutReferredUsersInput
    disconnect?: ReferralWhereInput | boolean
    delete?: ReferralWhereInput | boolean
    connect?: ReferralWhereUniqueInput
    update?: XOR<XOR<ReferralUpdateToOneWithWhereWithoutReferredUsersInput, ReferralUpdateWithoutReferredUsersInput>, ReferralUncheckedUpdateWithoutReferredUsersInput>
  }

  export type BlogCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BlogCommentCreateWithoutUserInput, BlogCommentUncheckedCreateWithoutUserInput> | BlogCommentCreateWithoutUserInput[] | BlogCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogCommentCreateOrConnectWithoutUserInput | BlogCommentCreateOrConnectWithoutUserInput[]
    upsert?: BlogCommentUpsertWithWhereUniqueWithoutUserInput | BlogCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BlogCommentCreateManyUserInputEnvelope
    set?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    disconnect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    delete?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    connect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    update?: BlogCommentUpdateWithWhereUniqueWithoutUserInput | BlogCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BlogCommentUpdateManyWithWhereWithoutUserInput | BlogCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BlogCommentScalarWhereInput | BlogCommentScalarWhereInput[]
  }

  export type BlogPostUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BlogPostCreateWithoutUserInput, BlogPostUncheckedCreateWithoutUserInput> | BlogPostCreateWithoutUserInput[] | BlogPostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutUserInput | BlogPostCreateOrConnectWithoutUserInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutUserInput | BlogPostUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BlogPostCreateManyUserInputEnvelope
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutUserInput | BlogPostUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutUserInput | BlogPostUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type FavoriteApiUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FavoriteApiCreateWithoutUserInput, FavoriteApiUncheckedCreateWithoutUserInput> | FavoriteApiCreateWithoutUserInput[] | FavoriteApiUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteApiCreateOrConnectWithoutUserInput | FavoriteApiCreateOrConnectWithoutUserInput[]
    upsert?: FavoriteApiUpsertWithWhereUniqueWithoutUserInput | FavoriteApiUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FavoriteApiCreateManyUserInputEnvelope
    set?: FavoriteApiWhereUniqueInput | FavoriteApiWhereUniqueInput[]
    disconnect?: FavoriteApiWhereUniqueInput | FavoriteApiWhereUniqueInput[]
    delete?: FavoriteApiWhereUniqueInput | FavoriteApiWhereUniqueInput[]
    connect?: FavoriteApiWhereUniqueInput | FavoriteApiWhereUniqueInput[]
    update?: FavoriteApiUpdateWithWhereUniqueWithoutUserInput | FavoriteApiUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FavoriteApiUpdateManyWithWhereWithoutUserInput | FavoriteApiUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FavoriteApiScalarWhereInput | FavoriteApiScalarWhereInput[]
  }

  export type FavoriteStockUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FavoriteStockCreateWithoutUserInput, FavoriteStockUncheckedCreateWithoutUserInput> | FavoriteStockCreateWithoutUserInput[] | FavoriteStockUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteStockCreateOrConnectWithoutUserInput | FavoriteStockCreateOrConnectWithoutUserInput[]
    upsert?: FavoriteStockUpsertWithWhereUniqueWithoutUserInput | FavoriteStockUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FavoriteStockCreateManyUserInputEnvelope
    set?: FavoriteStockWhereUniqueInput | FavoriteStockWhereUniqueInput[]
    disconnect?: FavoriteStockWhereUniqueInput | FavoriteStockWhereUniqueInput[]
    delete?: FavoriteStockWhereUniqueInput | FavoriteStockWhereUniqueInput[]
    connect?: FavoriteStockWhereUniqueInput | FavoriteStockWhereUniqueInput[]
    update?: FavoriteStockUpdateWithWhereUniqueWithoutUserInput | FavoriteStockUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FavoriteStockUpdateManyWithWhereWithoutUserInput | FavoriteStockUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FavoriteStockScalarWhereInput | FavoriteStockScalarWhereInput[]
  }

  export type GoalUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GoalCreateWithoutUserInput, GoalUncheckedCreateWithoutUserInput> | GoalCreateWithoutUserInput[] | GoalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GoalCreateOrConnectWithoutUserInput | GoalCreateOrConnectWithoutUserInput[]
    upsert?: GoalUpsertWithWhereUniqueWithoutUserInput | GoalUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GoalCreateManyUserInputEnvelope
    set?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    disconnect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    delete?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    update?: GoalUpdateWithWhereUniqueWithoutUserInput | GoalUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GoalUpdateManyWithWhereWithoutUserInput | GoalUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GoalScalarWhereInput | GoalScalarWhereInput[]
  }

  export type LimitOrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LimitOrderCreateWithoutUserInput, LimitOrderUncheckedCreateWithoutUserInput> | LimitOrderCreateWithoutUserInput[] | LimitOrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LimitOrderCreateOrConnectWithoutUserInput | LimitOrderCreateOrConnectWithoutUserInput[]
    upsert?: LimitOrderUpsertWithWhereUniqueWithoutUserInput | LimitOrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LimitOrderCreateManyUserInputEnvelope
    set?: LimitOrderWhereUniqueInput | LimitOrderWhereUniqueInput[]
    disconnect?: LimitOrderWhereUniqueInput | LimitOrderWhereUniqueInput[]
    delete?: LimitOrderWhereUniqueInput | LimitOrderWhereUniqueInput[]
    connect?: LimitOrderWhereUniqueInput | LimitOrderWhereUniqueInput[]
    update?: LimitOrderUpdateWithWhereUniqueWithoutUserInput | LimitOrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LimitOrderUpdateManyWithWhereWithoutUserInput | LimitOrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LimitOrderScalarWhereInput | LimitOrderScalarWhereInput[]
  }

  export type RedeemByUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RedeemByCreateWithoutUserInput, RedeemByUncheckedCreateWithoutUserInput> | RedeemByCreateWithoutUserInput[] | RedeemByUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RedeemByCreateOrConnectWithoutUserInput | RedeemByCreateOrConnectWithoutUserInput[]
    upsert?: RedeemByUpsertWithWhereUniqueWithoutUserInput | RedeemByUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RedeemByCreateManyUserInputEnvelope
    set?: RedeemByWhereUniqueInput | RedeemByWhereUniqueInput[]
    disconnect?: RedeemByWhereUniqueInput | RedeemByWhereUniqueInput[]
    delete?: RedeemByWhereUniqueInput | RedeemByWhereUniqueInput[]
    connect?: RedeemByWhereUniqueInput | RedeemByWhereUniqueInput[]
    update?: RedeemByUpdateWithWhereUniqueWithoutUserInput | RedeemByUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RedeemByUpdateManyWithWhereWithoutUserInput | RedeemByUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RedeemByScalarWhereInput | RedeemByScalarWhereInput[]
  }

  export type ReferralUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReferralCreateWithoutUserInput, ReferralUncheckedCreateWithoutUserInput> | ReferralCreateWithoutUserInput[] | ReferralUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutUserInput | ReferralCreateOrConnectWithoutUserInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutUserInput | ReferralUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReferralCreateManyUserInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutUserInput | ReferralUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutUserInput | ReferralUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type ReferralUsageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReferralUsageCreateWithoutUserInput, ReferralUsageUncheckedCreateWithoutUserInput> | ReferralUsageCreateWithoutUserInput[] | ReferralUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReferralUsageCreateOrConnectWithoutUserInput | ReferralUsageCreateOrConnectWithoutUserInput[]
    upsert?: ReferralUsageUpsertWithWhereUniqueWithoutUserInput | ReferralUsageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReferralUsageCreateManyUserInputEnvelope
    set?: ReferralUsageWhereUniqueInput | ReferralUsageWhereUniqueInput[]
    disconnect?: ReferralUsageWhereUniqueInput | ReferralUsageWhereUniqueInput[]
    delete?: ReferralUsageWhereUniqueInput | ReferralUsageWhereUniqueInput[]
    connect?: ReferralUsageWhereUniqueInput | ReferralUsageWhereUniqueInput[]
    update?: ReferralUsageUpdateWithWhereUniqueWithoutUserInput | ReferralUsageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReferralUsageUpdateManyWithWhereWithoutUserInput | ReferralUsageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReferralUsageScalarWhereInput | ReferralUsageScalarWhereInput[]
  }

  export type TradeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TradeCreateWithoutUserInput, TradeUncheckedCreateWithoutUserInput> | TradeCreateWithoutUserInput[] | TradeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TradeCreateOrConnectWithoutUserInput | TradeCreateOrConnectWithoutUserInput[]
    upsert?: TradeUpsertWithWhereUniqueWithoutUserInput | TradeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TradeCreateManyUserInputEnvelope
    set?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    disconnect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    delete?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    connect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    update?: TradeUpdateWithWhereUniqueWithoutUserInput | TradeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TradeUpdateManyWithWhereWithoutUserInput | TradeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TradeScalarWhereInput | TradeScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutReferralsInput = {
    create?: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsInput
    connect?: UserWhereUniqueInput
  }

  export type ReferralUsageCreateNestedManyWithoutReferralInput = {
    create?: XOR<ReferralUsageCreateWithoutReferralInput, ReferralUsageUncheckedCreateWithoutReferralInput> | ReferralUsageCreateWithoutReferralInput[] | ReferralUsageUncheckedCreateWithoutReferralInput[]
    connectOrCreate?: ReferralUsageCreateOrConnectWithoutReferralInput | ReferralUsageCreateOrConnectWithoutReferralInput[]
    createMany?: ReferralUsageCreateManyReferralInputEnvelope
    connect?: ReferralUsageWhereUniqueInput | ReferralUsageWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutReferredByInput = {
    create?: XOR<UserCreateWithoutReferredByInput, UserUncheckedCreateWithoutReferredByInput> | UserCreateWithoutReferredByInput[] | UserUncheckedCreateWithoutReferredByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutReferredByInput | UserCreateOrConnectWithoutReferredByInput[]
    createMany?: UserCreateManyReferredByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ReferralUsageUncheckedCreateNestedManyWithoutReferralInput = {
    create?: XOR<ReferralUsageCreateWithoutReferralInput, ReferralUsageUncheckedCreateWithoutReferralInput> | ReferralUsageCreateWithoutReferralInput[] | ReferralUsageUncheckedCreateWithoutReferralInput[]
    connectOrCreate?: ReferralUsageCreateOrConnectWithoutReferralInput | ReferralUsageCreateOrConnectWithoutReferralInput[]
    createMany?: ReferralUsageCreateManyReferralInputEnvelope
    connect?: ReferralUsageWhereUniqueInput | ReferralUsageWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutReferredByInput = {
    create?: XOR<UserCreateWithoutReferredByInput, UserUncheckedCreateWithoutReferredByInput> | UserCreateWithoutReferredByInput[] | UserUncheckedCreateWithoutReferredByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutReferredByInput | UserCreateOrConnectWithoutReferredByInput[]
    createMany?: UserCreateManyReferredByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutReferralsNestedInput = {
    create?: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsInput
    upsert?: UserUpsertWithoutReferralsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReferralsInput, UserUpdateWithoutReferralsInput>, UserUncheckedUpdateWithoutReferralsInput>
  }

  export type ReferralUsageUpdateManyWithoutReferralNestedInput = {
    create?: XOR<ReferralUsageCreateWithoutReferralInput, ReferralUsageUncheckedCreateWithoutReferralInput> | ReferralUsageCreateWithoutReferralInput[] | ReferralUsageUncheckedCreateWithoutReferralInput[]
    connectOrCreate?: ReferralUsageCreateOrConnectWithoutReferralInput | ReferralUsageCreateOrConnectWithoutReferralInput[]
    upsert?: ReferralUsageUpsertWithWhereUniqueWithoutReferralInput | ReferralUsageUpsertWithWhereUniqueWithoutReferralInput[]
    createMany?: ReferralUsageCreateManyReferralInputEnvelope
    set?: ReferralUsageWhereUniqueInput | ReferralUsageWhereUniqueInput[]
    disconnect?: ReferralUsageWhereUniqueInput | ReferralUsageWhereUniqueInput[]
    delete?: ReferralUsageWhereUniqueInput | ReferralUsageWhereUniqueInput[]
    connect?: ReferralUsageWhereUniqueInput | ReferralUsageWhereUniqueInput[]
    update?: ReferralUsageUpdateWithWhereUniqueWithoutReferralInput | ReferralUsageUpdateWithWhereUniqueWithoutReferralInput[]
    updateMany?: ReferralUsageUpdateManyWithWhereWithoutReferralInput | ReferralUsageUpdateManyWithWhereWithoutReferralInput[]
    deleteMany?: ReferralUsageScalarWhereInput | ReferralUsageScalarWhereInput[]
  }

  export type UserUpdateManyWithoutReferredByNestedInput = {
    create?: XOR<UserCreateWithoutReferredByInput, UserUncheckedCreateWithoutReferredByInput> | UserCreateWithoutReferredByInput[] | UserUncheckedCreateWithoutReferredByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutReferredByInput | UserCreateOrConnectWithoutReferredByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutReferredByInput | UserUpsertWithWhereUniqueWithoutReferredByInput[]
    createMany?: UserCreateManyReferredByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutReferredByInput | UserUpdateWithWhereUniqueWithoutReferredByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutReferredByInput | UserUpdateManyWithWhereWithoutReferredByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ReferralUsageUncheckedUpdateManyWithoutReferralNestedInput = {
    create?: XOR<ReferralUsageCreateWithoutReferralInput, ReferralUsageUncheckedCreateWithoutReferralInput> | ReferralUsageCreateWithoutReferralInput[] | ReferralUsageUncheckedCreateWithoutReferralInput[]
    connectOrCreate?: ReferralUsageCreateOrConnectWithoutReferralInput | ReferralUsageCreateOrConnectWithoutReferralInput[]
    upsert?: ReferralUsageUpsertWithWhereUniqueWithoutReferralInput | ReferralUsageUpsertWithWhereUniqueWithoutReferralInput[]
    createMany?: ReferralUsageCreateManyReferralInputEnvelope
    set?: ReferralUsageWhereUniqueInput | ReferralUsageWhereUniqueInput[]
    disconnect?: ReferralUsageWhereUniqueInput | ReferralUsageWhereUniqueInput[]
    delete?: ReferralUsageWhereUniqueInput | ReferralUsageWhereUniqueInput[]
    connect?: ReferralUsageWhereUniqueInput | ReferralUsageWhereUniqueInput[]
    update?: ReferralUsageUpdateWithWhereUniqueWithoutReferralInput | ReferralUsageUpdateWithWhereUniqueWithoutReferralInput[]
    updateMany?: ReferralUsageUpdateManyWithWhereWithoutReferralInput | ReferralUsageUpdateManyWithWhereWithoutReferralInput[]
    deleteMany?: ReferralUsageScalarWhereInput | ReferralUsageScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutReferredByNestedInput = {
    create?: XOR<UserCreateWithoutReferredByInput, UserUncheckedCreateWithoutReferredByInput> | UserCreateWithoutReferredByInput[] | UserUncheckedCreateWithoutReferredByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutReferredByInput | UserCreateOrConnectWithoutReferredByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutReferredByInput | UserUpsertWithWhereUniqueWithoutReferredByInput[]
    createMany?: UserCreateManyReferredByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutReferredByInput | UserUpdateWithWhereUniqueWithoutReferredByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutReferredByInput | UserUpdateManyWithWhereWithoutReferredByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ReferralCreateNestedOneWithoutReferralUsagesInput = {
    create?: XOR<ReferralCreateWithoutReferralUsagesInput, ReferralUncheckedCreateWithoutReferralUsagesInput>
    connectOrCreate?: ReferralCreateOrConnectWithoutReferralUsagesInput
    connect?: ReferralWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReferralUsagesInput = {
    create?: XOR<UserCreateWithoutReferralUsagesInput, UserUncheckedCreateWithoutReferralUsagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralUsagesInput
    connect?: UserWhereUniqueInput
  }

  export type ReferralUpdateOneWithoutReferralUsagesNestedInput = {
    create?: XOR<ReferralCreateWithoutReferralUsagesInput, ReferralUncheckedCreateWithoutReferralUsagesInput>
    connectOrCreate?: ReferralCreateOrConnectWithoutReferralUsagesInput
    upsert?: ReferralUpsertWithoutReferralUsagesInput
    disconnect?: ReferralWhereInput | boolean
    delete?: ReferralWhereInput | boolean
    connect?: ReferralWhereUniqueInput
    update?: XOR<XOR<ReferralUpdateToOneWithWhereWithoutReferralUsagesInput, ReferralUpdateWithoutReferralUsagesInput>, ReferralUncheckedUpdateWithoutReferralUsagesInput>
  }

  export type UserUpdateOneWithoutReferralUsagesNestedInput = {
    create?: XOR<UserCreateWithoutReferralUsagesInput, UserUncheckedCreateWithoutReferralUsagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralUsagesInput
    upsert?: UserUpsertWithoutReferralUsagesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReferralUsagesInput, UserUpdateWithoutReferralUsagesInput>, UserUncheckedUpdateWithoutReferralUsagesInput>
  }

  export type UserCreateNestedOneWithoutCommentInput = {
    create?: XOR<UserCreateWithoutCommentInput, UserUncheckedCreateWithoutCommentInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCommentNestedInput = {
    create?: XOR<UserCreateWithoutCommentInput, UserUncheckedCreateWithoutCommentInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentInput
    upsert?: UserUpsertWithoutCommentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentInput, UserUpdateWithoutCommentInput>, UserUncheckedUpdateWithoutCommentInput>
  }

  export type UserCreateNestedOneWithoutFavoriteApiInput = {
    create?: XOR<UserCreateWithoutFavoriteApiInput, UserUncheckedCreateWithoutFavoriteApiInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavoriteApiInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFavoriteApiNestedInput = {
    create?: XOR<UserCreateWithoutFavoriteApiInput, UserUncheckedCreateWithoutFavoriteApiInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavoriteApiInput
    upsert?: UserUpsertWithoutFavoriteApiInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFavoriteApiInput, UserUpdateWithoutFavoriteApiInput>, UserUncheckedUpdateWithoutFavoriteApiInput>
  }

  export type UserCreateNestedOneWithoutGoalInput = {
    create?: XOR<UserCreateWithoutGoalInput, UserUncheckedCreateWithoutGoalInput>
    connectOrCreate?: UserCreateOrConnectWithoutGoalInput
    connect?: UserWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutGoalNestedInput = {
    create?: XOR<UserCreateWithoutGoalInput, UserUncheckedCreateWithoutGoalInput>
    connectOrCreate?: UserCreateOrConnectWithoutGoalInput
    upsert?: UserUpsertWithoutGoalInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGoalInput, UserUpdateWithoutGoalInput>, UserUncheckedUpdateWithoutGoalInput>
  }

  export type RewardCreateNestedOneWithoutRedeemedByInput = {
    create?: XOR<RewardCreateWithoutRedeemedByInput, RewardUncheckedCreateWithoutRedeemedByInput>
    connectOrCreate?: RewardCreateOrConnectWithoutRedeemedByInput
    connect?: RewardWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRedeemByInput = {
    create?: XOR<UserCreateWithoutRedeemByInput, UserUncheckedCreateWithoutRedeemByInput>
    connectOrCreate?: UserCreateOrConnectWithoutRedeemByInput
    connect?: UserWhereUniqueInput
  }

  export type RewardUpdateOneRequiredWithoutRedeemedByNestedInput = {
    create?: XOR<RewardCreateWithoutRedeemedByInput, RewardUncheckedCreateWithoutRedeemedByInput>
    connectOrCreate?: RewardCreateOrConnectWithoutRedeemedByInput
    upsert?: RewardUpsertWithoutRedeemedByInput
    connect?: RewardWhereUniqueInput
    update?: XOR<XOR<RewardUpdateToOneWithWhereWithoutRedeemedByInput, RewardUpdateWithoutRedeemedByInput>, RewardUncheckedUpdateWithoutRedeemedByInput>
  }

  export type UserUpdateOneRequiredWithoutRedeemByNestedInput = {
    create?: XOR<UserCreateWithoutRedeemByInput, UserUncheckedCreateWithoutRedeemByInput>
    connectOrCreate?: UserCreateOrConnectWithoutRedeemByInput
    upsert?: UserUpsertWithoutRedeemByInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRedeemByInput, UserUpdateWithoutRedeemByInput>, UserUncheckedUpdateWithoutRedeemByInput>
  }

  export type QuizQuestionCreateoptionsInput = {
    set: string[]
  }

  export type QuizQuestionUpdateoptionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type RedeemByCreateNestedManyWithoutRewardInput = {
    create?: XOR<RedeemByCreateWithoutRewardInput, RedeemByUncheckedCreateWithoutRewardInput> | RedeemByCreateWithoutRewardInput[] | RedeemByUncheckedCreateWithoutRewardInput[]
    connectOrCreate?: RedeemByCreateOrConnectWithoutRewardInput | RedeemByCreateOrConnectWithoutRewardInput[]
    createMany?: RedeemByCreateManyRewardInputEnvelope
    connect?: RedeemByWhereUniqueInput | RedeemByWhereUniqueInput[]
  }

  export type RedeemByUncheckedCreateNestedManyWithoutRewardInput = {
    create?: XOR<RedeemByCreateWithoutRewardInput, RedeemByUncheckedCreateWithoutRewardInput> | RedeemByCreateWithoutRewardInput[] | RedeemByUncheckedCreateWithoutRewardInput[]
    connectOrCreate?: RedeemByCreateOrConnectWithoutRewardInput | RedeemByCreateOrConnectWithoutRewardInput[]
    createMany?: RedeemByCreateManyRewardInputEnvelope
    connect?: RedeemByWhereUniqueInput | RedeemByWhereUniqueInput[]
  }

  export type RedeemByUpdateManyWithoutRewardNestedInput = {
    create?: XOR<RedeemByCreateWithoutRewardInput, RedeemByUncheckedCreateWithoutRewardInput> | RedeemByCreateWithoutRewardInput[] | RedeemByUncheckedCreateWithoutRewardInput[]
    connectOrCreate?: RedeemByCreateOrConnectWithoutRewardInput | RedeemByCreateOrConnectWithoutRewardInput[]
    upsert?: RedeemByUpsertWithWhereUniqueWithoutRewardInput | RedeemByUpsertWithWhereUniqueWithoutRewardInput[]
    createMany?: RedeemByCreateManyRewardInputEnvelope
    set?: RedeemByWhereUniqueInput | RedeemByWhereUniqueInput[]
    disconnect?: RedeemByWhereUniqueInput | RedeemByWhereUniqueInput[]
    delete?: RedeemByWhereUniqueInput | RedeemByWhereUniqueInput[]
    connect?: RedeemByWhereUniqueInput | RedeemByWhereUniqueInput[]
    update?: RedeemByUpdateWithWhereUniqueWithoutRewardInput | RedeemByUpdateWithWhereUniqueWithoutRewardInput[]
    updateMany?: RedeemByUpdateManyWithWhereWithoutRewardInput | RedeemByUpdateManyWithWhereWithoutRewardInput[]
    deleteMany?: RedeemByScalarWhereInput | RedeemByScalarWhereInput[]
  }

  export type RedeemByUncheckedUpdateManyWithoutRewardNestedInput = {
    create?: XOR<RedeemByCreateWithoutRewardInput, RedeemByUncheckedCreateWithoutRewardInput> | RedeemByCreateWithoutRewardInput[] | RedeemByUncheckedCreateWithoutRewardInput[]
    connectOrCreate?: RedeemByCreateOrConnectWithoutRewardInput | RedeemByCreateOrConnectWithoutRewardInput[]
    upsert?: RedeemByUpsertWithWhereUniqueWithoutRewardInput | RedeemByUpsertWithWhereUniqueWithoutRewardInput[]
    createMany?: RedeemByCreateManyRewardInputEnvelope
    set?: RedeemByWhereUniqueInput | RedeemByWhereUniqueInput[]
    disconnect?: RedeemByWhereUniqueInput | RedeemByWhereUniqueInput[]
    delete?: RedeemByWhereUniqueInput | RedeemByWhereUniqueInput[]
    connect?: RedeemByWhereUniqueInput | RedeemByWhereUniqueInput[]
    update?: RedeemByUpdateWithWhereUniqueWithoutRewardInput | RedeemByUpdateWithWhereUniqueWithoutRewardInput[]
    updateMany?: RedeemByUpdateManyWithWhereWithoutRewardInput | RedeemByUpdateManyWithWhereWithoutRewardInput[]
    deleteMany?: RedeemByScalarWhereInput | RedeemByScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type StatusCreateWithoutTasksInput = {
    text: string
  }

  export type StatusUncheckedCreateWithoutTasksInput = {
    id?: number
    text: string
  }

  export type StatusCreateOrConnectWithoutTasksInput = {
    where: StatusWhereUniqueInput
    create: XOR<StatusCreateWithoutTasksInput, StatusUncheckedCreateWithoutTasksInput>
  }

  export type TaskAssignmentCreateWithoutTaskInput = {
    assignedAt?: Date | string
    person: PersonCreateNestedOneWithoutTasksInput
  }

  export type TaskAssignmentUncheckedCreateWithoutTaskInput = {
    personId: number
    assignedAt?: Date | string
  }

  export type TaskAssignmentCreateOrConnectWithoutTaskInput = {
    where: TaskAssignmentWhereUniqueInput
    create: XOR<TaskAssignmentCreateWithoutTaskInput, TaskAssignmentUncheckedCreateWithoutTaskInput>
  }

  export type TaskAssignmentCreateManyTaskInputEnvelope = {
    data: TaskAssignmentCreateManyTaskInput | TaskAssignmentCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type StatusUpsertWithoutTasksInput = {
    update: XOR<StatusUpdateWithoutTasksInput, StatusUncheckedUpdateWithoutTasksInput>
    create: XOR<StatusCreateWithoutTasksInput, StatusUncheckedCreateWithoutTasksInput>
    where?: StatusWhereInput
  }

  export type StatusUpdateToOneWithWhereWithoutTasksInput = {
    where?: StatusWhereInput
    data: XOR<StatusUpdateWithoutTasksInput, StatusUncheckedUpdateWithoutTasksInput>
  }

  export type StatusUpdateWithoutTasksInput = {
    text?: StringFieldUpdateOperationsInput | string
  }

  export type StatusUncheckedUpdateWithoutTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
  }

  export type TaskAssignmentUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskAssignmentWhereUniqueInput
    update: XOR<TaskAssignmentUpdateWithoutTaskInput, TaskAssignmentUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskAssignmentCreateWithoutTaskInput, TaskAssignmentUncheckedCreateWithoutTaskInput>
  }

  export type TaskAssignmentUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskAssignmentWhereUniqueInput
    data: XOR<TaskAssignmentUpdateWithoutTaskInput, TaskAssignmentUncheckedUpdateWithoutTaskInput>
  }

  export type TaskAssignmentUpdateManyWithWhereWithoutTaskInput = {
    where: TaskAssignmentScalarWhereInput
    data: XOR<TaskAssignmentUpdateManyMutationInput, TaskAssignmentUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskAssignmentScalarWhereInput = {
    AND?: TaskAssignmentScalarWhereInput | TaskAssignmentScalarWhereInput[]
    OR?: TaskAssignmentScalarWhereInput[]
    NOT?: TaskAssignmentScalarWhereInput | TaskAssignmentScalarWhereInput[]
    taskId?: IntFilter<"TaskAssignment"> | number
    personId?: IntFilter<"TaskAssignment"> | number
    assignedAt?: DateTimeFilter<"TaskAssignment"> | Date | string
  }

  export type TaskCreateWithoutStatusInput = {
    name: string
    persons?: TaskAssignmentCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutStatusInput = {
    id?: number
    name: string
    persons?: TaskAssignmentUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutStatusInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutStatusInput, TaskUncheckedCreateWithoutStatusInput>
  }

  export type TaskCreateManyStatusInputEnvelope = {
    data: TaskCreateManyStatusInput | TaskCreateManyStatusInput[]
    skipDuplicates?: boolean
  }

  export type TaskUpsertWithWhereUniqueWithoutStatusInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutStatusInput, TaskUncheckedUpdateWithoutStatusInput>
    create: XOR<TaskCreateWithoutStatusInput, TaskUncheckedCreateWithoutStatusInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutStatusInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutStatusInput, TaskUncheckedUpdateWithoutStatusInput>
  }

  export type TaskUpdateManyWithWhereWithoutStatusInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutStatusInput>
  }

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[]
    OR?: TaskScalarWhereInput[]
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[]
    id?: IntFilter<"Task"> | number
    name?: StringFilter<"Task"> | string
    statusId?: IntFilter<"Task"> | number
  }

  export type TaskAssignmentCreateWithoutPersonInput = {
    assignedAt?: Date | string
    task: TaskCreateNestedOneWithoutPersonsInput
  }

  export type TaskAssignmentUncheckedCreateWithoutPersonInput = {
    taskId: number
    assignedAt?: Date | string
  }

  export type TaskAssignmentCreateOrConnectWithoutPersonInput = {
    where: TaskAssignmentWhereUniqueInput
    create: XOR<TaskAssignmentCreateWithoutPersonInput, TaskAssignmentUncheckedCreateWithoutPersonInput>
  }

  export type TaskAssignmentCreateManyPersonInputEnvelope = {
    data: TaskAssignmentCreateManyPersonInput | TaskAssignmentCreateManyPersonInput[]
    skipDuplicates?: boolean
  }

  export type TaskAssignmentUpsertWithWhereUniqueWithoutPersonInput = {
    where: TaskAssignmentWhereUniqueInput
    update: XOR<TaskAssignmentUpdateWithoutPersonInput, TaskAssignmentUncheckedUpdateWithoutPersonInput>
    create: XOR<TaskAssignmentCreateWithoutPersonInput, TaskAssignmentUncheckedCreateWithoutPersonInput>
  }

  export type TaskAssignmentUpdateWithWhereUniqueWithoutPersonInput = {
    where: TaskAssignmentWhereUniqueInput
    data: XOR<TaskAssignmentUpdateWithoutPersonInput, TaskAssignmentUncheckedUpdateWithoutPersonInput>
  }

  export type TaskAssignmentUpdateManyWithWhereWithoutPersonInput = {
    where: TaskAssignmentScalarWhereInput
    data: XOR<TaskAssignmentUpdateManyMutationInput, TaskAssignmentUncheckedUpdateManyWithoutPersonInput>
  }

  export type PersonCreateWithoutTasksInput = {
    email: string
    name: string
    avatar?: string | null
  }

  export type PersonUncheckedCreateWithoutTasksInput = {
    id?: number
    email: string
    name: string
    avatar?: string | null
  }

  export type PersonCreateOrConnectWithoutTasksInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutTasksInput, PersonUncheckedCreateWithoutTasksInput>
  }

  export type TaskCreateWithoutPersonsInput = {
    name: string
    status: StatusCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutPersonsInput = {
    id?: number
    name: string
    statusId: number
  }

  export type TaskCreateOrConnectWithoutPersonsInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutPersonsInput, TaskUncheckedCreateWithoutPersonsInput>
  }

  export type PersonUpsertWithoutTasksInput = {
    update: XOR<PersonUpdateWithoutTasksInput, PersonUncheckedUpdateWithoutTasksInput>
    create: XOR<PersonCreateWithoutTasksInput, PersonUncheckedCreateWithoutTasksInput>
    where?: PersonWhereInput
  }

  export type PersonUpdateToOneWithWhereWithoutTasksInput = {
    where?: PersonWhereInput
    data: XOR<PersonUpdateWithoutTasksInput, PersonUncheckedUpdateWithoutTasksInput>
  }

  export type PersonUpdateWithoutTasksInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonUncheckedUpdateWithoutTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskUpsertWithoutPersonsInput = {
    update: XOR<TaskUpdateWithoutPersonsInput, TaskUncheckedUpdateWithoutPersonsInput>
    create: XOR<TaskCreateWithoutPersonsInput, TaskUncheckedCreateWithoutPersonsInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutPersonsInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutPersonsInput, TaskUncheckedUpdateWithoutPersonsInput>
  }

  export type TaskUpdateWithoutPersonsInput = {
    name?: StringFieldUpdateOperationsInput | string
    status?: StatusUpdateOneRequiredWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutPersonsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    statusId?: IntFieldUpdateOperationsInput | number
  }

  export type StockCreateWithoutCompanyInput = {
    symbol: string
    sector?: string | null
    change?: number | null
    favoriteStock?: FavoriteStockCreateNestedManyWithoutStockInput
    hist_prices?: HistPriceCreateNestedManyWithoutStockInput
    limitOrder?: LimitOrderCreateNestedManyWithoutStockInput
    trading?: TradeCreateNestedManyWithoutStockInput
  }

  export type StockUncheckedCreateWithoutCompanyInput = {
    stock_id?: number
    symbol: string
    sector?: string | null
    change?: number | null
    favoriteStock?: FavoriteStockUncheckedCreateNestedManyWithoutStockInput
    hist_prices?: HistPriceUncheckedCreateNestedManyWithoutStockInput
    limitOrder?: LimitOrderUncheckedCreateNestedManyWithoutStockInput
    trading?: TradeUncheckedCreateNestedManyWithoutStockInput
  }

  export type StockCreateOrConnectWithoutCompanyInput = {
    where: StockWhereUniqueInput
    create: XOR<StockCreateWithoutCompanyInput, StockUncheckedCreateWithoutCompanyInput>
  }

  export type StockCreateManyCompanyInputEnvelope = {
    data: StockCreateManyCompanyInput | StockCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type StockUpsertWithWhereUniqueWithoutCompanyInput = {
    where: StockWhereUniqueInput
    update: XOR<StockUpdateWithoutCompanyInput, StockUncheckedUpdateWithoutCompanyInput>
    create: XOR<StockCreateWithoutCompanyInput, StockUncheckedCreateWithoutCompanyInput>
  }

  export type StockUpdateWithWhereUniqueWithoutCompanyInput = {
    where: StockWhereUniqueInput
    data: XOR<StockUpdateWithoutCompanyInput, StockUncheckedUpdateWithoutCompanyInput>
  }

  export type StockUpdateManyWithWhereWithoutCompanyInput = {
    where: StockScalarWhereInput
    data: XOR<StockUpdateManyMutationInput, StockUncheckedUpdateManyWithoutCompanyInput>
  }

  export type StockScalarWhereInput = {
    AND?: StockScalarWhereInput | StockScalarWhereInput[]
    OR?: StockScalarWhereInput[]
    NOT?: StockScalarWhereInput | StockScalarWhereInput[]
    stock_id?: IntFilter<"Stock"> | number
    symbol?: StringFilter<"Stock"> | string
    sector?: StringNullableFilter<"Stock"> | string | null
    company_id?: IntNullableFilter<"Stock"> | number | null
    change?: IntNullableFilter<"Stock"> | number | null
  }

  export type FavoriteStockCreateWithoutStockInput = {
    user: UserCreateNestedOneWithoutFavoriteStocksInput
  }

  export type FavoriteStockUncheckedCreateWithoutStockInput = {
    id?: number
    userId: number
  }

  export type FavoriteStockCreateOrConnectWithoutStockInput = {
    where: FavoriteStockWhereUniqueInput
    create: XOR<FavoriteStockCreateWithoutStockInput, FavoriteStockUncheckedCreateWithoutStockInput>
  }

  export type FavoriteStockCreateManyStockInputEnvelope = {
    data: FavoriteStockCreateManyStockInput | FavoriteStockCreateManyStockInput[]
    skipDuplicates?: boolean
  }

  export type HistPriceCreateWithoutStockInput = {
    date: Date | string
    open_price?: Decimal | DecimalJsLike | number | string | null
    high_price?: Decimal | DecimalJsLike | number | string | null
    low_price?: Decimal | DecimalJsLike | number | string | null
    close_price: Decimal | DecimalJsLike | number | string
    volume?: bigint | number | null
  }

  export type HistPriceUncheckedCreateWithoutStockInput = {
    price_id?: number
    date: Date | string
    open_price?: Decimal | DecimalJsLike | number | string | null
    high_price?: Decimal | DecimalJsLike | number | string | null
    low_price?: Decimal | DecimalJsLike | number | string | null
    close_price: Decimal | DecimalJsLike | number | string
    volume?: bigint | number | null
  }

  export type HistPriceCreateOrConnectWithoutStockInput = {
    where: HistPriceWhereUniqueInput
    create: XOR<HistPriceCreateWithoutStockInput, HistPriceUncheckedCreateWithoutStockInput>
  }

  export type HistPriceCreateManyStockInputEnvelope = {
    data: HistPriceCreateManyStockInput | HistPriceCreateManyStockInput[]
    skipDuplicates?: boolean
  }

  export type LimitOrderCreateWithoutStockInput = {
    quantity: number
    limitPrice: Decimal | DecimalJsLike | number | string
    orderType: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLimitOrdersInput
  }

  export type LimitOrderUncheckedCreateWithoutStockInput = {
    id?: number
    userId: number
    quantity: number
    limitPrice: Decimal | DecimalJsLike | number | string
    orderType: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LimitOrderCreateOrConnectWithoutStockInput = {
    where: LimitOrderWhereUniqueInput
    create: XOR<LimitOrderCreateWithoutStockInput, LimitOrderUncheckedCreateWithoutStockInput>
  }

  export type LimitOrderCreateManyStockInputEnvelope = {
    data: LimitOrderCreateManyStockInput | LimitOrderCreateManyStockInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutStocksInput = {
    symbol: string
    name: string
    founded: number
    employees: number
    address: string
    city: string
    country: string
    zipCode: string
    phone: string
    website: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type CompanyUncheckedCreateWithoutStocksInput = {
    id?: number
    symbol: string
    name: string
    founded: number
    employees: number
    address: string
    city: string
    country: string
    zipCode: string
    phone: string
    website: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type CompanyCreateOrConnectWithoutStocksInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutStocksInput, CompanyUncheckedCreateWithoutStocksInput>
  }

  export type TradeCreateWithoutStockInput = {
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    tradeType: string
    tradeDate?: Date | string
    user?: UserCreateNestedOneWithoutTradingInput
  }

  export type TradeUncheckedCreateWithoutStockInput = {
    id?: number
    userId?: number | null
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    tradeType: string
    tradeDate?: Date | string
  }

  export type TradeCreateOrConnectWithoutStockInput = {
    where: TradeWhereUniqueInput
    create: XOR<TradeCreateWithoutStockInput, TradeUncheckedCreateWithoutStockInput>
  }

  export type TradeCreateManyStockInputEnvelope = {
    data: TradeCreateManyStockInput | TradeCreateManyStockInput[]
    skipDuplicates?: boolean
  }

  export type FavoriteStockUpsertWithWhereUniqueWithoutStockInput = {
    where: FavoriteStockWhereUniqueInput
    update: XOR<FavoriteStockUpdateWithoutStockInput, FavoriteStockUncheckedUpdateWithoutStockInput>
    create: XOR<FavoriteStockCreateWithoutStockInput, FavoriteStockUncheckedCreateWithoutStockInput>
  }

  export type FavoriteStockUpdateWithWhereUniqueWithoutStockInput = {
    where: FavoriteStockWhereUniqueInput
    data: XOR<FavoriteStockUpdateWithoutStockInput, FavoriteStockUncheckedUpdateWithoutStockInput>
  }

  export type FavoriteStockUpdateManyWithWhereWithoutStockInput = {
    where: FavoriteStockScalarWhereInput
    data: XOR<FavoriteStockUpdateManyMutationInput, FavoriteStockUncheckedUpdateManyWithoutStockInput>
  }

  export type FavoriteStockScalarWhereInput = {
    AND?: FavoriteStockScalarWhereInput | FavoriteStockScalarWhereInput[]
    OR?: FavoriteStockScalarWhereInput[]
    NOT?: FavoriteStockScalarWhereInput | FavoriteStockScalarWhereInput[]
    id?: IntFilter<"FavoriteStock"> | number
    userId?: IntFilter<"FavoriteStock"> | number
    stockId?: IntFilter<"FavoriteStock"> | number
  }

  export type HistPriceUpsertWithWhereUniqueWithoutStockInput = {
    where: HistPriceWhereUniqueInput
    update: XOR<HistPriceUpdateWithoutStockInput, HistPriceUncheckedUpdateWithoutStockInput>
    create: XOR<HistPriceCreateWithoutStockInput, HistPriceUncheckedCreateWithoutStockInput>
  }

  export type HistPriceUpdateWithWhereUniqueWithoutStockInput = {
    where: HistPriceWhereUniqueInput
    data: XOR<HistPriceUpdateWithoutStockInput, HistPriceUncheckedUpdateWithoutStockInput>
  }

  export type HistPriceUpdateManyWithWhereWithoutStockInput = {
    where: HistPriceScalarWhereInput
    data: XOR<HistPriceUpdateManyMutationInput, HistPriceUncheckedUpdateManyWithoutStockInput>
  }

  export type HistPriceScalarWhereInput = {
    AND?: HistPriceScalarWhereInput | HistPriceScalarWhereInput[]
    OR?: HistPriceScalarWhereInput[]
    NOT?: HistPriceScalarWhereInput | HistPriceScalarWhereInput[]
    price_id?: IntFilter<"HistPrice"> | number
    stock_id?: IntFilter<"HistPrice"> | number
    date?: DateTimeFilter<"HistPrice"> | Date | string
    open_price?: DecimalNullableFilter<"HistPrice"> | Decimal | DecimalJsLike | number | string | null
    high_price?: DecimalNullableFilter<"HistPrice"> | Decimal | DecimalJsLike | number | string | null
    low_price?: DecimalNullableFilter<"HistPrice"> | Decimal | DecimalJsLike | number | string | null
    close_price?: DecimalFilter<"HistPrice"> | Decimal | DecimalJsLike | number | string
    volume?: BigIntNullableFilter<"HistPrice"> | bigint | number | null
  }

  export type LimitOrderUpsertWithWhereUniqueWithoutStockInput = {
    where: LimitOrderWhereUniqueInput
    update: XOR<LimitOrderUpdateWithoutStockInput, LimitOrderUncheckedUpdateWithoutStockInput>
    create: XOR<LimitOrderCreateWithoutStockInput, LimitOrderUncheckedCreateWithoutStockInput>
  }

  export type LimitOrderUpdateWithWhereUniqueWithoutStockInput = {
    where: LimitOrderWhereUniqueInput
    data: XOR<LimitOrderUpdateWithoutStockInput, LimitOrderUncheckedUpdateWithoutStockInput>
  }

  export type LimitOrderUpdateManyWithWhereWithoutStockInput = {
    where: LimitOrderScalarWhereInput
    data: XOR<LimitOrderUpdateManyMutationInput, LimitOrderUncheckedUpdateManyWithoutStockInput>
  }

  export type LimitOrderScalarWhereInput = {
    AND?: LimitOrderScalarWhereInput | LimitOrderScalarWhereInput[]
    OR?: LimitOrderScalarWhereInput[]
    NOT?: LimitOrderScalarWhereInput | LimitOrderScalarWhereInput[]
    id?: IntFilter<"LimitOrder"> | number
    userId?: IntFilter<"LimitOrder"> | number
    stockId?: IntFilter<"LimitOrder"> | number
    quantity?: IntFilter<"LimitOrder"> | number
    limitPrice?: DecimalFilter<"LimitOrder"> | Decimal | DecimalJsLike | number | string
    orderType?: StringFilter<"LimitOrder"> | string
    status?: StringFilter<"LimitOrder"> | string
    createdAt?: DateTimeFilter<"LimitOrder"> | Date | string
    updatedAt?: DateTimeFilter<"LimitOrder"> | Date | string
  }

  export type CompanyUpsertWithoutStocksInput = {
    update: XOR<CompanyUpdateWithoutStocksInput, CompanyUncheckedUpdateWithoutStocksInput>
    create: XOR<CompanyCreateWithoutStocksInput, CompanyUncheckedCreateWithoutStocksInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutStocksInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutStocksInput, CompanyUncheckedUpdateWithoutStocksInput>
  }

  export type CompanyUpdateWithoutStocksInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    founded?: IntFieldUpdateOperationsInput | number
    employees?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CompanyUncheckedUpdateWithoutStocksInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    founded?: IntFieldUpdateOperationsInput | number
    employees?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TradeUpsertWithWhereUniqueWithoutStockInput = {
    where: TradeWhereUniqueInput
    update: XOR<TradeUpdateWithoutStockInput, TradeUncheckedUpdateWithoutStockInput>
    create: XOR<TradeCreateWithoutStockInput, TradeUncheckedCreateWithoutStockInput>
  }

  export type TradeUpdateWithWhereUniqueWithoutStockInput = {
    where: TradeWhereUniqueInput
    data: XOR<TradeUpdateWithoutStockInput, TradeUncheckedUpdateWithoutStockInput>
  }

  export type TradeUpdateManyWithWhereWithoutStockInput = {
    where: TradeScalarWhereInput
    data: XOR<TradeUpdateManyMutationInput, TradeUncheckedUpdateManyWithoutStockInput>
  }

  export type TradeScalarWhereInput = {
    AND?: TradeScalarWhereInput | TradeScalarWhereInput[]
    OR?: TradeScalarWhereInput[]
    NOT?: TradeScalarWhereInput | TradeScalarWhereInput[]
    id?: IntFilter<"Trade"> | number
    userId?: IntNullableFilter<"Trade"> | number | null
    stockId?: IntFilter<"Trade"> | number
    quantity?: IntFilter<"Trade"> | number
    price?: DecimalFilter<"Trade"> | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFilter<"Trade"> | Decimal | DecimalJsLike | number | string
    tradeType?: StringFilter<"Trade"> | string
    tradeDate?: DateTimeFilter<"Trade"> | Date | string
  }

  export type StockCreateWithoutFavoriteStockInput = {
    symbol: string
    sector?: string | null
    change?: number | null
    hist_prices?: HistPriceCreateNestedManyWithoutStockInput
    limitOrder?: LimitOrderCreateNestedManyWithoutStockInput
    company?: CompanyCreateNestedOneWithoutStocksInput
    trading?: TradeCreateNestedManyWithoutStockInput
  }

  export type StockUncheckedCreateWithoutFavoriteStockInput = {
    stock_id?: number
    symbol: string
    sector?: string | null
    company_id?: number | null
    change?: number | null
    hist_prices?: HistPriceUncheckedCreateNestedManyWithoutStockInput
    limitOrder?: LimitOrderUncheckedCreateNestedManyWithoutStockInput
    trading?: TradeUncheckedCreateNestedManyWithoutStockInput
  }

  export type StockCreateOrConnectWithoutFavoriteStockInput = {
    where: StockWhereUniqueInput
    create: XOR<StockCreateWithoutFavoriteStockInput, StockUncheckedCreateWithoutFavoriteStockInput>
  }

  export type UserCreateWithoutFavoriteStocksInput = {
    email: string
    password: string
    wallet?: number
    createdAt?: Date | string
    status?: string
    userReferralLink?: string | null
    username: string
    updatedAt?: Date | string
    name?: string | null
    phoneNumber?: number | null
    BlogComment?: BlogCommentCreateNestedManyWithoutUserInput
    BlogPost?: BlogPostCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    FavoriteApi?: FavoriteApiCreateNestedManyWithoutUserInput
    Goal?: GoalCreateNestedManyWithoutUserInput
    limitOrders?: LimitOrderCreateNestedManyWithoutUserInput
    RedeemBy?: RedeemByCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutUserInput
    referralUsages?: ReferralUsageCreateNestedManyWithoutUserInput
    trading?: TradeCreateNestedManyWithoutUserInput
    referredBy?: ReferralCreateNestedOneWithoutReferredUsersInput
  }

  export type UserUncheckedCreateWithoutFavoriteStocksInput = {
    id?: number
    email: string
    password: string
    wallet?: number
    createdAt?: Date | string
    referredById?: number | null
    status?: string
    userReferralLink?: string | null
    username: string
    updatedAt?: Date | string
    name?: string | null
    phoneNumber?: number | null
    BlogComment?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    BlogPost?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    FavoriteApi?: FavoriteApiUncheckedCreateNestedManyWithoutUserInput
    Goal?: GoalUncheckedCreateNestedManyWithoutUserInput
    limitOrders?: LimitOrderUncheckedCreateNestedManyWithoutUserInput
    RedeemBy?: RedeemByUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutUserInput
    referralUsages?: ReferralUsageUncheckedCreateNestedManyWithoutUserInput
    trading?: TradeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFavoriteStocksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFavoriteStocksInput, UserUncheckedCreateWithoutFavoriteStocksInput>
  }

  export type StockUpsertWithoutFavoriteStockInput = {
    update: XOR<StockUpdateWithoutFavoriteStockInput, StockUncheckedUpdateWithoutFavoriteStockInput>
    create: XOR<StockCreateWithoutFavoriteStockInput, StockUncheckedCreateWithoutFavoriteStockInput>
    where?: StockWhereInput
  }

  export type StockUpdateToOneWithWhereWithoutFavoriteStockInput = {
    where?: StockWhereInput
    data: XOR<StockUpdateWithoutFavoriteStockInput, StockUncheckedUpdateWithoutFavoriteStockInput>
  }

  export type StockUpdateWithoutFavoriteStockInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    change?: NullableIntFieldUpdateOperationsInput | number | null
    hist_prices?: HistPriceUpdateManyWithoutStockNestedInput
    limitOrder?: LimitOrderUpdateManyWithoutStockNestedInput
    company?: CompanyUpdateOneWithoutStocksNestedInput
    trading?: TradeUpdateManyWithoutStockNestedInput
  }

  export type StockUncheckedUpdateWithoutFavoriteStockInput = {
    stock_id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    change?: NullableIntFieldUpdateOperationsInput | number | null
    hist_prices?: HistPriceUncheckedUpdateManyWithoutStockNestedInput
    limitOrder?: LimitOrderUncheckedUpdateManyWithoutStockNestedInput
    trading?: TradeUncheckedUpdateManyWithoutStockNestedInput
  }

  export type UserUpsertWithoutFavoriteStocksInput = {
    update: XOR<UserUpdateWithoutFavoriteStocksInput, UserUncheckedUpdateWithoutFavoriteStocksInput>
    create: XOR<UserCreateWithoutFavoriteStocksInput, UserUncheckedCreateWithoutFavoriteStocksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFavoriteStocksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFavoriteStocksInput, UserUncheckedUpdateWithoutFavoriteStocksInput>
  }

  export type UserUpdateWithoutFavoriteStocksInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wallet?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    userReferralLink?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    BlogComment?: BlogCommentUpdateManyWithoutUserNestedInput
    BlogPost?: BlogPostUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    FavoriteApi?: FavoriteApiUpdateManyWithoutUserNestedInput
    Goal?: GoalUpdateManyWithoutUserNestedInput
    limitOrders?: LimitOrderUpdateManyWithoutUserNestedInput
    RedeemBy?: RedeemByUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutUserNestedInput
    referralUsages?: ReferralUsageUpdateManyWithoutUserNestedInput
    trading?: TradeUpdateManyWithoutUserNestedInput
    referredBy?: ReferralUpdateOneWithoutReferredUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutFavoriteStocksInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wallet?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    userReferralLink?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    BlogComment?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    BlogPost?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    FavoriteApi?: FavoriteApiUncheckedUpdateManyWithoutUserNestedInput
    Goal?: GoalUncheckedUpdateManyWithoutUserNestedInput
    limitOrders?: LimitOrderUncheckedUpdateManyWithoutUserNestedInput
    RedeemBy?: RedeemByUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutUserNestedInput
    referralUsages?: ReferralUsageUncheckedUpdateManyWithoutUserNestedInput
    trading?: TradeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StockCreateWithoutHist_pricesInput = {
    symbol: string
    sector?: string | null
    change?: number | null
    favoriteStock?: FavoriteStockCreateNestedManyWithoutStockInput
    limitOrder?: LimitOrderCreateNestedManyWithoutStockInput
    company?: CompanyCreateNestedOneWithoutStocksInput
    trading?: TradeCreateNestedManyWithoutStockInput
  }

  export type StockUncheckedCreateWithoutHist_pricesInput = {
    stock_id?: number
    symbol: string
    sector?: string | null
    company_id?: number | null
    change?: number | null
    favoriteStock?: FavoriteStockUncheckedCreateNestedManyWithoutStockInput
    limitOrder?: LimitOrderUncheckedCreateNestedManyWithoutStockInput
    trading?: TradeUncheckedCreateNestedManyWithoutStockInput
  }

  export type StockCreateOrConnectWithoutHist_pricesInput = {
    where: StockWhereUniqueInput
    create: XOR<StockCreateWithoutHist_pricesInput, StockUncheckedCreateWithoutHist_pricesInput>
  }

  export type StockUpsertWithoutHist_pricesInput = {
    update: XOR<StockUpdateWithoutHist_pricesInput, StockUncheckedUpdateWithoutHist_pricesInput>
    create: XOR<StockCreateWithoutHist_pricesInput, StockUncheckedCreateWithoutHist_pricesInput>
    where?: StockWhereInput
  }

  export type StockUpdateToOneWithWhereWithoutHist_pricesInput = {
    where?: StockWhereInput
    data: XOR<StockUpdateWithoutHist_pricesInput, StockUncheckedUpdateWithoutHist_pricesInput>
  }

  export type StockUpdateWithoutHist_pricesInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    change?: NullableIntFieldUpdateOperationsInput | number | null
    favoriteStock?: FavoriteStockUpdateManyWithoutStockNestedInput
    limitOrder?: LimitOrderUpdateManyWithoutStockNestedInput
    company?: CompanyUpdateOneWithoutStocksNestedInput
    trading?: TradeUpdateManyWithoutStockNestedInput
  }

  export type StockUncheckedUpdateWithoutHist_pricesInput = {
    stock_id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    change?: NullableIntFieldUpdateOperationsInput | number | null
    favoriteStock?: FavoriteStockUncheckedUpdateManyWithoutStockNestedInput
    limitOrder?: LimitOrderUncheckedUpdateManyWithoutStockNestedInput
    trading?: TradeUncheckedUpdateManyWithoutStockNestedInput
  }

  export type StockCreateWithoutLimitOrderInput = {
    symbol: string
    sector?: string | null
    change?: number | null
    favoriteStock?: FavoriteStockCreateNestedManyWithoutStockInput
    hist_prices?: HistPriceCreateNestedManyWithoutStockInput
    company?: CompanyCreateNestedOneWithoutStocksInput
    trading?: TradeCreateNestedManyWithoutStockInput
  }

  export type StockUncheckedCreateWithoutLimitOrderInput = {
    stock_id?: number
    symbol: string
    sector?: string | null
    company_id?: number | null
    change?: number | null
    favoriteStock?: FavoriteStockUncheckedCreateNestedManyWithoutStockInput
    hist_prices?: HistPriceUncheckedCreateNestedManyWithoutStockInput
    trading?: TradeUncheckedCreateNestedManyWithoutStockInput
  }

  export type StockCreateOrConnectWithoutLimitOrderInput = {
    where: StockWhereUniqueInput
    create: XOR<StockCreateWithoutLimitOrderInput, StockUncheckedCreateWithoutLimitOrderInput>
  }

  export type UserCreateWithoutLimitOrdersInput = {
    email: string
    password: string
    wallet?: number
    createdAt?: Date | string
    status?: string
    userReferralLink?: string | null
    username: string
    updatedAt?: Date | string
    name?: string | null
    phoneNumber?: number | null
    BlogComment?: BlogCommentCreateNestedManyWithoutUserInput
    BlogPost?: BlogPostCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    FavoriteApi?: FavoriteApiCreateNestedManyWithoutUserInput
    favoriteStocks?: FavoriteStockCreateNestedManyWithoutUserInput
    Goal?: GoalCreateNestedManyWithoutUserInput
    RedeemBy?: RedeemByCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutUserInput
    referralUsages?: ReferralUsageCreateNestedManyWithoutUserInput
    trading?: TradeCreateNestedManyWithoutUserInput
    referredBy?: ReferralCreateNestedOneWithoutReferredUsersInput
  }

  export type UserUncheckedCreateWithoutLimitOrdersInput = {
    id?: number
    email: string
    password: string
    wallet?: number
    createdAt?: Date | string
    referredById?: number | null
    status?: string
    userReferralLink?: string | null
    username: string
    updatedAt?: Date | string
    name?: string | null
    phoneNumber?: number | null
    BlogComment?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    BlogPost?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    FavoriteApi?: FavoriteApiUncheckedCreateNestedManyWithoutUserInput
    favoriteStocks?: FavoriteStockUncheckedCreateNestedManyWithoutUserInput
    Goal?: GoalUncheckedCreateNestedManyWithoutUserInput
    RedeemBy?: RedeemByUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutUserInput
    referralUsages?: ReferralUsageUncheckedCreateNestedManyWithoutUserInput
    trading?: TradeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLimitOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLimitOrdersInput, UserUncheckedCreateWithoutLimitOrdersInput>
  }

  export type StockUpsertWithoutLimitOrderInput = {
    update: XOR<StockUpdateWithoutLimitOrderInput, StockUncheckedUpdateWithoutLimitOrderInput>
    create: XOR<StockCreateWithoutLimitOrderInput, StockUncheckedCreateWithoutLimitOrderInput>
    where?: StockWhereInput
  }

  export type StockUpdateToOneWithWhereWithoutLimitOrderInput = {
    where?: StockWhereInput
    data: XOR<StockUpdateWithoutLimitOrderInput, StockUncheckedUpdateWithoutLimitOrderInput>
  }

  export type StockUpdateWithoutLimitOrderInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    change?: NullableIntFieldUpdateOperationsInput | number | null
    favoriteStock?: FavoriteStockUpdateManyWithoutStockNestedInput
    hist_prices?: HistPriceUpdateManyWithoutStockNestedInput
    company?: CompanyUpdateOneWithoutStocksNestedInput
    trading?: TradeUpdateManyWithoutStockNestedInput
  }

  export type StockUncheckedUpdateWithoutLimitOrderInput = {
    stock_id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    change?: NullableIntFieldUpdateOperationsInput | number | null
    favoriteStock?: FavoriteStockUncheckedUpdateManyWithoutStockNestedInput
    hist_prices?: HistPriceUncheckedUpdateManyWithoutStockNestedInput
    trading?: TradeUncheckedUpdateManyWithoutStockNestedInput
  }

  export type UserUpsertWithoutLimitOrdersInput = {
    update: XOR<UserUpdateWithoutLimitOrdersInput, UserUncheckedUpdateWithoutLimitOrdersInput>
    create: XOR<UserCreateWithoutLimitOrdersInput, UserUncheckedCreateWithoutLimitOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLimitOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLimitOrdersInput, UserUncheckedUpdateWithoutLimitOrdersInput>
  }

  export type UserUpdateWithoutLimitOrdersInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wallet?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    userReferralLink?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    BlogComment?: BlogCommentUpdateManyWithoutUserNestedInput
    BlogPost?: BlogPostUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    FavoriteApi?: FavoriteApiUpdateManyWithoutUserNestedInput
    favoriteStocks?: FavoriteStockUpdateManyWithoutUserNestedInput
    Goal?: GoalUpdateManyWithoutUserNestedInput
    RedeemBy?: RedeemByUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutUserNestedInput
    referralUsages?: ReferralUsageUpdateManyWithoutUserNestedInput
    trading?: TradeUpdateManyWithoutUserNestedInput
    referredBy?: ReferralUpdateOneWithoutReferredUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutLimitOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wallet?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    userReferralLink?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    BlogComment?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    BlogPost?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    FavoriteApi?: FavoriteApiUncheckedUpdateManyWithoutUserNestedInput
    favoriteStocks?: FavoriteStockUncheckedUpdateManyWithoutUserNestedInput
    Goal?: GoalUncheckedUpdateManyWithoutUserNestedInput
    RedeemBy?: RedeemByUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutUserNestedInput
    referralUsages?: ReferralUsageUncheckedUpdateManyWithoutUserNestedInput
    trading?: TradeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StockCreateWithoutTradingInput = {
    symbol: string
    sector?: string | null
    change?: number | null
    favoriteStock?: FavoriteStockCreateNestedManyWithoutStockInput
    hist_prices?: HistPriceCreateNestedManyWithoutStockInput
    limitOrder?: LimitOrderCreateNestedManyWithoutStockInput
    company?: CompanyCreateNestedOneWithoutStocksInput
  }

  export type StockUncheckedCreateWithoutTradingInput = {
    stock_id?: number
    symbol: string
    sector?: string | null
    company_id?: number | null
    change?: number | null
    favoriteStock?: FavoriteStockUncheckedCreateNestedManyWithoutStockInput
    hist_prices?: HistPriceUncheckedCreateNestedManyWithoutStockInput
    limitOrder?: LimitOrderUncheckedCreateNestedManyWithoutStockInput
  }

  export type StockCreateOrConnectWithoutTradingInput = {
    where: StockWhereUniqueInput
    create: XOR<StockCreateWithoutTradingInput, StockUncheckedCreateWithoutTradingInput>
  }

  export type UserCreateWithoutTradingInput = {
    email: string
    password: string
    wallet?: number
    createdAt?: Date | string
    status?: string
    userReferralLink?: string | null
    username: string
    updatedAt?: Date | string
    name?: string | null
    phoneNumber?: number | null
    BlogComment?: BlogCommentCreateNestedManyWithoutUserInput
    BlogPost?: BlogPostCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    FavoriteApi?: FavoriteApiCreateNestedManyWithoutUserInput
    favoriteStocks?: FavoriteStockCreateNestedManyWithoutUserInput
    Goal?: GoalCreateNestedManyWithoutUserInput
    limitOrders?: LimitOrderCreateNestedManyWithoutUserInput
    RedeemBy?: RedeemByCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutUserInput
    referralUsages?: ReferralUsageCreateNestedManyWithoutUserInput
    referredBy?: ReferralCreateNestedOneWithoutReferredUsersInput
  }

  export type UserUncheckedCreateWithoutTradingInput = {
    id?: number
    email: string
    password: string
    wallet?: number
    createdAt?: Date | string
    referredById?: number | null
    status?: string
    userReferralLink?: string | null
    username: string
    updatedAt?: Date | string
    name?: string | null
    phoneNumber?: number | null
    BlogComment?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    BlogPost?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    FavoriteApi?: FavoriteApiUncheckedCreateNestedManyWithoutUserInput
    favoriteStocks?: FavoriteStockUncheckedCreateNestedManyWithoutUserInput
    Goal?: GoalUncheckedCreateNestedManyWithoutUserInput
    limitOrders?: LimitOrderUncheckedCreateNestedManyWithoutUserInput
    RedeemBy?: RedeemByUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutUserInput
    referralUsages?: ReferralUsageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTradingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTradingInput, UserUncheckedCreateWithoutTradingInput>
  }

  export type StockUpsertWithoutTradingInput = {
    update: XOR<StockUpdateWithoutTradingInput, StockUncheckedUpdateWithoutTradingInput>
    create: XOR<StockCreateWithoutTradingInput, StockUncheckedCreateWithoutTradingInput>
    where?: StockWhereInput
  }

  export type StockUpdateToOneWithWhereWithoutTradingInput = {
    where?: StockWhereInput
    data: XOR<StockUpdateWithoutTradingInput, StockUncheckedUpdateWithoutTradingInput>
  }

  export type StockUpdateWithoutTradingInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    change?: NullableIntFieldUpdateOperationsInput | number | null
    favoriteStock?: FavoriteStockUpdateManyWithoutStockNestedInput
    hist_prices?: HistPriceUpdateManyWithoutStockNestedInput
    limitOrder?: LimitOrderUpdateManyWithoutStockNestedInput
    company?: CompanyUpdateOneWithoutStocksNestedInput
  }

  export type StockUncheckedUpdateWithoutTradingInput = {
    stock_id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    change?: NullableIntFieldUpdateOperationsInput | number | null
    favoriteStock?: FavoriteStockUncheckedUpdateManyWithoutStockNestedInput
    hist_prices?: HistPriceUncheckedUpdateManyWithoutStockNestedInput
    limitOrder?: LimitOrderUncheckedUpdateManyWithoutStockNestedInput
  }

  export type UserUpsertWithoutTradingInput = {
    update: XOR<UserUpdateWithoutTradingInput, UserUncheckedUpdateWithoutTradingInput>
    create: XOR<UserCreateWithoutTradingInput, UserUncheckedCreateWithoutTradingInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTradingInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTradingInput, UserUncheckedUpdateWithoutTradingInput>
  }

  export type UserUpdateWithoutTradingInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wallet?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    userReferralLink?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    BlogComment?: BlogCommentUpdateManyWithoutUserNestedInput
    BlogPost?: BlogPostUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    FavoriteApi?: FavoriteApiUpdateManyWithoutUserNestedInput
    favoriteStocks?: FavoriteStockUpdateManyWithoutUserNestedInput
    Goal?: GoalUpdateManyWithoutUserNestedInput
    limitOrders?: LimitOrderUpdateManyWithoutUserNestedInput
    RedeemBy?: RedeemByUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutUserNestedInput
    referralUsages?: ReferralUsageUpdateManyWithoutUserNestedInput
    referredBy?: ReferralUpdateOneWithoutReferredUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutTradingInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wallet?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    userReferralLink?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    BlogComment?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    BlogPost?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    FavoriteApi?: FavoriteApiUncheckedUpdateManyWithoutUserNestedInput
    favoriteStocks?: FavoriteStockUncheckedUpdateManyWithoutUserNestedInput
    Goal?: GoalUncheckedUpdateManyWithoutUserNestedInput
    limitOrders?: LimitOrderUncheckedUpdateManyWithoutUserNestedInput
    RedeemBy?: RedeemByUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutUserNestedInput
    referralUsages?: ReferralUsageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutBlogPostInput = {
    email: string
    password: string
    wallet?: number
    createdAt?: Date | string
    status?: string
    userReferralLink?: string | null
    username: string
    updatedAt?: Date | string
    name?: string | null
    phoneNumber?: number | null
    BlogComment?: BlogCommentCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    FavoriteApi?: FavoriteApiCreateNestedManyWithoutUserInput
    favoriteStocks?: FavoriteStockCreateNestedManyWithoutUserInput
    Goal?: GoalCreateNestedManyWithoutUserInput
    limitOrders?: LimitOrderCreateNestedManyWithoutUserInput
    RedeemBy?: RedeemByCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutUserInput
    referralUsages?: ReferralUsageCreateNestedManyWithoutUserInput
    trading?: TradeCreateNestedManyWithoutUserInput
    referredBy?: ReferralCreateNestedOneWithoutReferredUsersInput
  }

  export type UserUncheckedCreateWithoutBlogPostInput = {
    id?: number
    email: string
    password: string
    wallet?: number
    createdAt?: Date | string
    referredById?: number | null
    status?: string
    userReferralLink?: string | null
    username: string
    updatedAt?: Date | string
    name?: string | null
    phoneNumber?: number | null
    BlogComment?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    FavoriteApi?: FavoriteApiUncheckedCreateNestedManyWithoutUserInput
    favoriteStocks?: FavoriteStockUncheckedCreateNestedManyWithoutUserInput
    Goal?: GoalUncheckedCreateNestedManyWithoutUserInput
    limitOrders?: LimitOrderUncheckedCreateNestedManyWithoutUserInput
    RedeemBy?: RedeemByUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutUserInput
    referralUsages?: ReferralUsageUncheckedCreateNestedManyWithoutUserInput
    trading?: TradeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBlogPostInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlogPostInput, UserUncheckedCreateWithoutBlogPostInput>
  }

  export type BlogCommentCreateWithoutPostInput = {
    comment: string
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutBlogCommentInput
  }

  export type BlogCommentUncheckedCreateWithoutPostInput = {
    id?: number
    user_id: number
    comment: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BlogCommentCreateOrConnectWithoutPostInput = {
    where: BlogCommentWhereUniqueInput
    create: XOR<BlogCommentCreateWithoutPostInput, BlogCommentUncheckedCreateWithoutPostInput>
  }

  export type BlogCommentCreateManyPostInputEnvelope = {
    data: BlogCommentCreateManyPostInput | BlogCommentCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutBlogPostInput = {
    update: XOR<UserUpdateWithoutBlogPostInput, UserUncheckedUpdateWithoutBlogPostInput>
    create: XOR<UserCreateWithoutBlogPostInput, UserUncheckedCreateWithoutBlogPostInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBlogPostInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBlogPostInput, UserUncheckedUpdateWithoutBlogPostInput>
  }

  export type UserUpdateWithoutBlogPostInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wallet?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    userReferralLink?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    BlogComment?: BlogCommentUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    FavoriteApi?: FavoriteApiUpdateManyWithoutUserNestedInput
    favoriteStocks?: FavoriteStockUpdateManyWithoutUserNestedInput
    Goal?: GoalUpdateManyWithoutUserNestedInput
    limitOrders?: LimitOrderUpdateManyWithoutUserNestedInput
    RedeemBy?: RedeemByUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutUserNestedInput
    referralUsages?: ReferralUsageUpdateManyWithoutUserNestedInput
    trading?: TradeUpdateManyWithoutUserNestedInput
    referredBy?: ReferralUpdateOneWithoutReferredUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutBlogPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wallet?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    userReferralLink?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    BlogComment?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    FavoriteApi?: FavoriteApiUncheckedUpdateManyWithoutUserNestedInput
    favoriteStocks?: FavoriteStockUncheckedUpdateManyWithoutUserNestedInput
    Goal?: GoalUncheckedUpdateManyWithoutUserNestedInput
    limitOrders?: LimitOrderUncheckedUpdateManyWithoutUserNestedInput
    RedeemBy?: RedeemByUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutUserNestedInput
    referralUsages?: ReferralUsageUncheckedUpdateManyWithoutUserNestedInput
    trading?: TradeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BlogCommentUpsertWithWhereUniqueWithoutPostInput = {
    where: BlogCommentWhereUniqueInput
    update: XOR<BlogCommentUpdateWithoutPostInput, BlogCommentUncheckedUpdateWithoutPostInput>
    create: XOR<BlogCommentCreateWithoutPostInput, BlogCommentUncheckedCreateWithoutPostInput>
  }

  export type BlogCommentUpdateWithWhereUniqueWithoutPostInput = {
    where: BlogCommentWhereUniqueInput
    data: XOR<BlogCommentUpdateWithoutPostInput, BlogCommentUncheckedUpdateWithoutPostInput>
  }

  export type BlogCommentUpdateManyWithWhereWithoutPostInput = {
    where: BlogCommentScalarWhereInput
    data: XOR<BlogCommentUpdateManyMutationInput, BlogCommentUncheckedUpdateManyWithoutPostInput>
  }

  export type BlogCommentScalarWhereInput = {
    AND?: BlogCommentScalarWhereInput | BlogCommentScalarWhereInput[]
    OR?: BlogCommentScalarWhereInput[]
    NOT?: BlogCommentScalarWhereInput | BlogCommentScalarWhereInput[]
    id?: IntFilter<"BlogComment"> | number
    post_id?: IntFilter<"BlogComment"> | number
    user_id?: IntFilter<"BlogComment"> | number
    comment?: StringFilter<"BlogComment"> | string
    created_at?: DateTimeFilter<"BlogComment"> | Date | string
    updated_at?: DateTimeFilter<"BlogComment"> | Date | string
  }

  export type BlogPostCreateWithoutBlogCommentInput = {
    title: string
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutBlogPostInput
  }

  export type BlogPostUncheckedCreateWithoutBlogCommentInput = {
    id?: number
    user_id: number
    title: string
    content: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BlogPostCreateOrConnectWithoutBlogCommentInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutBlogCommentInput, BlogPostUncheckedCreateWithoutBlogCommentInput>
  }

  export type UserCreateWithoutBlogCommentInput = {
    email: string
    password: string
    wallet?: number
    createdAt?: Date | string
    status?: string
    userReferralLink?: string | null
    username: string
    updatedAt?: Date | string
    name?: string | null
    phoneNumber?: number | null
    BlogPost?: BlogPostCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    FavoriteApi?: FavoriteApiCreateNestedManyWithoutUserInput
    favoriteStocks?: FavoriteStockCreateNestedManyWithoutUserInput
    Goal?: GoalCreateNestedManyWithoutUserInput
    limitOrders?: LimitOrderCreateNestedManyWithoutUserInput
    RedeemBy?: RedeemByCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutUserInput
    referralUsages?: ReferralUsageCreateNestedManyWithoutUserInput
    trading?: TradeCreateNestedManyWithoutUserInput
    referredBy?: ReferralCreateNestedOneWithoutReferredUsersInput
  }

  export type UserUncheckedCreateWithoutBlogCommentInput = {
    id?: number
    email: string
    password: string
    wallet?: number
    createdAt?: Date | string
    referredById?: number | null
    status?: string
    userReferralLink?: string | null
    username: string
    updatedAt?: Date | string
    name?: string | null
    phoneNumber?: number | null
    BlogPost?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    FavoriteApi?: FavoriteApiUncheckedCreateNestedManyWithoutUserInput
    favoriteStocks?: FavoriteStockUncheckedCreateNestedManyWithoutUserInput
    Goal?: GoalUncheckedCreateNestedManyWithoutUserInput
    limitOrders?: LimitOrderUncheckedCreateNestedManyWithoutUserInput
    RedeemBy?: RedeemByUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutUserInput
    referralUsages?: ReferralUsageUncheckedCreateNestedManyWithoutUserInput
    trading?: TradeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBlogCommentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlogCommentInput, UserUncheckedCreateWithoutBlogCommentInput>
  }

  export type BlogPostUpsertWithoutBlogCommentInput = {
    update: XOR<BlogPostUpdateWithoutBlogCommentInput, BlogPostUncheckedUpdateWithoutBlogCommentInput>
    create: XOR<BlogPostCreateWithoutBlogCommentInput, BlogPostUncheckedCreateWithoutBlogCommentInput>
    where?: BlogPostWhereInput
  }

  export type BlogPostUpdateToOneWithWhereWithoutBlogCommentInput = {
    where?: BlogPostWhereInput
    data: XOR<BlogPostUpdateWithoutBlogCommentInput, BlogPostUncheckedUpdateWithoutBlogCommentInput>
  }

  export type BlogPostUpdateWithoutBlogCommentInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBlogPostNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutBlogCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutBlogCommentInput = {
    update: XOR<UserUpdateWithoutBlogCommentInput, UserUncheckedUpdateWithoutBlogCommentInput>
    create: XOR<UserCreateWithoutBlogCommentInput, UserUncheckedCreateWithoutBlogCommentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBlogCommentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBlogCommentInput, UserUncheckedUpdateWithoutBlogCommentInput>
  }

  export type UserUpdateWithoutBlogCommentInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wallet?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    userReferralLink?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    BlogPost?: BlogPostUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    FavoriteApi?: FavoriteApiUpdateManyWithoutUserNestedInput
    favoriteStocks?: FavoriteStockUpdateManyWithoutUserNestedInput
    Goal?: GoalUpdateManyWithoutUserNestedInput
    limitOrders?: LimitOrderUpdateManyWithoutUserNestedInput
    RedeemBy?: RedeemByUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutUserNestedInput
    referralUsages?: ReferralUsageUpdateManyWithoutUserNestedInput
    trading?: TradeUpdateManyWithoutUserNestedInput
    referredBy?: ReferralUpdateOneWithoutReferredUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutBlogCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wallet?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    userReferralLink?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    BlogPost?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    FavoriteApi?: FavoriteApiUncheckedUpdateManyWithoutUserNestedInput
    favoriteStocks?: FavoriteStockUncheckedUpdateManyWithoutUserNestedInput
    Goal?: GoalUncheckedUpdateManyWithoutUserNestedInput
    limitOrders?: LimitOrderUncheckedUpdateManyWithoutUserNestedInput
    RedeemBy?: RedeemByUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutUserNestedInput
    referralUsages?: ReferralUsageUncheckedUpdateManyWithoutUserNestedInput
    trading?: TradeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BlogCommentCreateWithoutUserInput = {
    comment: string
    created_at?: Date | string
    updated_at?: Date | string
    post: BlogPostCreateNestedOneWithoutBlogCommentInput
  }

  export type BlogCommentUncheckedCreateWithoutUserInput = {
    id?: number
    post_id: number
    comment: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BlogCommentCreateOrConnectWithoutUserInput = {
    where: BlogCommentWhereUniqueInput
    create: XOR<BlogCommentCreateWithoutUserInput, BlogCommentUncheckedCreateWithoutUserInput>
  }

  export type BlogCommentCreateManyUserInputEnvelope = {
    data: BlogCommentCreateManyUserInput | BlogCommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BlogPostCreateWithoutUserInput = {
    title: string
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    BlogComment?: BlogCommentCreateNestedManyWithoutPostInput
  }

  export type BlogPostUncheckedCreateWithoutUserInput = {
    id?: number
    title: string
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    BlogComment?: BlogCommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type BlogPostCreateOrConnectWithoutUserInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutUserInput, BlogPostUncheckedCreateWithoutUserInput>
  }

  export type BlogPostCreateManyUserInputEnvelope = {
    data: BlogPostCreateManyUserInput | BlogPostCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutUserInput = {
    stockSymbol: string
    content: string
    createdAt?: Date | string
    viewCount?: number
  }

  export type CommentUncheckedCreateWithoutUserInput = {
    id?: number
    stockSymbol: string
    content: string
    createdAt?: Date | string
    viewCount?: number
  }

  export type CommentCreateOrConnectWithoutUserInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentCreateManyUserInputEnvelope = {
    data: CommentCreateManyUserInput | CommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FavoriteApiCreateWithoutUserInput = {
    symbol: string
  }

  export type FavoriteApiUncheckedCreateWithoutUserInput = {
    id?: number
    symbol: string
  }

  export type FavoriteApiCreateOrConnectWithoutUserInput = {
    where: FavoriteApiWhereUniqueInput
    create: XOR<FavoriteApiCreateWithoutUserInput, FavoriteApiUncheckedCreateWithoutUserInput>
  }

  export type FavoriteApiCreateManyUserInputEnvelope = {
    data: FavoriteApiCreateManyUserInput | FavoriteApiCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FavoriteStockCreateWithoutUserInput = {
    stock: StockCreateNestedOneWithoutFavoriteStockInput
  }

  export type FavoriteStockUncheckedCreateWithoutUserInput = {
    id?: number
    stockId: number
  }

  export type FavoriteStockCreateOrConnectWithoutUserInput = {
    where: FavoriteStockWhereUniqueInput
    create: XOR<FavoriteStockCreateWithoutUserInput, FavoriteStockUncheckedCreateWithoutUserInput>
  }

  export type FavoriteStockCreateManyUserInputEnvelope = {
    data: FavoriteStockCreateManyUserInput | FavoriteStockCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GoalCreateWithoutUserInput = {
    title: string
    amount: number
    deadline: Date | string
    createdAt?: Date | string
    description?: string | null
  }

  export type GoalUncheckedCreateWithoutUserInput = {
    id?: number
    title: string
    amount: number
    deadline: Date | string
    createdAt?: Date | string
    description?: string | null
  }

  export type GoalCreateOrConnectWithoutUserInput = {
    where: GoalWhereUniqueInput
    create: XOR<GoalCreateWithoutUserInput, GoalUncheckedCreateWithoutUserInput>
  }

  export type GoalCreateManyUserInputEnvelope = {
    data: GoalCreateManyUserInput | GoalCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LimitOrderCreateWithoutUserInput = {
    quantity: number
    limitPrice: Decimal | DecimalJsLike | number | string
    orderType: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    stock: StockCreateNestedOneWithoutLimitOrderInput
  }

  export type LimitOrderUncheckedCreateWithoutUserInput = {
    id?: number
    stockId: number
    quantity: number
    limitPrice: Decimal | DecimalJsLike | number | string
    orderType: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LimitOrderCreateOrConnectWithoutUserInput = {
    where: LimitOrderWhereUniqueInput
    create: XOR<LimitOrderCreateWithoutUserInput, LimitOrderUncheckedCreateWithoutUserInput>
  }

  export type LimitOrderCreateManyUserInputEnvelope = {
    data: LimitOrderCreateManyUserInput | LimitOrderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RedeemByCreateWithoutUserInput = {
    dateOrdered?: Date | string
    cardCode: string
    reward: RewardCreateNestedOneWithoutRedeemedByInput
  }

  export type RedeemByUncheckedCreateWithoutUserInput = {
    id?: number
    dateOrdered?: Date | string
    rewardId: number
    cardCode: string
  }

  export type RedeemByCreateOrConnectWithoutUserInput = {
    where: RedeemByWhereUniqueInput
    create: XOR<RedeemByCreateWithoutUserInput, RedeemByUncheckedCreateWithoutUserInput>
  }

  export type RedeemByCreateManyUserInputEnvelope = {
    data: RedeemByCreateManyUserInput | RedeemByCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReferralCreateWithoutUserInput = {
    referralLink: string
    referralSignups?: number
    successfulReferrals?: number
    rewardsExchanged?: number
    creditsEarned?: number
    wallet?: number
    referralUsages?: ReferralUsageCreateNestedManyWithoutReferralInput
    referredUsers?: UserCreateNestedManyWithoutReferredByInput
  }

  export type ReferralUncheckedCreateWithoutUserInput = {
    id?: number
    referralLink: string
    referralSignups?: number
    successfulReferrals?: number
    rewardsExchanged?: number
    creditsEarned?: number
    wallet?: number
    referralUsages?: ReferralUsageUncheckedCreateNestedManyWithoutReferralInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferredByInput
  }

  export type ReferralCreateOrConnectWithoutUserInput = {
    where: ReferralWhereUniqueInput
    create: XOR<ReferralCreateWithoutUserInput, ReferralUncheckedCreateWithoutUserInput>
  }

  export type ReferralCreateManyUserInputEnvelope = {
    data: ReferralCreateManyUserInput | ReferralCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReferralUsageCreateWithoutUserInput = {
    createdAt?: Date | string
    referral?: ReferralCreateNestedOneWithoutReferralUsagesInput
  }

  export type ReferralUsageUncheckedCreateWithoutUserInput = {
    id?: number
    referralId?: number | null
    createdAt?: Date | string
  }

  export type ReferralUsageCreateOrConnectWithoutUserInput = {
    where: ReferralUsageWhereUniqueInput
    create: XOR<ReferralUsageCreateWithoutUserInput, ReferralUsageUncheckedCreateWithoutUserInput>
  }

  export type ReferralUsageCreateManyUserInputEnvelope = {
    data: ReferralUsageCreateManyUserInput | ReferralUsageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TradeCreateWithoutUserInput = {
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    tradeType: string
    tradeDate?: Date | string
    stock: StockCreateNestedOneWithoutTradingInput
  }

  export type TradeUncheckedCreateWithoutUserInput = {
    id?: number
    stockId: number
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    tradeType: string
    tradeDate?: Date | string
  }

  export type TradeCreateOrConnectWithoutUserInput = {
    where: TradeWhereUniqueInput
    create: XOR<TradeCreateWithoutUserInput, TradeUncheckedCreateWithoutUserInput>
  }

  export type TradeCreateManyUserInputEnvelope = {
    data: TradeCreateManyUserInput | TradeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReferralCreateWithoutReferredUsersInput = {
    referralLink: string
    referralSignups?: number
    successfulReferrals?: number
    rewardsExchanged?: number
    creditsEarned?: number
    wallet?: number
    user?: UserCreateNestedOneWithoutReferralsInput
    referralUsages?: ReferralUsageCreateNestedManyWithoutReferralInput
  }

  export type ReferralUncheckedCreateWithoutReferredUsersInput = {
    id?: number
    referralLink: string
    referralSignups?: number
    successfulReferrals?: number
    rewardsExchanged?: number
    creditsEarned?: number
    userId?: number | null
    wallet?: number
    referralUsages?: ReferralUsageUncheckedCreateNestedManyWithoutReferralInput
  }

  export type ReferralCreateOrConnectWithoutReferredUsersInput = {
    where: ReferralWhereUniqueInput
    create: XOR<ReferralCreateWithoutReferredUsersInput, ReferralUncheckedCreateWithoutReferredUsersInput>
  }

  export type BlogCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: BlogCommentWhereUniqueInput
    update: XOR<BlogCommentUpdateWithoutUserInput, BlogCommentUncheckedUpdateWithoutUserInput>
    create: XOR<BlogCommentCreateWithoutUserInput, BlogCommentUncheckedCreateWithoutUserInput>
  }

  export type BlogCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: BlogCommentWhereUniqueInput
    data: XOR<BlogCommentUpdateWithoutUserInput, BlogCommentUncheckedUpdateWithoutUserInput>
  }

  export type BlogCommentUpdateManyWithWhereWithoutUserInput = {
    where: BlogCommentScalarWhereInput
    data: XOR<BlogCommentUpdateManyMutationInput, BlogCommentUncheckedUpdateManyWithoutUserInput>
  }

  export type BlogPostUpsertWithWhereUniqueWithoutUserInput = {
    where: BlogPostWhereUniqueInput
    update: XOR<BlogPostUpdateWithoutUserInput, BlogPostUncheckedUpdateWithoutUserInput>
    create: XOR<BlogPostCreateWithoutUserInput, BlogPostUncheckedCreateWithoutUserInput>
  }

  export type BlogPostUpdateWithWhereUniqueWithoutUserInput = {
    where: BlogPostWhereUniqueInput
    data: XOR<BlogPostUpdateWithoutUserInput, BlogPostUncheckedUpdateWithoutUserInput>
  }

  export type BlogPostUpdateManyWithWhereWithoutUserInput = {
    where: BlogPostScalarWhereInput
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyWithoutUserInput>
  }

  export type BlogPostScalarWhereInput = {
    AND?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
    OR?: BlogPostScalarWhereInput[]
    NOT?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
    id?: IntFilter<"BlogPost"> | number
    user_id?: IntFilter<"BlogPost"> | number
    title?: StringFilter<"BlogPost"> | string
    content?: StringFilter<"BlogPost"> | string
    created_at?: DateTimeFilter<"BlogPost"> | Date | string
    updated_at?: DateTimeFilter<"BlogPost"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
  }

  export type CommentUpdateManyWithWhereWithoutUserInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutUserInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: IntFilter<"Comment"> | number
    userId?: IntFilter<"Comment"> | number
    stockSymbol?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    viewCount?: IntFilter<"Comment"> | number
  }

  export type FavoriteApiUpsertWithWhereUniqueWithoutUserInput = {
    where: FavoriteApiWhereUniqueInput
    update: XOR<FavoriteApiUpdateWithoutUserInput, FavoriteApiUncheckedUpdateWithoutUserInput>
    create: XOR<FavoriteApiCreateWithoutUserInput, FavoriteApiUncheckedCreateWithoutUserInput>
  }

  export type FavoriteApiUpdateWithWhereUniqueWithoutUserInput = {
    where: FavoriteApiWhereUniqueInput
    data: XOR<FavoriteApiUpdateWithoutUserInput, FavoriteApiUncheckedUpdateWithoutUserInput>
  }

  export type FavoriteApiUpdateManyWithWhereWithoutUserInput = {
    where: FavoriteApiScalarWhereInput
    data: XOR<FavoriteApiUpdateManyMutationInput, FavoriteApiUncheckedUpdateManyWithoutUserInput>
  }

  export type FavoriteApiScalarWhereInput = {
    AND?: FavoriteApiScalarWhereInput | FavoriteApiScalarWhereInput[]
    OR?: FavoriteApiScalarWhereInput[]
    NOT?: FavoriteApiScalarWhereInput | FavoriteApiScalarWhereInput[]
    id?: IntFilter<"FavoriteApi"> | number
    userId?: IntFilter<"FavoriteApi"> | number
    symbol?: StringFilter<"FavoriteApi"> | string
  }

  export type FavoriteStockUpsertWithWhereUniqueWithoutUserInput = {
    where: FavoriteStockWhereUniqueInput
    update: XOR<FavoriteStockUpdateWithoutUserInput, FavoriteStockUncheckedUpdateWithoutUserInput>
    create: XOR<FavoriteStockCreateWithoutUserInput, FavoriteStockUncheckedCreateWithoutUserInput>
  }

  export type FavoriteStockUpdateWithWhereUniqueWithoutUserInput = {
    where: FavoriteStockWhereUniqueInput
    data: XOR<FavoriteStockUpdateWithoutUserInput, FavoriteStockUncheckedUpdateWithoutUserInput>
  }

  export type FavoriteStockUpdateManyWithWhereWithoutUserInput = {
    where: FavoriteStockScalarWhereInput
    data: XOR<FavoriteStockUpdateManyMutationInput, FavoriteStockUncheckedUpdateManyWithoutUserInput>
  }

  export type GoalUpsertWithWhereUniqueWithoutUserInput = {
    where: GoalWhereUniqueInput
    update: XOR<GoalUpdateWithoutUserInput, GoalUncheckedUpdateWithoutUserInput>
    create: XOR<GoalCreateWithoutUserInput, GoalUncheckedCreateWithoutUserInput>
  }

  export type GoalUpdateWithWhereUniqueWithoutUserInput = {
    where: GoalWhereUniqueInput
    data: XOR<GoalUpdateWithoutUserInput, GoalUncheckedUpdateWithoutUserInput>
  }

  export type GoalUpdateManyWithWhereWithoutUserInput = {
    where: GoalScalarWhereInput
    data: XOR<GoalUpdateManyMutationInput, GoalUncheckedUpdateManyWithoutUserInput>
  }

  export type GoalScalarWhereInput = {
    AND?: GoalScalarWhereInput | GoalScalarWhereInput[]
    OR?: GoalScalarWhereInput[]
    NOT?: GoalScalarWhereInput | GoalScalarWhereInput[]
    id?: IntFilter<"Goal"> | number
    title?: StringFilter<"Goal"> | string
    amount?: FloatFilter<"Goal"> | number
    deadline?: DateTimeFilter<"Goal"> | Date | string
    createdAt?: DateTimeFilter<"Goal"> | Date | string
    description?: StringNullableFilter<"Goal"> | string | null
    userId?: IntFilter<"Goal"> | number
  }

  export type LimitOrderUpsertWithWhereUniqueWithoutUserInput = {
    where: LimitOrderWhereUniqueInput
    update: XOR<LimitOrderUpdateWithoutUserInput, LimitOrderUncheckedUpdateWithoutUserInput>
    create: XOR<LimitOrderCreateWithoutUserInput, LimitOrderUncheckedCreateWithoutUserInput>
  }

  export type LimitOrderUpdateWithWhereUniqueWithoutUserInput = {
    where: LimitOrderWhereUniqueInput
    data: XOR<LimitOrderUpdateWithoutUserInput, LimitOrderUncheckedUpdateWithoutUserInput>
  }

  export type LimitOrderUpdateManyWithWhereWithoutUserInput = {
    where: LimitOrderScalarWhereInput
    data: XOR<LimitOrderUpdateManyMutationInput, LimitOrderUncheckedUpdateManyWithoutUserInput>
  }

  export type RedeemByUpsertWithWhereUniqueWithoutUserInput = {
    where: RedeemByWhereUniqueInput
    update: XOR<RedeemByUpdateWithoutUserInput, RedeemByUncheckedUpdateWithoutUserInput>
    create: XOR<RedeemByCreateWithoutUserInput, RedeemByUncheckedCreateWithoutUserInput>
  }

  export type RedeemByUpdateWithWhereUniqueWithoutUserInput = {
    where: RedeemByWhereUniqueInput
    data: XOR<RedeemByUpdateWithoutUserInput, RedeemByUncheckedUpdateWithoutUserInput>
  }

  export type RedeemByUpdateManyWithWhereWithoutUserInput = {
    where: RedeemByScalarWhereInput
    data: XOR<RedeemByUpdateManyMutationInput, RedeemByUncheckedUpdateManyWithoutUserInput>
  }

  export type RedeemByScalarWhereInput = {
    AND?: RedeemByScalarWhereInput | RedeemByScalarWhereInput[]
    OR?: RedeemByScalarWhereInput[]
    NOT?: RedeemByScalarWhereInput | RedeemByScalarWhereInput[]
    id?: IntFilter<"RedeemBy"> | number
    userId?: IntFilter<"RedeemBy"> | number
    dateOrdered?: DateTimeFilter<"RedeemBy"> | Date | string
    rewardId?: IntFilter<"RedeemBy"> | number
    cardCode?: StringFilter<"RedeemBy"> | string
  }

  export type ReferralUpsertWithWhereUniqueWithoutUserInput = {
    where: ReferralWhereUniqueInput
    update: XOR<ReferralUpdateWithoutUserInput, ReferralUncheckedUpdateWithoutUserInput>
    create: XOR<ReferralCreateWithoutUserInput, ReferralUncheckedCreateWithoutUserInput>
  }

  export type ReferralUpdateWithWhereUniqueWithoutUserInput = {
    where: ReferralWhereUniqueInput
    data: XOR<ReferralUpdateWithoutUserInput, ReferralUncheckedUpdateWithoutUserInput>
  }

  export type ReferralUpdateManyWithWhereWithoutUserInput = {
    where: ReferralScalarWhereInput
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyWithoutUserInput>
  }

  export type ReferralScalarWhereInput = {
    AND?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
    OR?: ReferralScalarWhereInput[]
    NOT?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
    id?: IntFilter<"Referral"> | number
    referralLink?: StringFilter<"Referral"> | string
    referralSignups?: IntFilter<"Referral"> | number
    successfulReferrals?: IntFilter<"Referral"> | number
    rewardsExchanged?: IntFilter<"Referral"> | number
    creditsEarned?: IntFilter<"Referral"> | number
    userId?: IntNullableFilter<"Referral"> | number | null
    wallet?: IntFilter<"Referral"> | number
  }

  export type ReferralUsageUpsertWithWhereUniqueWithoutUserInput = {
    where: ReferralUsageWhereUniqueInput
    update: XOR<ReferralUsageUpdateWithoutUserInput, ReferralUsageUncheckedUpdateWithoutUserInput>
    create: XOR<ReferralUsageCreateWithoutUserInput, ReferralUsageUncheckedCreateWithoutUserInput>
  }

  export type ReferralUsageUpdateWithWhereUniqueWithoutUserInput = {
    where: ReferralUsageWhereUniqueInput
    data: XOR<ReferralUsageUpdateWithoutUserInput, ReferralUsageUncheckedUpdateWithoutUserInput>
  }

  export type ReferralUsageUpdateManyWithWhereWithoutUserInput = {
    where: ReferralUsageScalarWhereInput
    data: XOR<ReferralUsageUpdateManyMutationInput, ReferralUsageUncheckedUpdateManyWithoutUserInput>
  }

  export type ReferralUsageScalarWhereInput = {
    AND?: ReferralUsageScalarWhereInput | ReferralUsageScalarWhereInput[]
    OR?: ReferralUsageScalarWhereInput[]
    NOT?: ReferralUsageScalarWhereInput | ReferralUsageScalarWhereInput[]
    id?: IntFilter<"ReferralUsage"> | number
    userId?: IntNullableFilter<"ReferralUsage"> | number | null
    referralId?: IntNullableFilter<"ReferralUsage"> | number | null
    createdAt?: DateTimeFilter<"ReferralUsage"> | Date | string
  }

  export type TradeUpsertWithWhereUniqueWithoutUserInput = {
    where: TradeWhereUniqueInput
    update: XOR<TradeUpdateWithoutUserInput, TradeUncheckedUpdateWithoutUserInput>
    create: XOR<TradeCreateWithoutUserInput, TradeUncheckedCreateWithoutUserInput>
  }

  export type TradeUpdateWithWhereUniqueWithoutUserInput = {
    where: TradeWhereUniqueInput
    data: XOR<TradeUpdateWithoutUserInput, TradeUncheckedUpdateWithoutUserInput>
  }

  export type TradeUpdateManyWithWhereWithoutUserInput = {
    where: TradeScalarWhereInput
    data: XOR<TradeUpdateManyMutationInput, TradeUncheckedUpdateManyWithoutUserInput>
  }

  export type ReferralUpsertWithoutReferredUsersInput = {
    update: XOR<ReferralUpdateWithoutReferredUsersInput, ReferralUncheckedUpdateWithoutReferredUsersInput>
    create: XOR<ReferralCreateWithoutReferredUsersInput, ReferralUncheckedCreateWithoutReferredUsersInput>
    where?: ReferralWhereInput
  }

  export type ReferralUpdateToOneWithWhereWithoutReferredUsersInput = {
    where?: ReferralWhereInput
    data: XOR<ReferralUpdateWithoutReferredUsersInput, ReferralUncheckedUpdateWithoutReferredUsersInput>
  }

  export type ReferralUpdateWithoutReferredUsersInput = {
    referralLink?: StringFieldUpdateOperationsInput | string
    referralSignups?: IntFieldUpdateOperationsInput | number
    successfulReferrals?: IntFieldUpdateOperationsInput | number
    rewardsExchanged?: IntFieldUpdateOperationsInput | number
    creditsEarned?: IntFieldUpdateOperationsInput | number
    wallet?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneWithoutReferralsNestedInput
    referralUsages?: ReferralUsageUpdateManyWithoutReferralNestedInput
  }

  export type ReferralUncheckedUpdateWithoutReferredUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    referralLink?: StringFieldUpdateOperationsInput | string
    referralSignups?: IntFieldUpdateOperationsInput | number
    successfulReferrals?: IntFieldUpdateOperationsInput | number
    rewardsExchanged?: IntFieldUpdateOperationsInput | number
    creditsEarned?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    wallet?: IntFieldUpdateOperationsInput | number
    referralUsages?: ReferralUsageUncheckedUpdateManyWithoutReferralNestedInput
  }

  export type UserCreateWithoutReferralsInput = {
    email: string
    password: string
    wallet?: number
    createdAt?: Date | string
    status?: string
    userReferralLink?: string | null
    username: string
    updatedAt?: Date | string
    name?: string | null
    phoneNumber?: number | null
    BlogComment?: BlogCommentCreateNestedManyWithoutUserInput
    BlogPost?: BlogPostCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    FavoriteApi?: FavoriteApiCreateNestedManyWithoutUserInput
    favoriteStocks?: FavoriteStockCreateNestedManyWithoutUserInput
    Goal?: GoalCreateNestedManyWithoutUserInput
    limitOrders?: LimitOrderCreateNestedManyWithoutUserInput
    RedeemBy?: RedeemByCreateNestedManyWithoutUserInput
    referralUsages?: ReferralUsageCreateNestedManyWithoutUserInput
    trading?: TradeCreateNestedManyWithoutUserInput
    referredBy?: ReferralCreateNestedOneWithoutReferredUsersInput
  }

  export type UserUncheckedCreateWithoutReferralsInput = {
    id?: number
    email: string
    password: string
    wallet?: number
    createdAt?: Date | string
    referredById?: number | null
    status?: string
    userReferralLink?: string | null
    username: string
    updatedAt?: Date | string
    name?: string | null
    phoneNumber?: number | null
    BlogComment?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    BlogPost?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    FavoriteApi?: FavoriteApiUncheckedCreateNestedManyWithoutUserInput
    favoriteStocks?: FavoriteStockUncheckedCreateNestedManyWithoutUserInput
    Goal?: GoalUncheckedCreateNestedManyWithoutUserInput
    limitOrders?: LimitOrderUncheckedCreateNestedManyWithoutUserInput
    RedeemBy?: RedeemByUncheckedCreateNestedManyWithoutUserInput
    referralUsages?: ReferralUsageUncheckedCreateNestedManyWithoutUserInput
    trading?: TradeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReferralsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
  }

  export type ReferralUsageCreateWithoutReferralInput = {
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutReferralUsagesInput
  }

  export type ReferralUsageUncheckedCreateWithoutReferralInput = {
    id?: number
    userId?: number | null
    createdAt?: Date | string
  }

  export type ReferralUsageCreateOrConnectWithoutReferralInput = {
    where: ReferralUsageWhereUniqueInput
    create: XOR<ReferralUsageCreateWithoutReferralInput, ReferralUsageUncheckedCreateWithoutReferralInput>
  }

  export type ReferralUsageCreateManyReferralInputEnvelope = {
    data: ReferralUsageCreateManyReferralInput | ReferralUsageCreateManyReferralInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutReferredByInput = {
    email: string
    password: string
    wallet?: number
    createdAt?: Date | string
    status?: string
    userReferralLink?: string | null
    username: string
    updatedAt?: Date | string
    name?: string | null
    phoneNumber?: number | null
    BlogComment?: BlogCommentCreateNestedManyWithoutUserInput
    BlogPost?: BlogPostCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    FavoriteApi?: FavoriteApiCreateNestedManyWithoutUserInput
    favoriteStocks?: FavoriteStockCreateNestedManyWithoutUserInput
    Goal?: GoalCreateNestedManyWithoutUserInput
    limitOrders?: LimitOrderCreateNestedManyWithoutUserInput
    RedeemBy?: RedeemByCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutUserInput
    referralUsages?: ReferralUsageCreateNestedManyWithoutUserInput
    trading?: TradeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReferredByInput = {
    id?: number
    email: string
    password: string
    wallet?: number
    createdAt?: Date | string
    status?: string
    userReferralLink?: string | null
    username: string
    updatedAt?: Date | string
    name?: string | null
    phoneNumber?: number | null
    BlogComment?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    BlogPost?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    FavoriteApi?: FavoriteApiUncheckedCreateNestedManyWithoutUserInput
    favoriteStocks?: FavoriteStockUncheckedCreateNestedManyWithoutUserInput
    Goal?: GoalUncheckedCreateNestedManyWithoutUserInput
    limitOrders?: LimitOrderUncheckedCreateNestedManyWithoutUserInput
    RedeemBy?: RedeemByUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutUserInput
    referralUsages?: ReferralUsageUncheckedCreateNestedManyWithoutUserInput
    trading?: TradeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReferredByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferredByInput, UserUncheckedCreateWithoutReferredByInput>
  }

  export type UserCreateManyReferredByInputEnvelope = {
    data: UserCreateManyReferredByInput | UserCreateManyReferredByInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutReferralsInput = {
    update: XOR<UserUpdateWithoutReferralsInput, UserUncheckedUpdateWithoutReferralsInput>
    create: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReferralsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReferralsInput, UserUncheckedUpdateWithoutReferralsInput>
  }

  export type UserUpdateWithoutReferralsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wallet?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    userReferralLink?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    BlogComment?: BlogCommentUpdateManyWithoutUserNestedInput
    BlogPost?: BlogPostUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    FavoriteApi?: FavoriteApiUpdateManyWithoutUserNestedInput
    favoriteStocks?: FavoriteStockUpdateManyWithoutUserNestedInput
    Goal?: GoalUpdateManyWithoutUserNestedInput
    limitOrders?: LimitOrderUpdateManyWithoutUserNestedInput
    RedeemBy?: RedeemByUpdateManyWithoutUserNestedInput
    referralUsages?: ReferralUsageUpdateManyWithoutUserNestedInput
    trading?: TradeUpdateManyWithoutUserNestedInput
    referredBy?: ReferralUpdateOneWithoutReferredUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutReferralsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wallet?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    userReferralLink?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    BlogComment?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    BlogPost?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    FavoriteApi?: FavoriteApiUncheckedUpdateManyWithoutUserNestedInput
    favoriteStocks?: FavoriteStockUncheckedUpdateManyWithoutUserNestedInput
    Goal?: GoalUncheckedUpdateManyWithoutUserNestedInput
    limitOrders?: LimitOrderUncheckedUpdateManyWithoutUserNestedInput
    RedeemBy?: RedeemByUncheckedUpdateManyWithoutUserNestedInput
    referralUsages?: ReferralUsageUncheckedUpdateManyWithoutUserNestedInput
    trading?: TradeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ReferralUsageUpsertWithWhereUniqueWithoutReferralInput = {
    where: ReferralUsageWhereUniqueInput
    update: XOR<ReferralUsageUpdateWithoutReferralInput, ReferralUsageUncheckedUpdateWithoutReferralInput>
    create: XOR<ReferralUsageCreateWithoutReferralInput, ReferralUsageUncheckedCreateWithoutReferralInput>
  }

  export type ReferralUsageUpdateWithWhereUniqueWithoutReferralInput = {
    where: ReferralUsageWhereUniqueInput
    data: XOR<ReferralUsageUpdateWithoutReferralInput, ReferralUsageUncheckedUpdateWithoutReferralInput>
  }

  export type ReferralUsageUpdateManyWithWhereWithoutReferralInput = {
    where: ReferralUsageScalarWhereInput
    data: XOR<ReferralUsageUpdateManyMutationInput, ReferralUsageUncheckedUpdateManyWithoutReferralInput>
  }

  export type UserUpsertWithWhereUniqueWithoutReferredByInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutReferredByInput, UserUncheckedUpdateWithoutReferredByInput>
    create: XOR<UserCreateWithoutReferredByInput, UserUncheckedCreateWithoutReferredByInput>
  }

  export type UserUpdateWithWhereUniqueWithoutReferredByInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutReferredByInput, UserUncheckedUpdateWithoutReferredByInput>
  }

  export type UserUpdateManyWithWhereWithoutReferredByInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutReferredByInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    wallet?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    referredById?: IntNullableFilter<"User"> | number | null
    status?: StringFilter<"User"> | string
    userReferralLink?: StringNullableFilter<"User"> | string | null
    username?: StringFilter<"User"> | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    name?: StringNullableFilter<"User"> | string | null
    phoneNumber?: IntNullableFilter<"User"> | number | null
  }

  export type ReferralCreateWithoutReferralUsagesInput = {
    referralLink: string
    referralSignups?: number
    successfulReferrals?: number
    rewardsExchanged?: number
    creditsEarned?: number
    wallet?: number
    user?: UserCreateNestedOneWithoutReferralsInput
    referredUsers?: UserCreateNestedManyWithoutReferredByInput
  }

  export type ReferralUncheckedCreateWithoutReferralUsagesInput = {
    id?: number
    referralLink: string
    referralSignups?: number
    successfulReferrals?: number
    rewardsExchanged?: number
    creditsEarned?: number
    userId?: number | null
    wallet?: number
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferredByInput
  }

  export type ReferralCreateOrConnectWithoutReferralUsagesInput = {
    where: ReferralWhereUniqueInput
    create: XOR<ReferralCreateWithoutReferralUsagesInput, ReferralUncheckedCreateWithoutReferralUsagesInput>
  }

  export type UserCreateWithoutReferralUsagesInput = {
    email: string
    password: string
    wallet?: number
    createdAt?: Date | string
    status?: string
    userReferralLink?: string | null
    username: string
    updatedAt?: Date | string
    name?: string | null
    phoneNumber?: number | null
    BlogComment?: BlogCommentCreateNestedManyWithoutUserInput
    BlogPost?: BlogPostCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    FavoriteApi?: FavoriteApiCreateNestedManyWithoutUserInput
    favoriteStocks?: FavoriteStockCreateNestedManyWithoutUserInput
    Goal?: GoalCreateNestedManyWithoutUserInput
    limitOrders?: LimitOrderCreateNestedManyWithoutUserInput
    RedeemBy?: RedeemByCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutUserInput
    trading?: TradeCreateNestedManyWithoutUserInput
    referredBy?: ReferralCreateNestedOneWithoutReferredUsersInput
  }

  export type UserUncheckedCreateWithoutReferralUsagesInput = {
    id?: number
    email: string
    password: string
    wallet?: number
    createdAt?: Date | string
    referredById?: number | null
    status?: string
    userReferralLink?: string | null
    username: string
    updatedAt?: Date | string
    name?: string | null
    phoneNumber?: number | null
    BlogComment?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    BlogPost?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    FavoriteApi?: FavoriteApiUncheckedCreateNestedManyWithoutUserInput
    favoriteStocks?: FavoriteStockUncheckedCreateNestedManyWithoutUserInput
    Goal?: GoalUncheckedCreateNestedManyWithoutUserInput
    limitOrders?: LimitOrderUncheckedCreateNestedManyWithoutUserInput
    RedeemBy?: RedeemByUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutUserInput
    trading?: TradeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReferralUsagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferralUsagesInput, UserUncheckedCreateWithoutReferralUsagesInput>
  }

  export type ReferralUpsertWithoutReferralUsagesInput = {
    update: XOR<ReferralUpdateWithoutReferralUsagesInput, ReferralUncheckedUpdateWithoutReferralUsagesInput>
    create: XOR<ReferralCreateWithoutReferralUsagesInput, ReferralUncheckedCreateWithoutReferralUsagesInput>
    where?: ReferralWhereInput
  }

  export type ReferralUpdateToOneWithWhereWithoutReferralUsagesInput = {
    where?: ReferralWhereInput
    data: XOR<ReferralUpdateWithoutReferralUsagesInput, ReferralUncheckedUpdateWithoutReferralUsagesInput>
  }

  export type ReferralUpdateWithoutReferralUsagesInput = {
    referralLink?: StringFieldUpdateOperationsInput | string
    referralSignups?: IntFieldUpdateOperationsInput | number
    successfulReferrals?: IntFieldUpdateOperationsInput | number
    rewardsExchanged?: IntFieldUpdateOperationsInput | number
    creditsEarned?: IntFieldUpdateOperationsInput | number
    wallet?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneWithoutReferralsNestedInput
    referredUsers?: UserUpdateManyWithoutReferredByNestedInput
  }

  export type ReferralUncheckedUpdateWithoutReferralUsagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    referralLink?: StringFieldUpdateOperationsInput | string
    referralSignups?: IntFieldUpdateOperationsInput | number
    successfulReferrals?: IntFieldUpdateOperationsInput | number
    rewardsExchanged?: IntFieldUpdateOperationsInput | number
    creditsEarned?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    wallet?: IntFieldUpdateOperationsInput | number
    referredUsers?: UserUncheckedUpdateManyWithoutReferredByNestedInput
  }

  export type UserUpsertWithoutReferralUsagesInput = {
    update: XOR<UserUpdateWithoutReferralUsagesInput, UserUncheckedUpdateWithoutReferralUsagesInput>
    create: XOR<UserCreateWithoutReferralUsagesInput, UserUncheckedCreateWithoutReferralUsagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReferralUsagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReferralUsagesInput, UserUncheckedUpdateWithoutReferralUsagesInput>
  }

  export type UserUpdateWithoutReferralUsagesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wallet?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    userReferralLink?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    BlogComment?: BlogCommentUpdateManyWithoutUserNestedInput
    BlogPost?: BlogPostUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    FavoriteApi?: FavoriteApiUpdateManyWithoutUserNestedInput
    favoriteStocks?: FavoriteStockUpdateManyWithoutUserNestedInput
    Goal?: GoalUpdateManyWithoutUserNestedInput
    limitOrders?: LimitOrderUpdateManyWithoutUserNestedInput
    RedeemBy?: RedeemByUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutUserNestedInput
    trading?: TradeUpdateManyWithoutUserNestedInput
    referredBy?: ReferralUpdateOneWithoutReferredUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutReferralUsagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wallet?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    userReferralLink?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    BlogComment?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    BlogPost?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    FavoriteApi?: FavoriteApiUncheckedUpdateManyWithoutUserNestedInput
    favoriteStocks?: FavoriteStockUncheckedUpdateManyWithoutUserNestedInput
    Goal?: GoalUncheckedUpdateManyWithoutUserNestedInput
    limitOrders?: LimitOrderUncheckedUpdateManyWithoutUserNestedInput
    RedeemBy?: RedeemByUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutUserNestedInput
    trading?: TradeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCommentInput = {
    email: string
    password: string
    wallet?: number
    createdAt?: Date | string
    status?: string
    userReferralLink?: string | null
    username: string
    updatedAt?: Date | string
    name?: string | null
    phoneNumber?: number | null
    BlogComment?: BlogCommentCreateNestedManyWithoutUserInput
    BlogPost?: BlogPostCreateNestedManyWithoutUserInput
    FavoriteApi?: FavoriteApiCreateNestedManyWithoutUserInput
    favoriteStocks?: FavoriteStockCreateNestedManyWithoutUserInput
    Goal?: GoalCreateNestedManyWithoutUserInput
    limitOrders?: LimitOrderCreateNestedManyWithoutUserInput
    RedeemBy?: RedeemByCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutUserInput
    referralUsages?: ReferralUsageCreateNestedManyWithoutUserInput
    trading?: TradeCreateNestedManyWithoutUserInput
    referredBy?: ReferralCreateNestedOneWithoutReferredUsersInput
  }

  export type UserUncheckedCreateWithoutCommentInput = {
    id?: number
    email: string
    password: string
    wallet?: number
    createdAt?: Date | string
    referredById?: number | null
    status?: string
    userReferralLink?: string | null
    username: string
    updatedAt?: Date | string
    name?: string | null
    phoneNumber?: number | null
    BlogComment?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    BlogPost?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    FavoriteApi?: FavoriteApiUncheckedCreateNestedManyWithoutUserInput
    favoriteStocks?: FavoriteStockUncheckedCreateNestedManyWithoutUserInput
    Goal?: GoalUncheckedCreateNestedManyWithoutUserInput
    limitOrders?: LimitOrderUncheckedCreateNestedManyWithoutUserInput
    RedeemBy?: RedeemByUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutUserInput
    referralUsages?: ReferralUsageUncheckedCreateNestedManyWithoutUserInput
    trading?: TradeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentInput, UserUncheckedCreateWithoutCommentInput>
  }

  export type UserUpsertWithoutCommentInput = {
    update: XOR<UserUpdateWithoutCommentInput, UserUncheckedUpdateWithoutCommentInput>
    create: XOR<UserCreateWithoutCommentInput, UserUncheckedCreateWithoutCommentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentInput, UserUncheckedUpdateWithoutCommentInput>
  }

  export type UserUpdateWithoutCommentInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wallet?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    userReferralLink?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    BlogComment?: BlogCommentUpdateManyWithoutUserNestedInput
    BlogPost?: BlogPostUpdateManyWithoutUserNestedInput
    FavoriteApi?: FavoriteApiUpdateManyWithoutUserNestedInput
    favoriteStocks?: FavoriteStockUpdateManyWithoutUserNestedInput
    Goal?: GoalUpdateManyWithoutUserNestedInput
    limitOrders?: LimitOrderUpdateManyWithoutUserNestedInput
    RedeemBy?: RedeemByUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutUserNestedInput
    referralUsages?: ReferralUsageUpdateManyWithoutUserNestedInput
    trading?: TradeUpdateManyWithoutUserNestedInput
    referredBy?: ReferralUpdateOneWithoutReferredUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wallet?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    userReferralLink?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    BlogComment?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    BlogPost?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    FavoriteApi?: FavoriteApiUncheckedUpdateManyWithoutUserNestedInput
    favoriteStocks?: FavoriteStockUncheckedUpdateManyWithoutUserNestedInput
    Goal?: GoalUncheckedUpdateManyWithoutUserNestedInput
    limitOrders?: LimitOrderUncheckedUpdateManyWithoutUserNestedInput
    RedeemBy?: RedeemByUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutUserNestedInput
    referralUsages?: ReferralUsageUncheckedUpdateManyWithoutUserNestedInput
    trading?: TradeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutFavoriteApiInput = {
    email: string
    password: string
    wallet?: number
    createdAt?: Date | string
    status?: string
    userReferralLink?: string | null
    username: string
    updatedAt?: Date | string
    name?: string | null
    phoneNumber?: number | null
    BlogComment?: BlogCommentCreateNestedManyWithoutUserInput
    BlogPost?: BlogPostCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    favoriteStocks?: FavoriteStockCreateNestedManyWithoutUserInput
    Goal?: GoalCreateNestedManyWithoutUserInput
    limitOrders?: LimitOrderCreateNestedManyWithoutUserInput
    RedeemBy?: RedeemByCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutUserInput
    referralUsages?: ReferralUsageCreateNestedManyWithoutUserInput
    trading?: TradeCreateNestedManyWithoutUserInput
    referredBy?: ReferralCreateNestedOneWithoutReferredUsersInput
  }

  export type UserUncheckedCreateWithoutFavoriteApiInput = {
    id?: number
    email: string
    password: string
    wallet?: number
    createdAt?: Date | string
    referredById?: number | null
    status?: string
    userReferralLink?: string | null
    username: string
    updatedAt?: Date | string
    name?: string | null
    phoneNumber?: number | null
    BlogComment?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    BlogPost?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    favoriteStocks?: FavoriteStockUncheckedCreateNestedManyWithoutUserInput
    Goal?: GoalUncheckedCreateNestedManyWithoutUserInput
    limitOrders?: LimitOrderUncheckedCreateNestedManyWithoutUserInput
    RedeemBy?: RedeemByUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutUserInput
    referralUsages?: ReferralUsageUncheckedCreateNestedManyWithoutUserInput
    trading?: TradeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFavoriteApiInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFavoriteApiInput, UserUncheckedCreateWithoutFavoriteApiInput>
  }

  export type UserUpsertWithoutFavoriteApiInput = {
    update: XOR<UserUpdateWithoutFavoriteApiInput, UserUncheckedUpdateWithoutFavoriteApiInput>
    create: XOR<UserCreateWithoutFavoriteApiInput, UserUncheckedCreateWithoutFavoriteApiInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFavoriteApiInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFavoriteApiInput, UserUncheckedUpdateWithoutFavoriteApiInput>
  }

  export type UserUpdateWithoutFavoriteApiInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wallet?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    userReferralLink?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    BlogComment?: BlogCommentUpdateManyWithoutUserNestedInput
    BlogPost?: BlogPostUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    favoriteStocks?: FavoriteStockUpdateManyWithoutUserNestedInput
    Goal?: GoalUpdateManyWithoutUserNestedInput
    limitOrders?: LimitOrderUpdateManyWithoutUserNestedInput
    RedeemBy?: RedeemByUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutUserNestedInput
    referralUsages?: ReferralUsageUpdateManyWithoutUserNestedInput
    trading?: TradeUpdateManyWithoutUserNestedInput
    referredBy?: ReferralUpdateOneWithoutReferredUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutFavoriteApiInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wallet?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    userReferralLink?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    BlogComment?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    BlogPost?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    favoriteStocks?: FavoriteStockUncheckedUpdateManyWithoutUserNestedInput
    Goal?: GoalUncheckedUpdateManyWithoutUserNestedInput
    limitOrders?: LimitOrderUncheckedUpdateManyWithoutUserNestedInput
    RedeemBy?: RedeemByUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutUserNestedInput
    referralUsages?: ReferralUsageUncheckedUpdateManyWithoutUserNestedInput
    trading?: TradeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutGoalInput = {
    email: string
    password: string
    wallet?: number
    createdAt?: Date | string
    status?: string
    userReferralLink?: string | null
    username: string
    updatedAt?: Date | string
    name?: string | null
    phoneNumber?: number | null
    BlogComment?: BlogCommentCreateNestedManyWithoutUserInput
    BlogPost?: BlogPostCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    FavoriteApi?: FavoriteApiCreateNestedManyWithoutUserInput
    favoriteStocks?: FavoriteStockCreateNestedManyWithoutUserInput
    limitOrders?: LimitOrderCreateNestedManyWithoutUserInput
    RedeemBy?: RedeemByCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutUserInput
    referralUsages?: ReferralUsageCreateNestedManyWithoutUserInput
    trading?: TradeCreateNestedManyWithoutUserInput
    referredBy?: ReferralCreateNestedOneWithoutReferredUsersInput
  }

  export type UserUncheckedCreateWithoutGoalInput = {
    id?: number
    email: string
    password: string
    wallet?: number
    createdAt?: Date | string
    referredById?: number | null
    status?: string
    userReferralLink?: string | null
    username: string
    updatedAt?: Date | string
    name?: string | null
    phoneNumber?: number | null
    BlogComment?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    BlogPost?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    FavoriteApi?: FavoriteApiUncheckedCreateNestedManyWithoutUserInput
    favoriteStocks?: FavoriteStockUncheckedCreateNestedManyWithoutUserInput
    limitOrders?: LimitOrderUncheckedCreateNestedManyWithoutUserInput
    RedeemBy?: RedeemByUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutUserInput
    referralUsages?: ReferralUsageUncheckedCreateNestedManyWithoutUserInput
    trading?: TradeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGoalInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGoalInput, UserUncheckedCreateWithoutGoalInput>
  }

  export type UserUpsertWithoutGoalInput = {
    update: XOR<UserUpdateWithoutGoalInput, UserUncheckedUpdateWithoutGoalInput>
    create: XOR<UserCreateWithoutGoalInput, UserUncheckedCreateWithoutGoalInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGoalInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGoalInput, UserUncheckedUpdateWithoutGoalInput>
  }

  export type UserUpdateWithoutGoalInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wallet?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    userReferralLink?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    BlogComment?: BlogCommentUpdateManyWithoutUserNestedInput
    BlogPost?: BlogPostUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    FavoriteApi?: FavoriteApiUpdateManyWithoutUserNestedInput
    favoriteStocks?: FavoriteStockUpdateManyWithoutUserNestedInput
    limitOrders?: LimitOrderUpdateManyWithoutUserNestedInput
    RedeemBy?: RedeemByUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutUserNestedInput
    referralUsages?: ReferralUsageUpdateManyWithoutUserNestedInput
    trading?: TradeUpdateManyWithoutUserNestedInput
    referredBy?: ReferralUpdateOneWithoutReferredUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutGoalInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wallet?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    userReferralLink?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    BlogComment?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    BlogPost?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    FavoriteApi?: FavoriteApiUncheckedUpdateManyWithoutUserNestedInput
    favoriteStocks?: FavoriteStockUncheckedUpdateManyWithoutUserNestedInput
    limitOrders?: LimitOrderUncheckedUpdateManyWithoutUserNestedInput
    RedeemBy?: RedeemByUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutUserNestedInput
    referralUsages?: ReferralUsageUncheckedUpdateManyWithoutUserNestedInput
    trading?: TradeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RewardCreateWithoutRedeemedByInput = {
    rewardName: string
    rewardDescription: string
    cost: number
    probability: Decimal | DecimalJsLike | number | string
  }

  export type RewardUncheckedCreateWithoutRedeemedByInput = {
    id?: number
    rewardName: string
    rewardDescription: string
    cost: number
    probability: Decimal | DecimalJsLike | number | string
  }

  export type RewardCreateOrConnectWithoutRedeemedByInput = {
    where: RewardWhereUniqueInput
    create: XOR<RewardCreateWithoutRedeemedByInput, RewardUncheckedCreateWithoutRedeemedByInput>
  }

  export type UserCreateWithoutRedeemByInput = {
    email: string
    password: string
    wallet?: number
    createdAt?: Date | string
    status?: string
    userReferralLink?: string | null
    username: string
    updatedAt?: Date | string
    name?: string | null
    phoneNumber?: number | null
    BlogComment?: BlogCommentCreateNestedManyWithoutUserInput
    BlogPost?: BlogPostCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    FavoriteApi?: FavoriteApiCreateNestedManyWithoutUserInput
    favoriteStocks?: FavoriteStockCreateNestedManyWithoutUserInput
    Goal?: GoalCreateNestedManyWithoutUserInput
    limitOrders?: LimitOrderCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutUserInput
    referralUsages?: ReferralUsageCreateNestedManyWithoutUserInput
    trading?: TradeCreateNestedManyWithoutUserInput
    referredBy?: ReferralCreateNestedOneWithoutReferredUsersInput
  }

  export type UserUncheckedCreateWithoutRedeemByInput = {
    id?: number
    email: string
    password: string
    wallet?: number
    createdAt?: Date | string
    referredById?: number | null
    status?: string
    userReferralLink?: string | null
    username: string
    updatedAt?: Date | string
    name?: string | null
    phoneNumber?: number | null
    BlogComment?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    BlogPost?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    FavoriteApi?: FavoriteApiUncheckedCreateNestedManyWithoutUserInput
    favoriteStocks?: FavoriteStockUncheckedCreateNestedManyWithoutUserInput
    Goal?: GoalUncheckedCreateNestedManyWithoutUserInput
    limitOrders?: LimitOrderUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutUserInput
    referralUsages?: ReferralUsageUncheckedCreateNestedManyWithoutUserInput
    trading?: TradeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRedeemByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRedeemByInput, UserUncheckedCreateWithoutRedeemByInput>
  }

  export type RewardUpsertWithoutRedeemedByInput = {
    update: XOR<RewardUpdateWithoutRedeemedByInput, RewardUncheckedUpdateWithoutRedeemedByInput>
    create: XOR<RewardCreateWithoutRedeemedByInput, RewardUncheckedCreateWithoutRedeemedByInput>
    where?: RewardWhereInput
  }

  export type RewardUpdateToOneWithWhereWithoutRedeemedByInput = {
    where?: RewardWhereInput
    data: XOR<RewardUpdateWithoutRedeemedByInput, RewardUncheckedUpdateWithoutRedeemedByInput>
  }

  export type RewardUpdateWithoutRedeemedByInput = {
    rewardName?: StringFieldUpdateOperationsInput | string
    rewardDescription?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    probability?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type RewardUncheckedUpdateWithoutRedeemedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    rewardName?: StringFieldUpdateOperationsInput | string
    rewardDescription?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    probability?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type UserUpsertWithoutRedeemByInput = {
    update: XOR<UserUpdateWithoutRedeemByInput, UserUncheckedUpdateWithoutRedeemByInput>
    create: XOR<UserCreateWithoutRedeemByInput, UserUncheckedCreateWithoutRedeemByInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRedeemByInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRedeemByInput, UserUncheckedUpdateWithoutRedeemByInput>
  }

  export type UserUpdateWithoutRedeemByInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wallet?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    userReferralLink?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    BlogComment?: BlogCommentUpdateManyWithoutUserNestedInput
    BlogPost?: BlogPostUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    FavoriteApi?: FavoriteApiUpdateManyWithoutUserNestedInput
    favoriteStocks?: FavoriteStockUpdateManyWithoutUserNestedInput
    Goal?: GoalUpdateManyWithoutUserNestedInput
    limitOrders?: LimitOrderUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutUserNestedInput
    referralUsages?: ReferralUsageUpdateManyWithoutUserNestedInput
    trading?: TradeUpdateManyWithoutUserNestedInput
    referredBy?: ReferralUpdateOneWithoutReferredUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutRedeemByInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wallet?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    userReferralLink?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    BlogComment?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    BlogPost?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    FavoriteApi?: FavoriteApiUncheckedUpdateManyWithoutUserNestedInput
    favoriteStocks?: FavoriteStockUncheckedUpdateManyWithoutUserNestedInput
    Goal?: GoalUncheckedUpdateManyWithoutUserNestedInput
    limitOrders?: LimitOrderUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutUserNestedInput
    referralUsages?: ReferralUsageUncheckedUpdateManyWithoutUserNestedInput
    trading?: TradeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RedeemByCreateWithoutRewardInput = {
    dateOrdered?: Date | string
    cardCode: string
    user: UserCreateNestedOneWithoutRedeemByInput
  }

  export type RedeemByUncheckedCreateWithoutRewardInput = {
    id?: number
    userId: number
    dateOrdered?: Date | string
    cardCode: string
  }

  export type RedeemByCreateOrConnectWithoutRewardInput = {
    where: RedeemByWhereUniqueInput
    create: XOR<RedeemByCreateWithoutRewardInput, RedeemByUncheckedCreateWithoutRewardInput>
  }

  export type RedeemByCreateManyRewardInputEnvelope = {
    data: RedeemByCreateManyRewardInput | RedeemByCreateManyRewardInput[]
    skipDuplicates?: boolean
  }

  export type RedeemByUpsertWithWhereUniqueWithoutRewardInput = {
    where: RedeemByWhereUniqueInput
    update: XOR<RedeemByUpdateWithoutRewardInput, RedeemByUncheckedUpdateWithoutRewardInput>
    create: XOR<RedeemByCreateWithoutRewardInput, RedeemByUncheckedCreateWithoutRewardInput>
  }

  export type RedeemByUpdateWithWhereUniqueWithoutRewardInput = {
    where: RedeemByWhereUniqueInput
    data: XOR<RedeemByUpdateWithoutRewardInput, RedeemByUncheckedUpdateWithoutRewardInput>
  }

  export type RedeemByUpdateManyWithWhereWithoutRewardInput = {
    where: RedeemByScalarWhereInput
    data: XOR<RedeemByUpdateManyMutationInput, RedeemByUncheckedUpdateManyWithoutRewardInput>
  }

  export type TaskAssignmentCreateManyTaskInput = {
    personId: number
    assignedAt?: Date | string
  }

  export type TaskAssignmentUpdateWithoutTaskInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    person?: PersonUpdateOneRequiredWithoutTasksNestedInput
  }

  export type TaskAssignmentUncheckedUpdateWithoutTaskInput = {
    personId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAssignmentUncheckedUpdateManyWithoutTaskInput = {
    personId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateManyStatusInput = {
    id?: number
    name: string
  }

  export type TaskUpdateWithoutStatusInput = {
    name?: StringFieldUpdateOperationsInput | string
    persons?: TaskAssignmentUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    persons?: TaskAssignmentUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TaskAssignmentCreateManyPersonInput = {
    taskId: number
    assignedAt?: Date | string
  }

  export type TaskAssignmentUpdateWithoutPersonInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutPersonsNestedInput
  }

  export type TaskAssignmentUncheckedUpdateWithoutPersonInput = {
    taskId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAssignmentUncheckedUpdateManyWithoutPersonInput = {
    taskId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockCreateManyCompanyInput = {
    stock_id?: number
    symbol: string
    sector?: string | null
    change?: number | null
  }

  export type StockUpdateWithoutCompanyInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    change?: NullableIntFieldUpdateOperationsInput | number | null
    favoriteStock?: FavoriteStockUpdateManyWithoutStockNestedInput
    hist_prices?: HistPriceUpdateManyWithoutStockNestedInput
    limitOrder?: LimitOrderUpdateManyWithoutStockNestedInput
    trading?: TradeUpdateManyWithoutStockNestedInput
  }

  export type StockUncheckedUpdateWithoutCompanyInput = {
    stock_id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    change?: NullableIntFieldUpdateOperationsInput | number | null
    favoriteStock?: FavoriteStockUncheckedUpdateManyWithoutStockNestedInput
    hist_prices?: HistPriceUncheckedUpdateManyWithoutStockNestedInput
    limitOrder?: LimitOrderUncheckedUpdateManyWithoutStockNestedInput
    trading?: TradeUncheckedUpdateManyWithoutStockNestedInput
  }

  export type StockUncheckedUpdateManyWithoutCompanyInput = {
    stock_id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    change?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FavoriteStockCreateManyStockInput = {
    id?: number
    userId: number
  }

  export type HistPriceCreateManyStockInput = {
    price_id?: number
    date: Date | string
    open_price?: Decimal | DecimalJsLike | number | string | null
    high_price?: Decimal | DecimalJsLike | number | string | null
    low_price?: Decimal | DecimalJsLike | number | string | null
    close_price: Decimal | DecimalJsLike | number | string
    volume?: bigint | number | null
  }

  export type LimitOrderCreateManyStockInput = {
    id?: number
    userId: number
    quantity: number
    limitPrice: Decimal | DecimalJsLike | number | string
    orderType: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TradeCreateManyStockInput = {
    id?: number
    userId?: number | null
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    tradeType: string
    tradeDate?: Date | string
  }

  export type FavoriteStockUpdateWithoutStockInput = {
    user?: UserUpdateOneRequiredWithoutFavoriteStocksNestedInput
  }

  export type FavoriteStockUncheckedUpdateWithoutStockInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type FavoriteStockUncheckedUpdateManyWithoutStockInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type HistPriceUpdateWithoutStockInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    open_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    high_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    low_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    volume?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type HistPriceUncheckedUpdateWithoutStockInput = {
    price_id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    open_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    high_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    low_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    volume?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type HistPriceUncheckedUpdateManyWithoutStockInput = {
    price_id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    open_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    high_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    low_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    volume?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type LimitOrderUpdateWithoutStockInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    limitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLimitOrdersNestedInput
  }

  export type LimitOrderUncheckedUpdateWithoutStockInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    limitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LimitOrderUncheckedUpdateManyWithoutStockInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    limitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeUpdateWithoutStockInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tradeType?: StringFieldUpdateOperationsInput | string
    tradeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutTradingNestedInput
  }

  export type TradeUncheckedUpdateWithoutStockInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tradeType?: StringFieldUpdateOperationsInput | string
    tradeDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeUncheckedUpdateManyWithoutStockInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tradeType?: StringFieldUpdateOperationsInput | string
    tradeDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogCommentCreateManyPostInput = {
    id?: number
    user_id: number
    comment: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BlogCommentUpdateWithoutPostInput = {
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBlogCommentNestedInput
  }

  export type BlogCommentUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogCommentUncheckedUpdateManyWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogCommentCreateManyUserInput = {
    id?: number
    post_id: number
    comment: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BlogPostCreateManyUserInput = {
    id?: number
    title: string
    content: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CommentCreateManyUserInput = {
    id?: number
    stockSymbol: string
    content: string
    createdAt?: Date | string
    viewCount?: number
  }

  export type FavoriteApiCreateManyUserInput = {
    id?: number
    symbol: string
  }

  export type FavoriteStockCreateManyUserInput = {
    id?: number
    stockId: number
  }

  export type GoalCreateManyUserInput = {
    id?: number
    title: string
    amount: number
    deadline: Date | string
    createdAt?: Date | string
    description?: string | null
  }

  export type LimitOrderCreateManyUserInput = {
    id?: number
    stockId: number
    quantity: number
    limitPrice: Decimal | DecimalJsLike | number | string
    orderType: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RedeemByCreateManyUserInput = {
    id?: number
    dateOrdered?: Date | string
    rewardId: number
    cardCode: string
  }

  export type ReferralCreateManyUserInput = {
    id?: number
    referralLink: string
    referralSignups?: number
    successfulReferrals?: number
    rewardsExchanged?: number
    creditsEarned?: number
    wallet?: number
  }

  export type ReferralUsageCreateManyUserInput = {
    id?: number
    referralId?: number | null
    createdAt?: Date | string
  }

  export type TradeCreateManyUserInput = {
    id?: number
    stockId: number
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    tradeType: string
    tradeDate?: Date | string
  }

  export type BlogCommentUpdateWithoutUserInput = {
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: BlogPostUpdateOneRequiredWithoutBlogCommentNestedInput
  }

  export type BlogCommentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    post_id?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogCommentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    post_id?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    BlogComment?: BlogCommentUpdateManyWithoutPostNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    BlogComment?: BlogCommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type BlogPostUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutUserInput = {
    stockSymbol?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewCount?: IntFieldUpdateOperationsInput | number
  }

  export type CommentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    stockSymbol?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewCount?: IntFieldUpdateOperationsInput | number
  }

  export type CommentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    stockSymbol?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewCount?: IntFieldUpdateOperationsInput | number
  }

  export type FavoriteApiUpdateWithoutUserInput = {
    symbol?: StringFieldUpdateOperationsInput | string
  }

  export type FavoriteApiUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
  }

  export type FavoriteApiUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
  }

  export type FavoriteStockUpdateWithoutUserInput = {
    stock?: StockUpdateOneRequiredWithoutFavoriteStockNestedInput
  }

  export type FavoriteStockUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    stockId?: IntFieldUpdateOperationsInput | number
  }

  export type FavoriteStockUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    stockId?: IntFieldUpdateOperationsInput | number
  }

  export type GoalUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GoalUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GoalUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LimitOrderUpdateWithoutUserInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    limitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stock?: StockUpdateOneRequiredWithoutLimitOrderNestedInput
  }

  export type LimitOrderUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    stockId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    limitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LimitOrderUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    stockId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    limitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RedeemByUpdateWithoutUserInput = {
    dateOrdered?: DateTimeFieldUpdateOperationsInput | Date | string
    cardCode?: StringFieldUpdateOperationsInput | string
    reward?: RewardUpdateOneRequiredWithoutRedeemedByNestedInput
  }

  export type RedeemByUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateOrdered?: DateTimeFieldUpdateOperationsInput | Date | string
    rewardId?: IntFieldUpdateOperationsInput | number
    cardCode?: StringFieldUpdateOperationsInput | string
  }

  export type RedeemByUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateOrdered?: DateTimeFieldUpdateOperationsInput | Date | string
    rewardId?: IntFieldUpdateOperationsInput | number
    cardCode?: StringFieldUpdateOperationsInput | string
  }

  export type ReferralUpdateWithoutUserInput = {
    referralLink?: StringFieldUpdateOperationsInput | string
    referralSignups?: IntFieldUpdateOperationsInput | number
    successfulReferrals?: IntFieldUpdateOperationsInput | number
    rewardsExchanged?: IntFieldUpdateOperationsInput | number
    creditsEarned?: IntFieldUpdateOperationsInput | number
    wallet?: IntFieldUpdateOperationsInput | number
    referralUsages?: ReferralUsageUpdateManyWithoutReferralNestedInput
    referredUsers?: UserUpdateManyWithoutReferredByNestedInput
  }

  export type ReferralUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    referralLink?: StringFieldUpdateOperationsInput | string
    referralSignups?: IntFieldUpdateOperationsInput | number
    successfulReferrals?: IntFieldUpdateOperationsInput | number
    rewardsExchanged?: IntFieldUpdateOperationsInput | number
    creditsEarned?: IntFieldUpdateOperationsInput | number
    wallet?: IntFieldUpdateOperationsInput | number
    referralUsages?: ReferralUsageUncheckedUpdateManyWithoutReferralNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferredByNestedInput
  }

  export type ReferralUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    referralLink?: StringFieldUpdateOperationsInput | string
    referralSignups?: IntFieldUpdateOperationsInput | number
    successfulReferrals?: IntFieldUpdateOperationsInput | number
    rewardsExchanged?: IntFieldUpdateOperationsInput | number
    creditsEarned?: IntFieldUpdateOperationsInput | number
    wallet?: IntFieldUpdateOperationsInput | number
  }

  export type ReferralUsageUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referral?: ReferralUpdateOneWithoutReferralUsagesNestedInput
  }

  export type ReferralUsageUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    referralId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUsageUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    referralId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeUpdateWithoutUserInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tradeType?: StringFieldUpdateOperationsInput | string
    tradeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    stock?: StockUpdateOneRequiredWithoutTradingNestedInput
  }

  export type TradeUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    stockId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tradeType?: StringFieldUpdateOperationsInput | string
    tradeDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    stockId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tradeType?: StringFieldUpdateOperationsInput | string
    tradeDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUsageCreateManyReferralInput = {
    id?: number
    userId?: number | null
    createdAt?: Date | string
  }

  export type UserCreateManyReferredByInput = {
    id?: number
    email: string
    password: string
    wallet?: number
    createdAt?: Date | string
    status?: string
    userReferralLink?: string | null
    username: string
    updatedAt?: Date | string
    name?: string | null
    phoneNumber?: number | null
  }

  export type ReferralUsageUpdateWithoutReferralInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutReferralUsagesNestedInput
  }

  export type ReferralUsageUncheckedUpdateWithoutReferralInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUsageUncheckedUpdateManyWithoutReferralInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutReferredByInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wallet?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    userReferralLink?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    BlogComment?: BlogCommentUpdateManyWithoutUserNestedInput
    BlogPost?: BlogPostUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    FavoriteApi?: FavoriteApiUpdateManyWithoutUserNestedInput
    favoriteStocks?: FavoriteStockUpdateManyWithoutUserNestedInput
    Goal?: GoalUpdateManyWithoutUserNestedInput
    limitOrders?: LimitOrderUpdateManyWithoutUserNestedInput
    RedeemBy?: RedeemByUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutUserNestedInput
    referralUsages?: ReferralUsageUpdateManyWithoutUserNestedInput
    trading?: TradeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReferredByInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wallet?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    userReferralLink?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    BlogComment?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    BlogPost?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    FavoriteApi?: FavoriteApiUncheckedUpdateManyWithoutUserNestedInput
    favoriteStocks?: FavoriteStockUncheckedUpdateManyWithoutUserNestedInput
    Goal?: GoalUncheckedUpdateManyWithoutUserNestedInput
    limitOrders?: LimitOrderUncheckedUpdateManyWithoutUserNestedInput
    RedeemBy?: RedeemByUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutUserNestedInput
    referralUsages?: ReferralUsageUncheckedUpdateManyWithoutUserNestedInput
    trading?: TradeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutReferredByInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wallet?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    userReferralLink?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RedeemByCreateManyRewardInput = {
    id?: number
    userId: number
    dateOrdered?: Date | string
    cardCode: string
  }

  export type RedeemByUpdateWithoutRewardInput = {
    dateOrdered?: DateTimeFieldUpdateOperationsInput | Date | string
    cardCode?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutRedeemByNestedInput
  }

  export type RedeemByUncheckedUpdateWithoutRewardInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    dateOrdered?: DateTimeFieldUpdateOperationsInput | Date | string
    cardCode?: StringFieldUpdateOperationsInput | string
  }

  export type RedeemByUncheckedUpdateManyWithoutRewardInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    dateOrdered?: DateTimeFieldUpdateOperationsInput | Date | string
    cardCode?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}